Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/casper/casperMecanumDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.casper;\n\nimport androidx.annotation.NonNull;\n\nimport com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.canvas.Canvas;\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.telemetry.TelemetryPacket;\nimport com.acmerobotics.roadrunner.control.PIDCoefficients;\nimport com.acmerobotics.roadrunner.control.PIDFController;\nimport com.acmerobotics.roadrunner.drive.DriveSignal;\nimport com.acmerobotics.roadrunner.drive.MecanumDrive;\nimport com.acmerobotics.roadrunner.followers.HolonomicPIDVAFollower;\nimport com.acmerobotics.roadrunner.followers.TrajectoryFollower;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.profile.MotionProfile;\nimport com.acmerobotics.roadrunner.profile.MotionProfileGenerator;\nimport com.acmerobotics.roadrunner.profile.MotionState;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\nimport com.acmerobotics.roadrunner.trajectory.constraints.DriveConstraints;\nimport com.acmerobotics.roadrunner.trajectory.constraints.MecanumConstraints;\nimport com.acmerobotics.roadrunner.util.NanoClock;\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.hardware.lynx.LynxModule;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.hardware.VoltageSensor;\nimport com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;\nimport com.qualcomm.robotcore.util.Range;\nimport com.qualcomm.robotcore.util.RobotLog;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n\nimport org.firstinspires.ftc.teamcode.drive.StandardTrackingWheelLocalizer;\nimport org.firstinspires.ftc.teamcode.util.DashboardUtil;\nimport org.firstinspires.ftc.teamcode.util.LynxModuleUtil;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.BASE_CONSTRAINTS;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.TRACK_WIDTH;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.encoderTicksToInches;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kA;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kStatic;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;\n\n/*\n * Casper mecanum drive hardware implementation for REV hardware.\n */\n@Config\npublic class casperMecanumDrive extends MecanumDrive {\n    public static PIDCoefficients TRANSLATIONAL_PID = new PIDCoefficients(8, 0, 0.0001);\n    public static PIDCoefficients HEADING_PID = new PIDCoefficients(26.5, 0.00005, 0.0005);\n\n    public static double LATERAL_MULTIPLIER = 2;\n\n    public static double VX_WEIGHT = 1;\n    public static double VY_WEIGHT = 1;\n    public static double OMEGA_WEIGHT = 1;\n\n    public static int POSE_HISTORY_LIMIT = 100;\n\n    public enum Mode {\n        IDLE,\n        TURN,\n        FOLLOW_TRAJECTORY\n    }\n\n    private FtcDashboard dashboard;\n    private NanoClock clock;\n\n    private org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive.Mode mode;\n\n    private PIDFController turnController;\n    private MotionProfile turnProfile;\n    private double turnStart;\n\n    private DriveConstraints constraints;\n    private TrajectoryFollower follower;\n\n    private LinkedList<Pose2d> poseHistory;\n\n    private DcMotorEx leftFront, leftRear, rightRear, rightFront;\n    private List<DcMotorEx> motors;\n    private BNO055IMU imu;\n\n    private VoltageSensor batteryVoltageSensor;\n\n    private Pose2d lastPoseOnTurn;\n\n    //Casper Attachments to be added here\n    public DcMotor collectMotor   = null;\n    public DcMotor shootMotorLeft = null;\n\n    //\n    public DcMotor wobbleMotor    = null;\n    public Servo wobbleServo      = null;\n\n    public casperMecanumDrive(HardwareMap hardwareMap) {\n        super(kV, kA, kStatic, TRACK_WIDTH, TRACK_WIDTH, LATERAL_MULTIPLIER);\n        RobotLog.ii(\"CASPER\", \"Enter - casperMecanumDrive\");\n\n        dashboard = FtcDashboard.getInstance();\n        dashboard.setTelemetryTransmissionInterval(25);\n\n        clock = NanoClock.system();\n\n        mode = org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive.Mode.IDLE;\n\n        turnController = new PIDFController(HEADING_PID);\n        turnController.setInputBounds(0, 2 * Math.PI);\n\n        constraints = new MecanumConstraints(BASE_CONSTRAINTS, TRACK_WIDTH);\n        follower = new HolonomicPIDVAFollower(TRANSLATIONAL_PID, TRANSLATIONAL_PID, HEADING_PID,\n                new Pose2d(0.5, 0.5, Math.toRadians(5.0)), 0.5);\n\n        poseHistory = new LinkedList<>();\n\n        LynxModuleUtil.ensureMinimumFirmwareVersion(hardwareMap);\n\n        batteryVoltageSensor = hardwareMap.voltageSensor.iterator().next();\n\n        for (LynxModule module : hardwareMap.getAll(LynxModule.class)) {\n            module.setBulkCachingMode(LynxModule.BulkCachingMode.AUTO);\n        }\n\n\n        // TODO: adjust the names of the following hardware devices to match your configuration\n        imu = hardwareMap.get(BNO055IMU.class, \"imu 1\");\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS;\n        imu.initialize(parameters);\n\n        // TODO: if your hub is mounted vertically, remap the IMU axes so that the z-axis points\n        // upward (normal to the floor) using a command like the following:\n        // BNO055IMUUtil.remapAxes(imu, AxesOrder.XYZ, AxesSigns.NPN);\n\n        leftFront = hardwareMap.get(DcMotorEx.class, \"M1\");\n        rightFront = hardwareMap.get(DcMotorEx.class, \"M2\");\n        leftRear = hardwareMap.get(DcMotorEx.class, \"M3\");\n        rightRear = hardwareMap.get(DcMotorEx.class, \"M4\");\n\n        motors = Arrays.asList(leftFront, leftRear, rightRear, rightFront);\n\n        for (DcMotorEx motor : motors) {\n            MotorConfigurationType motorConfigurationType = motor.getMotorType().clone();\n            motorConfigurationType.setAchieveableMaxRPMFraction(1.0);\n            motor.setMotorType(motorConfigurationType);\n        }\n\n        if (RUN_USING_ENCODER) {\n            setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        }\n\n        setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        if (RUN_USING_ENCODER && MOTOR_VELO_PID != null) {\n            setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, MOTOR_VELO_PID);\n        }\n\n        // TODO: reverse any motors using DcMotor.setDirection()\n        leftFront.setDirection(DcMotorEx.Direction.REVERSE);\n        leftRear.setDirection(DcMotorEx.Direction.REVERSE);\n\n        // TODO: if desired, use setLocalizer() to change the localization method\n        // for instance, setLocalizer(new ThreeTrackingWheelLocalizer(...));\n        setLocalizer(new StandardTrackingWheelLocalizer(hardwareMap));\n\n        //Attachement initialization\n        collectMotor = hardwareMap.get(DcMotor.class, \"M5\");\n        shootMotorLeft = hardwareMap.get(DcMotor.class, \"M7\");\n        wobbleMotor = hardwareMap.get(DcMotor.class, \"M8\");\n        wobbleServo = hardwareMap.get(Servo.class, \"wobbleServo\");\n\n        collectMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        shootMotorLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        RobotLog.ii(\"CASPER\", \"...\");\n\n    }\n\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose) {\n        return new TrajectoryBuilder(startPose, constraints);\n    }\n\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, boolean reversed) {\n        return new TrajectoryBuilder(startPose, reversed, constraints);\n    }\n\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, double startHeading) {\n        return new TrajectoryBuilder(startPose, startHeading, constraints);\n    }\n\n    public void turnAsync(double angle) {\n        double heading = getPoseEstimate().getHeading();\n\n        lastPoseOnTurn = getPoseEstimate();\n\n        turnProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                new MotionState(heading, 0, 0, 0),\n                new MotionState(heading + angle, 0, 0, 0),\n                constraints.maxAngVel,\n                constraints.maxAngAccel,\n                constraints.maxAngJerk\n        );\n\n        turnStart = clock.seconds();\n        mode = org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive.Mode.TURN;\n    }\n\n    public void turn(double angle) {\n        turnAsync(angle);\n        waitForIdle();\n    }\n\n    public void followTrajectoryAsync(Trajectory trajectory) {\n        follower.followTrajectory(trajectory);\n        mode = org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive.Mode.FOLLOW_TRAJECTORY;\n    }\n\n    public void followTrajectory(Trajectory trajectory) {\n        followTrajectoryAsync(trajectory);\n        waitForIdle();\n    }\n\n    public Pose2d getLastError() {\n        switch (mode) {\n            case FOLLOW_TRAJECTORY:\n                return follower.getLastError();\n            case TURN:\n                return new Pose2d(0, 0, turnController.getLastError());\n            case IDLE:\n                return new Pose2d();\n        }\n        throw new AssertionError();\n    }\n\n    public void update() {\n        updatePoseEstimate();\n\n        Pose2d currentPose = getPoseEstimate();\n        Pose2d lastError = getLastError();\n\n        poseHistory.add(currentPose);\n\n        if (POSE_HISTORY_LIMIT > -1 && poseHistory.size() > POSE_HISTORY_LIMIT) {\n            poseHistory.removeFirst();\n        }\n\n        TelemetryPacket packet = new TelemetryPacket();\n        Canvas fieldOverlay = packet.fieldOverlay();\n\n        packet.put(\"mode\", mode);\n\n        packet.put(\"x\", currentPose.getX());\n        packet.put(\"y\", currentPose.getY());\n        packet.put(\"heading\", currentPose.getHeading());\n\n        packet.put(\"xError\", lastError.getX());\n        packet.put(\"yError\", lastError.getY());\n        packet.put(\"headingError\", lastError.getHeading());\n\n        switch (mode) {\n            case IDLE:\n                // do nothing\n                break;\n            case TURN: {\n                double t = clock.seconds() - turnStart;\n\n                MotionState targetState = turnProfile.get(t);\n\n                turnController.setTargetPosition(targetState.getX());\n\n                double correction = turnController.update(currentPose.getHeading());\n\n                double targetOmega = targetState.getV();\n                double targetAlpha = targetState.getA();\n                setDriveSignal(new DriveSignal(new Pose2d(\n                        0, 0, targetOmega + correction\n                ), new Pose2d(\n                        0, 0, targetAlpha\n                )));\n\n                Pose2d newPose = lastPoseOnTurn.copy(lastPoseOnTurn.getX(), lastPoseOnTurn.getY(), targetState.getX());\n\n                fieldOverlay.setStroke(\"#4CAF50\");\n                DashboardUtil.drawRobot(fieldOverlay, newPose);\n\n                if (t >= turnProfile.duration()) {\n                    mode = org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive.Mode.IDLE;\n                    setDriveSignal(new DriveSignal());\n                }\n\n                break;\n            }\n            case FOLLOW_TRAJECTORY: {\n                setDriveSignal(follower.update(currentPose));\n\n                Trajectory trajectory = follower.getTrajectory();\n\n                fieldOverlay.setStrokeWidth(1);\n                fieldOverlay.setStroke(\"#4CAF50\");\n                DashboardUtil.drawSampledPath(fieldOverlay, trajectory.getPath());\n                double t = follower.elapsedTime();\n                DashboardUtil.drawRobot(fieldOverlay, trajectory.get(t));\n\n                fieldOverlay.setStroke(\"#3F51B5\");\n                DashboardUtil.drawPoseHistory(fieldOverlay, poseHistory);\n\n                if (!follower.isFollowing()) {\n                    mode = org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive.Mode.IDLE;\n                    setDriveSignal(new DriveSignal());\n                }\n\n                break;\n            }\n        }\n\n        fieldOverlay.setStroke(\"#3F51B5\");\n        DashboardUtil.drawRobot(fieldOverlay, currentPose);\n\n        dashboard.sendTelemetryPacket(packet);\n    }\n\n    public void waitForIdle() {\n        while (!Thread.currentThread().isInterrupted() && isBusy()) {\n            update();\n        }\n    }\n\n    public boolean isBusy() {\n        return mode != org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive.Mode.IDLE;\n    }\n\n    public void setMode(DcMotor.RunMode runMode) {\n        for (DcMotorEx motor : motors) {\n            motor.setMode(runMode);\n        }\n    }\n\n    public void setZeroPowerBehavior(DcMotor.ZeroPowerBehavior zeroPowerBehavior) {\n        for (DcMotorEx motor : motors) {\n            motor.setZeroPowerBehavior(zeroPowerBehavior);\n        }\n    }\n\n    public void setPIDFCoefficients(DcMotor.RunMode runMode, PIDFCoefficients coefficients) {\n        PIDFCoefficients compensatedCoefficients = new PIDFCoefficients(\n                coefficients.p, coefficients.i, coefficients.d,\n                coefficients.f * 12 / batteryVoltageSensor.getVoltage()\n        );\n        for (DcMotorEx motor : motors) {\n            motor.setPIDFCoefficients(runMode, compensatedCoefficients);\n        }\n    }\n\n    public void setWeightedDrivePower(Pose2d drivePower) {\n        Pose2d vel = drivePower;\n\n        if (Math.abs(drivePower.getX()) + Math.abs(drivePower.getY())\n                + Math.abs(drivePower.getHeading()) > 1) {\n            // re-normalize the powers according to the weights\n            double denom = VX_WEIGHT * Math.abs(drivePower.getX())\n                    + VY_WEIGHT * Math.abs(drivePower.getY())\n                    + OMEGA_WEIGHT * Math.abs(drivePower.getHeading());\n\n            vel = new Pose2d(\n                    VX_WEIGHT * drivePower.getX(),\n                    VY_WEIGHT * drivePower.getY(),\n                    OMEGA_WEIGHT * drivePower.getHeading()\n            ).div(denom);\n        }\n\n        setDrivePower(vel);\n    }\n\n    @NonNull\n    @Override\n    public List<Double> getWheelPositions() {\n        List<Double> wheelPositions = new ArrayList<>();\n        for (DcMotorEx motor : motors) {\n            wheelPositions.add(encoderTicksToInches(motor.getCurrentPosition()));\n        }\n        return wheelPositions;\n    }\n\n    @Override\n    public List<Double> getWheelVelocities() {\n        List<Double> wheelVelocities = new ArrayList<>();\n        for (DcMotorEx motor : motors) {\n            wheelVelocities.add(encoderTicksToInches(motor.getVelocity()));\n        }\n        return wheelVelocities;\n    }\n\n    @Override\n    public void setMotorPowers(double v, double v1, double v2, double v3) {\n        leftFront.setPower(v);\n        leftRear.setPower(v1);\n        rightRear.setPower(v2);\n        rightFront.setPower(v3);\n    }\n\n    @Override\n    public double getRawExternalHeading() {\n        return imu.getAngularOrientation().firstAngle;\n    }\n\n    public void moveHolonomic(double x, double y , double z)\n    {\n        double max_power = 0.6;\n        double min_power = -1*max_power;\n\n        double fl_power = Range.clip(y + x - z, min_power, max_power);\n        double fr_power = Range.clip(y - x + z, min_power, max_power);\n        double br_power = Range.clip(y + x + z, min_power, max_power);\n        double bl_power = Range.clip(y - x - z, min_power, max_power);\n        setMotorPowers(fl_power, bl_power, br_power, fr_power);\n    }\n\n    public void stopAllMotors() {\n        RobotLog.ii(\"CAL\", \"Stopping All motors\");\n        setMotorPowers(0,0,0,0);\n        shootMotorLeft.setPower(0);\n        wobbleMotor.setPower(0);\n        collectMotor.setPower(0);\n    }\n\n    public void openWobbleClaw() {\n        wobbleServo.setPosition(-0.4);\n    }\n\n    public void  closeWobbleClaw() {\n        wobbleServo.setPosition(0.2);\n\n    }\n\n    public void  autonomousShoot() {\n        shootMotorLeft.setPower(0.7);\n        collectMotor.setPower(0.6);\n\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/casper/casperMecanumDrive.java	(revision 6295462c6a0cdbfcf3f1601b4e8371747d3dea47)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/casper/casperMecanumDrive.java	(date 1611013325579)
@@ -1,7 +1,5 @@
 package org.firstinspires.ftc.teamcode.casper;
 
-import androidx.annotation.NonNull;
-
 import com.acmerobotics.dashboard.FtcDashboard;
 import com.acmerobotics.dashboard.canvas.Canvas;
 import com.acmerobotics.dashboard.config.Config;
@@ -32,7 +30,6 @@
 import com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;
 import com.qualcomm.robotcore.util.Range;
 import com.qualcomm.robotcore.util.RobotLog;
-import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 
 import org.firstinspires.ftc.teamcode.drive.StandardTrackingWheelLocalizer;
 import org.firstinspires.ftc.teamcode.util.DashboardUtil;
@@ -43,6 +40,8 @@
 import java.util.LinkedList;
 import java.util.List;
 
+import androidx.annotation.NonNull;
+
 import static org.firstinspires.ftc.teamcode.drive.DriveConstants.BASE_CONSTRAINTS;
 import static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;
 import static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;
@@ -439,13 +438,13 @@
     }
 
     public void  closeWobbleClaw() {
-        wobbleServo.setPosition(0.2);
+        wobbleServo.setPosition(0.1);
 
     }
 
     public void  autonomousShoot() {
         shootMotorLeft.setPower(0.7);
-        collectMotor.setPower(0.6);
+        collectMotor.setPower(0.6); 
 
     }
 
