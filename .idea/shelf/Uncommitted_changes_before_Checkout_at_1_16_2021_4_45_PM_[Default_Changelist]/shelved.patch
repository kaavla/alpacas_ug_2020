Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/testBotAutonomousBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestBot;\r\nimport android.app.Activity;\r\nimport android.graphics.Color;\r\nimport android.view.View;\r\n\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.DriveConstraints;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.ColorSensor;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\nimport com.qualcomm.robotcore.util.RobotLog;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\r\nimport org.firstinspires.ftc.teamcode.TestBot.testBotHW;\r\n\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\n//@Disabled\r\npublic class testBotAutonomousBase extends LinearOpMode {\r\n\r\n    public enum Direction {\r\n        FORWARD, BACKWARD, STRAFE_RIGHT, STRAFE_LEFT, SLIDE_UP, SLIDE_DOWN, SLIDE_IN, SLIDE_OUT, DIAGONAL_LEFT, DIAGONAL_RIGHT;\r\n    }\r\n\r\n    public enum SensorsToUse {\r\n        NONE, USE_COLOR_LEFT, USE_COLOR_RIGHT, USE_DISTANCE_LEFT, USE_DISTANCE_RIGHT, USE_TOUCH,\r\n        USE_DISTANCE_RIGHT_BLD, USE_DISTANCE_LEFT_BLD, USE_DISTANCE_LEFT_FDT, USE_DISTANCE_RIGHT_FDT,\r\n        USE_DISTANCE_FRONT;\r\n    }\r\n\r\n    public enum SideToUse {\r\n        USE_LEFT, USE_RIGHT;\r\n    }\r\n\r\n    public testBotHW robot = new testBotHW();\r\n    public ElapsedTime runtime = new ElapsedTime();\r\n    private Orientation lastAngles = new Orientation();\r\n    private double globalAngle = 0;\r\n    // public direction;\r\n    public double ref_angle = 0;\r\n    public double ref_angle_1 = 0;\r\n\r\n    public Direction direction;\r\n\r\n    public double distance_traveled = 0;\r\n\r\n    public static final double TICKS_PER_REV = 383.6;\r\n    public static final double MAX_RPM = 435;\r\n    static final double DRIVE_GEAR_REDUCTION = 2.0;     // This is < 1.0 if geared UP\r\n    static final double WHEEL_DIAMETER_INCHES = 4.0;     // For figuring circumference\r\n    static final double COUNTS_PER_INCH = (TICKS_PER_REV * DRIVE_GEAR_REDUCTION) / (WHEEL_DIAMETER_INCHES * 3.1415);\r\n    static final double PULLEY_COUNTS_PER_INCH = (50.9 * 28) / (1 * 3.1415); //gobilda 5202 117 rpm motors\r\n    static final double INOUT_COUNTS_PER_INCH = (19.2 * 28) / (2 * 3.1415); //gobilda 5202 117 rpm motors\r\n    public static double WHEEL_RADIUS = 1.9685; // in\r\n    public static double GEAR_RATIO = 1; // output (wheel) speed / input (motor) speed\r\n    public static double TRACK_WIDTH = 17.66; // in\r\n    static final double DRIVE_SPEED = 0.3;\r\n    static final double TURN_SPEED = 0.7;\r\n\r\n    private static final String TFOD_MODEL_ASSET = \"Skystone.tflite\";\r\n    private static final String LABEL_FIRST_ELEMENT = \"Stone\";\r\n    private static final String LABEL_SECOND_ELEMENT = \"Skystone\";\r\n    final String VUFORIA_KEY = \"ATVrdOT/////AAABmegFa9L6UUB2ljwRjEStPmU7NS6gi/+GLAe6uAv7o+cB7+pj9EORNLk32cxovTaRj+rUeNw75EMjs5jM0K2OlNn8iO861FyZ5bqnHeBQRr/tR4NIZkQq4ak2zpPLQyyGFzhEkHjnhenYh0dyvxluXF79u8VwJ+g77slCyrCjvgMp6VfEAPLpVJmjzq4hRJMtjYpoRp/agnYFU8HVnmQeGRbjKi1PHLbhP98IkGMowt6Hlobdd2l0vt7msVhwNombHz0XcwJEjwnRKoOkeg7s+kIWvd5paYiO/bnClo9DahFboEFWw1/9wutXgI6/7AGcvwZzkk1HwRh3qZRAWNUSq1hrcjdq9f2QXAYyiqd3wLpT\";\r\n\r\n\r\n    public TFObjectDetector tfod = null;\r\n    public VuforiaLocalizer vuforia = null;\r\n\r\n    @Override\r\n    public void runOpMode() throws InterruptedException {\r\n        //Empty Function\r\n    }\r\n\r\n    public static DriveConstraints BASE_CONSTRAINTS = new DriveConstraints(\r\n            40.0, 40.0, 0.0,\r\n            Math.toRadians(180.0), Math.toRadians(180.0), 0.0\r\n    );\r\n\r\n\r\n    public static double encoderTicksToInches(double ticks) {\r\n        return WHEEL_RADIUS * 2 * Math.PI * GEAR_RATIO * ticks / TICKS_PER_REV;\r\n    }\r\n\r\n    public static double rpmToVelocity(double rpm) {\r\n        return rpm * GEAR_RATIO * 2 * Math.PI * WHEEL_RADIUS / 60.0;\r\n    }\r\n\r\n    public static double getMotorVelocityF(double ticksPerSecond) {\r\n        // see https://docs.google.com/document/d/1tyWrXDfMidwYyP_5H4mZyVgaEswhOC35gvdmP-V-5hA/edit#heading=h.61g9ixenznbx\r\n        return 32767 / ticksPerSecond;\r\n    }\r\n\r\n    private void initVuforia() {\r\n        RobotLog.ii(\"CAL\", \"Enter -  initVuforia\");\r\n\r\n        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\r\n        parameters.vuforiaLicenseKey = VUFORIA_KEY;\r\n        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.BACK;\r\n        vuforia = ClassFactory.getInstance().createVuforia(parameters);\r\n\r\n        RobotLog.ii(\"CAL\", \"Exit -  initVuforia\");\r\n        telemetry.addData(\"Path1\", \"Init Vuforia Done\");\r\n        telemetry.update();\r\n    }\r\n\r\n    private void initTfod() {\r\n        RobotLog.ii(\"CAL\", \"Enter -  initTfod\");\r\n        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\r\n                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\r\n        tfodParameters.minimumConfidence = 0.8;\r\n        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\r\n        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\r\n\r\n        RobotLog.ii(\"CAL\", \"Exit -  initTfod\");\r\n        telemetry.addData(\"Path1\", \"initTfod Done\");\r\n        telemetry.update();\r\n    }\r\n\r\n    public void initHW() {\r\n        RobotLog.ii(\"CAL\", \"Enter -  initHW\");\r\n        robot.init(hardwareMap);\r\n        //HELLO PLEASE ADD SOMETHING TO INITIALIZE CLOSING THE WOBBLE GOAL CLAW\r\n        //THANKS\r\n        //robot.initMotorEncoders();\r\n        /*\r\n        initVuforia();\r\n\r\n        if (ClassFactory.getInstance().canCreateTFObjectDetector()) {\r\n            initTfod();\r\n        } else {\r\n            telemetry.addData(\"Sorry!\", \"This device is not compatible with TFOD\");\r\n        }\r\n\r\n        if (tfod != null) {\r\n            tfod.activate();\r\n        }\r\n        */\r\n        telemetry.addData(\"Path1\", \"Init HW Done\");\r\n        telemetry.update();\r\n\r\n        RobotLog.ii(\"CAL\", \"Exit -  initHW\");\r\n    }\r\n\r\n    private void resetAngle() {\r\n        lastAngles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        RobotLog.ii(\"CAL\", \"resetAngle - lastAngles = %2.2f\", lastAngles.firstAngle);\r\n        globalAngle = 0;\r\n    }\r\n\r\n    public double getAngle() {\r\n        // We experimentally determined the Z axis is the axis we want to use for heading angle.\r\n        // We have to process the angle because the imu works in euler angles so the Z axis is\r\n        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes\r\n        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.\r\n\r\n        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;\r\n\r\n        if (deltaAngle < -180)\r\n            deltaAngle += 360;\r\n        else if (deltaAngle > 180)\r\n            deltaAngle -= 360;\r\n\r\n        globalAngle += deltaAngle;\r\n\r\n        lastAngles = angles;\r\n\r\n        return globalAngle;\r\n    }\r\n\r\n    public double getAbsoluteAngle() {\r\n        // We experimentally determined the Z axis is the axis we want to use for heading angle.\r\n        // We have to process the angle because the imu works in euler angles so the Z axis is\r\n        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes\r\n        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.\r\n\r\n        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;\r\n\r\n        if (deltaAngle < -180)\r\n            deltaAngle += 360;\r\n        else if (deltaAngle > 180)\r\n            deltaAngle -= 360;\r\n\r\n        globalAngle += deltaAngle;\r\n\r\n        lastAngles = angles;\r\n\r\n        return globalAngle;\r\n    }\r\n\r\n\r\n    public void rotate(int degrees, double power) {\r\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\r\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\r\n                degrees, power);\r\n        robot.initMotorNoEncoders();\r\n        // restart imu movement tracking.\r\n        resetAngle();\r\n\r\n        if (degrees < 0) {   // turn right.\r\n            robot.moveHolonomic(0, 0, power * -1);\r\n        } else if (degrees > 0) {   // turn left.\r\n            robot.moveHolonomic(0, 0, power * 1);\r\n        } else return;\r\n\r\n\r\n        // rotate until turn is completed.\r\n        if (degrees < 0) {\r\n            // On right turn we have to get off zero first.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\r\n            }\r\n\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\r\n            }\r\n        } else    // left turn.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\r\n            }\r\n\r\n        // turn the motors off.\r\n        power = 0;\r\n        robot.leftMotor.setPower(power);\r\n        robot.rightMotor.setPower(power);\r\n        robot.backleftMotor.setPower(power);\r\n        robot.backrightMotor.setPower(power);\r\n\r\n        // wait for rotation to stop.\r\n        sleep(50);\r\n\r\n        // reset angle tracking on new heading.\r\n        resetAngle();\r\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\r\n    }\r\n\r\n    public void rotateFrontUsingOneSide(int degrees, double speed) {\r\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\r\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\r\n                degrees, speed);\r\n\r\n        // restart imu movement tracking.\r\n        resetAngle();\r\n\r\n        if (degrees < 0) {   // turn right.\r\n            robot.leftMotor.setPower(0);\r\n            robot.rightMotor.setPower(1 * speed);\r\n            robot.backleftMotor.setPower(0);\r\n            robot.backrightMotor.setPower(1 * speed);\r\n        } else if (degrees > 0) {   // turn left.\r\n            robot.leftMotor.setPower(1 * speed);\r\n            robot.rightMotor.setPower(0);\r\n            robot.backleftMotor.setPower(1 * speed);\r\n            robot.backrightMotor.setPower(0);\r\n        } else return;\r\n\r\n\r\n        // rotate until turn is completed.\r\n        if (degrees < 0) {\r\n            // On right turn we have to get off zero first.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\r\n            }\r\n\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\r\n            }\r\n        } else    // left turn.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\r\n            }\r\n\r\n        // turn the motors off.\r\n        int power = 0;\r\n        robot.leftMotor.setPower(power);\r\n        robot.rightMotor.setPower(power);\r\n        robot.backleftMotor.setPower(power);\r\n        robot.backrightMotor.setPower(power);\r\n\r\n        // wait for rotation to stop.\r\n        sleep(50);\r\n\r\n        // reset angle tracking on new heading.\r\n        resetAngle();\r\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\r\n    }\r\n\r\n    public void rotateUsingOneSide(int degrees, double speed) {\r\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\r\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\r\n                degrees, speed);\r\n\r\n        // restart imu movement tracking.\r\n        resetAngle();\r\n\r\n        if (degrees < 0) {   // turn right.\r\n            robot.leftMotor.setPower(0);\r\n            robot.rightMotor.setPower(-1 * speed);\r\n            robot.backleftMotor.setPower(0);\r\n            robot.backrightMotor.setPower(-1 * speed);\r\n        } else if (degrees > 0) {   // turn left.\r\n            robot.leftMotor.setPower(-1 * speed);\r\n            robot.rightMotor.setPower(0);\r\n            robot.backleftMotor.setPower(-1 * speed);\r\n            robot.backrightMotor.setPower(0);\r\n        } else return;\r\n\r\n\r\n        // rotate until turn is completed.\r\n        if (degrees < 0) {\r\n            // On right turn we have to get off zero first.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\r\n            }\r\n\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\r\n            }\r\n        } else    // left turn.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\r\n            }\r\n\r\n        // turn the motors off.\r\n        int power = 0;\r\n        robot.leftMotor.setPower(power);\r\n        robot.rightMotor.setPower(power);\r\n        robot.backleftMotor.setPower(power);\r\n        robot.backrightMotor.setPower(power);\r\n\r\n        // wait for rotation to stop.\r\n        sleep(50);\r\n\r\n        // reset angle tracking on new heading.\r\n        resetAngle();\r\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\r\n    }\r\n\r\n\r\n    public void myEncoderDrive(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\r\n        int newLeftTarget = 0;\r\n        int newRightTarget = 0;\r\n        int newLeftBackTarget = 0;\r\n        int newRightBackTarget = 0;\r\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderDrive -  speed=%f, Inches=%f, timeout=%f\",\r\n                speed, Inches, timeoutS);\r\n\r\n        robot.leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        robot.rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        robot.backleftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        robot.backrightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        //Reset the encoder\r\n        robot.leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        robot.rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        robot.backrightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        robot.backleftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n        // Ensure that the op mode is still active\r\n        if (opModeIsActive() && !isStopRequested()) {\r\n\r\n            // Determine new target position, and pass to motor controller\r\n            if (direction == Direction.FORWARD) {\r\n                //Go forward\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n            } else if (direction == Direction.BACKWARD) {\r\n                //Go backward\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n            } else if (direction == Direction.STRAFE_RIGHT) {\r\n                //Strafe Right\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n\r\n            } else if (direction == Direction.STRAFE_LEFT) {\r\n                //Strafe Left\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n\r\n            } else if (direction == Direction.DIAGONAL_LEFT) {\r\n                //Left Diagonal\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n\r\n            } else if (direction == Direction.DIAGONAL_RIGHT) {\r\n                //Right Diagonal\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n\r\n            } else {\r\n                Inches = 0;\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n            }\r\n\r\n\r\n            robot.leftMotor.setTargetPosition(newLeftTarget);\r\n            robot.rightMotor.setTargetPosition(newRightTarget);\r\n            robot.backleftMotor.setTargetPosition(newLeftBackTarget);\r\n            robot.backrightMotor.setTargetPosition(newRightBackTarget);\r\n\r\n            // Turn On RUN_TO_POSITION\r\n            robot.leftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n            robot.rightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n            robot.backleftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n            robot.backrightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n            // reset the timeout time and start motion.\r\n            runtime.reset();\r\n\r\n            robot.leftMotor.setPower(Math.abs(speed));\r\n            robot.rightMotor.setPower(Math.abs(speed));\r\n            robot.backleftMotor.setPower(Math.abs(speed));\r\n            robot.backrightMotor.setPower(Math.abs(speed));\r\n\r\n            while (opModeIsActive() && !isStopRequested() &&\r\n                    (runtime.seconds() < timeoutS) &&\r\n                    (robot.leftMotor.isBusy())) {\r\n/*\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_LEFT) {\r\n                    if(robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH) <= 7) {\r\n                        robot.stopAllMotors();\r\n\r\n                        telemetry.addData(\"LeftDistSensor\", \"The robot is %7f inches from crashing.\",\r\n                                robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH));\r\n                        telemetry.update();\r\n                        break;\r\n\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_RIGHT) {\r\n                    if(robot.sensorDistanceRight.getDistance(DistanceUnit.INCH) <= 7) {\r\n                        robot.stopAllMotors();\r\n\r\n                        telemetry.addData(\"RightDistSensor\", \"The robot is %7f inches from crashing.\",\r\n                                robot.sensorDistanceRight.getDistance(DistanceUnit.INCH));\r\n                        telemetry.update();\r\n                        break;\r\n\r\n                    }\r\n                }\r\n                if (sensors_2_use == SensorsToUse.USE_COLOR_LEFT) {\r\n\r\n                    if (myDetectSkystone(SideToUse.USE_LEFT, 2) == true)\r\n                    {\r\n                        robot.stopAllMotors();\r\n                        //telemetry.addData(\"LeftColorSensor\", \"The robot detected Skystone\");\r\n                        //telemetry.update();\r\n                        break;\r\n                    }\r\n                }\r\n                if (sensors_2_use == SensorsToUse.USE_COLOR_RIGHT) {\r\n\r\n                    if (myDetectSkystone(SideToUse.USE_RIGHT, 2) == true)\r\n                    {\r\n                        robot.stopAllMotors();\r\n                        //telemetry.addData(\"LeftColorSensor\", \"The robot detected Skystone\");\r\n                        //telemetry.update();\r\n                        break;\r\n                    }\r\n                }\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_RIGHT_BLD) {\r\n                    if(robot.sensorDistanceRight.getDistance(DistanceUnit.INCH) <= 2) {\r\n                        robot.stopAllMotors();\r\n\r\n                        telemetry.addData(\"RightDistSensor\", \"The robot is %7f inches from crashing.\",\r\n                                robot.sensorDistanceRight.getDistance(DistanceUnit.INCH));\r\n                        telemetry.update();\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_LEFT_BLD) {\r\n                    if(robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH) <= 2) {\r\n                        robot.stopAllMotors();\r\n\r\n                        telemetry.addData(\"LeftDistSensor\", \"The robot is %7f inches from crashing.\",\r\n                                robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH));\r\n                        telemetry.update();\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_LEFT_FDT) {\r\n                    if(robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH) > 20) {\r\n                        robot.stopAllMotors();\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_RIGHT_FDT) {\r\n                    if(robot.sensorDistanceRight.getDistance(DistanceUnit.INCH) > 20) {\r\n                        robot.stopAllMotors();\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_FRONT) {\r\n                    if(robot.sensorDistanceFL.getDistance(DistanceUnit.INCH) <23) {\r\n                        robot.stopAllMotors();\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n\r\n */\r\n        }\r\n\r\n\r\n\r\n                // Stop all motion;\r\n                robot.leftMotor.setPower(0);\r\n                robot.rightMotor.setPower(0);\r\n                robot.backleftMotor.setPower(0);\r\n                robot.backrightMotor.setPower(0);\r\n\r\n                distance_traveled = robot.rightMotor.getCurrentPosition() / COUNTS_PER_INCH;\r\n\r\n                // Turn off RUN_TO_POSITION\r\n                robot.leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n                robot.rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n                robot.backleftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n                robot.backrightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n\r\n                sleep(50);   // optional pause after each move\r\n            }\r\n        }\r\n\r\n            public void myWobbleGoal (Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\r\n                int newLeftTarget = 0;\r\n                int newRightTarget = 0;\r\n                RobotLog.ii(\"CAL\", \"Enter - myEncoderSlide -  speed=%f, Inches=%f, timeout=%f\",\r\n                        speed, Inches, timeoutS);\r\n\r\n                //Reset the encoder\r\n                robot.wobbleMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n                robot.wobbleMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n                //robot.slide_2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n                // Ensure that the op mode is still active\r\n                if (opModeIsActive() && !isStopRequested()) {\r\n\r\n                    // Determine new target position, and pass to motor controller\r\n                    if (direction == Direction.SLIDE_UP) {\r\n                        //Go forward\r\n                        newLeftTarget = robot.wobbleMotor.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                        //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (1*Inches * PULLEY_COUNTS_PER_INCH);\r\n\r\n                    } else if (direction == Direction.SLIDE_DOWN) {\r\n                        //Go backward\r\n                        newLeftTarget = robot.wobbleMotor.getCurrentPosition() + (int) (-1 * Inches * PULLEY_COUNTS_PER_INCH);\r\n                        //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (-1* Inches * PULLEY_COUNTS_PER_INCH);\r\n                    } else {\r\n                        Inches = 0;\r\n                        newLeftTarget = robot.wobbleMotor.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                        //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                    }\r\n\r\n\r\n                    robot.wobbleMotor.setTargetPosition(newLeftTarget);\r\n                    //robot.slide_2.setTargetPosition(newRightTarget);\r\n\r\n                    // Turn On RUN_TO_POSITION\r\n                    robot.wobbleMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n                    //robot.slide_2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n                    // reset the timeout time and start motion.\r\n                    runtime.reset();\r\n\r\n                    robot.wobbleMotor.setPower(Math.abs(speed));\r\n                    if (direction == Direction.SLIDE_DOWN) {\r\n                        //robot.slide_2.setPower((-1*speed));\r\n                    } else {\r\n                        //robot.slide_2.setPower((1*speed));\r\n\r\n                    }\r\n\r\n                    while (opModeIsActive() && !isStopRequested() &&\r\n                            (runtime.seconds() < timeoutS) &&\r\n                            (robot.wobbleMotor.isBusy())) {\r\n\r\n\r\n                        // Display it for the driver.\r\n                        telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newRightTarget);\r\n                        telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\r\n                                robot.wobbleMotor.getCurrentPosition(),\r\n                                robot.wobbleMotor.getCurrentPosition());\r\n                        telemetry.update();\r\n                    }\r\n                }\r\n\r\n                // Stop all motion;\r\n                robot.wobbleMotor.setPower(0);\r\n                //robot.slide_2.setPower(0);\r\n\r\n                // Turn off RUN_TO_POSITION\r\n                robot.wobbleMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n                //robot.slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n            }\r\n\r\n    public void shootTheRings (Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\r\n        int newLeftTarget = 0;\r\n        int newRightTarget = 0;\r\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderSlide -  speed=%f, Inches=%f, timeout=%f\",\r\n                speed, Inches, timeoutS);\r\n\r\n        //Reset the encoder\r\n        robot.shootMotorLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        robot.shootMotorLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        //robot.slide_2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n        // Ensure that the op mode is still active\r\n        if (opModeIsActive() && !isStopRequested()) {\r\n\r\n            // Determine new target position, and pass to motor controller\r\n            if (direction == Direction.SLIDE_UP) {\r\n                //Go forward\r\n                newLeftTarget = robot.shootMotorLeft.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (1*Inches * PULLEY_COUNTS_PER_INCH);\r\n\r\n            } else if (direction == Direction.SLIDE_DOWN) {\r\n                //Go backward\r\n                newLeftTarget = robot.shootMotorLeft.getCurrentPosition() + (int) (-1 * Inches * PULLEY_COUNTS_PER_INCH);\r\n                //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (-1* Inches * PULLEY_COUNTS_PER_INCH);\r\n            } else {\r\n                Inches = 0;\r\n                newLeftTarget = robot.shootMotorLeft.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n            }\r\n\r\n\r\n            robot.shootMotorLeft.setTargetPosition(newLeftTarget);\r\n            //robot.slide_2.setTargetPosition(newRightTarget);\r\n\r\n            // Turn On RUN_TO_POSITION\r\n            robot.shootMotorLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n            //robot.slide_2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n            // reset the timeout time and start motion.\r\n            runtime.reset();\r\n\r\n            robot.shootMotorLeft.setPower(Math.abs(speed));\r\n            if (direction == Direction.SLIDE_DOWN) {\r\n                //robot.slide_2.setPower((-1*speed));\r\n            } else {\r\n                //robot.slide_2.setPower((1*speed));\r\n\r\n            }\r\n\r\n            while (opModeIsActive() && !isStopRequested() &&\r\n                    (runtime.seconds() < timeoutS) &&\r\n                    (robot.shootMotorLeft.isBusy())) {\r\n\r\n\r\n                // Display it for the driver.\r\n                telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newRightTarget);\r\n                telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\r\n                        robot.shootMotorLeft.getCurrentPosition(),\r\n                        robot.shootMotorLeft.getCurrentPosition());\r\n                telemetry.update();\r\n            }\r\n        }\r\n\r\n        // Stop all motion;\r\n        robot.shootMotorLeft.setPower(0);\r\n        //robot.slide_2.setPower(0);\r\n\r\n        // Turn off RUN_TO_POSITION\r\n        robot.shootMotorLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        //robot.slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n    }\r\n\r\n//SONIA AND REESA PLEASE ADD YOUR TENSORFLOW STUFF HERE\r\n            /*\r\n    public void myTFOD(double timeoutS) {\r\n        {\r\n            // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\r\n            // first.\r\n\r\n            boolean strafeDone = false;\r\n            RobotLog.ii(\"CAL\", \"myTFOD - Enter\");\r\n\r\n            while (opModeIsActive() && !isStopRequested()) {\r\n\r\n                if (tfod == null) {\r\n                    robot.moveHolonomic(0, 0, 0);\r\n                    break;\r\n                }\r\n\r\n                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\r\n\r\n                if (updatedRecognitions != null) {\r\n                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\r\n                    // step through the list of recognitions and display boundary info.\r\n                    if (updatedRecognitions.size() == 0) {\r\n                        robot.moveHolonomic(0, 0, 0);\r\n                    } else {\r\n                        int i = 0;\r\n                        for (Recognition recognition : updatedRecognitions) {\r\n                            if (recognition.getLabel().equals(LABEL_SECOND_ELEMENT)) {\r\n                                double targetHeightRatio = (float) 0.8;\r\n                                double imageHeight = recognition.getImageHeight();\r\n                                double imageWidth = recognition.getImageWidth();\r\n                                double objectHeight = recognition.getHeight();\r\n                                double objectHeightRatio = objectHeight / imageHeight;\r\n                                double power = 0.1;\r\n                                double mid = (recognition.getLeft() + recognition.getRight()) / 2;\r\n                                double i_left = recognition.getLeft();\r\n                                double i_right = recognition.getRight();\r\n\r\n                                telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\r\n                                telemetry.addData(\" \", \"Image Width (%.1f), image Height (%.1f), object Height (%.1f)\",\r\n                                        imageWidth, imageHeight, objectHeight);\r\n                                telemetry.addData(String.format(\" init left,right (%d)\", i), \"%.03f , %.03f\",\r\n                                        i_left, i_right);\r\n\r\n                                if (strafeDone == false) {\r\n                                    if (mid < (640 - 100)) {\r\n                                        telemetry.addData(String.format(\" mid(%f) < 540 \", mid), \"\");\r\n                                        robot.moveHolonomic(-1 * power, 0, 0);\r\n                                    } else if (mid > (640 + 100)) {\r\n                                        telemetry.addData(String.format(\" mid(%f) > 740 \", mid), \"\");\r\n                                        robot.moveHolonomic(1 * power, 0, 0);\r\n                                    } else {\r\n                                        strafeDone = true;\r\n                                        robot.moveHolonomic(0, 0, 0);\r\n                                    }\r\n                                }\r\n\r\n                                if (strafeDone == true) {\r\n                                    telemetry.addData(\" \", \" Shank Strafe done\");\r\n\r\n                                    if (objectHeightRatio < targetHeightRatio) {\r\n                                        telemetry.addData(\" \", \" SHANK object < target power=%f\", power);\r\n\r\n                                        robot.moveHolonomic(0, 1 * power, 0);\r\n                                    } else {\r\n                                        robot.moveHolonomic(0, 0, 0);\r\n                                    }\r\n                                }\r\n\r\n                            } else {\r\n                                telemetry.addData(\"Not a skystone\", \" \");\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                    telemetry.update();\r\n                }\r\n\r\n                //RobotLog.ii(\"CAL\", \"while opModeIsActive and !isStopRequested - Enter\");\r\n            }\r\n            RobotLog.ii(\"CAL\", \"Exit if opModeIsActive\");\r\n\r\n            if (tfod != null) {\r\n                tfod.shutdown();\r\n            }\r\n            RobotLog.ii(\"CAL\", \"myTFOD - Exits\");\r\n\r\n        }\r\n    }\r\n\r\n             */\r\n    //SONIA AND REESA PLEASE DELETE THIS IF YOU DON'T NEED IT\r\n            /*\r\n    public boolean myTFOD2(double timeoutS) {\r\n        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\r\n        // first.\r\n        boolean strafeDone = false;\r\n        RobotLog.ii(\"CAL\", \"myTFOD - Enter\");\r\n\r\n\r\n        while (opModeIsActive() && !isStopRequested()) {\r\n\r\n            if (tfod == null) {\r\n                robot.moveHolonomic(0, 0, 0);\r\n                break;\r\n            }\r\n\r\n            List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\r\n\r\n            if (updatedRecognitions != null) {\r\n                telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\r\n                // step through the list of recognitions and display boundary info.\r\n                if (updatedRecognitions.size() == 0) {\r\n                    robot.moveHolonomic(0, 0, 0);\r\n                } else {\r\n                    int i = 0;\r\n                    for (Recognition recognition : updatedRecognitions) {\r\n                        if (recognition.getLabel().equals(LABEL_SECOND_ELEMENT)) {\r\n                            return true;\r\n                        } else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n                telemetry.update();\r\n                RobotLog.ii(\"CAL\", \"Exit if opModeIsActive\");\r\n\r\n                if (tfod != null) {\r\n                    tfod.shutdown();\r\n                }\r\n                RobotLog.ii(\"CAL\", \"myTFOD - Exits\");\r\n\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n         */\r\n        }\r\n    \r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/testBotAutonomousBase.java	(revision ce2a7a50d2d5df1d2fc2ff5b519ecd8ff738181a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/testBotAutonomousBase.java	(date 1610330957388)
@@ -545,7 +545,7 @@
             public void myWobbleGoal (Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {
                 int newLeftTarget = 0;
                 int newRightTarget = 0;
-                RobotLog.ii("CAL", "Enter - myEncoderSlide -  speed=%f, Inches=%f, timeout=%f",
+                RobotLog.ii("CAL", "Enter poiupuz- myEncoderSlide -  speed=%f, Inches=%f, timeout=%f",
                         speed, Inches, timeoutS);
 
                 //Reset the encoder
@@ -685,7 +685,6 @@
         robot.shootMotorLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
         //robot.slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
     }
-
 //SONIA AND REESA PLEASE ADD YOUR TENSORFLOW STUFF HERE
             /*
     public void myTFOD(double timeoutS) {
