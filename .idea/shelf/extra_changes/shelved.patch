Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/readme.md
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/readme.md	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/readme.md	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
@@ -1,121 +0,0 @@
-## TeamCode Module
-Test Change
-Welcome!
-
-This module, TeamCode, is the place where you will write/paste the code for your team's
-robot controller App. This module is currently empty (a clean slate) but the
-process for adding OpModes is straightforward.
-
-## Creating your own OpModes
-
-The easiest way to create your own OpMode is to copy a Sample OpMode and make it your own.
-
-Sample opmodes exist in the FtcRobotController module.
-To locate these samples, find the FtcRobotController module in the "Project/Android" tab.
-
-Expand the following tree elements:
- FtcRobotController / java / org.firstinspires.ftc.robotcontroller / external / samples
-
-A range of different samples classes can be seen in this folder.
-The class names follow a naming convention which indicates the purpose of each class.
-The full description of this convention is found in the samples/sample_convention.md file.
-
-A brief synopsis of the naming convention is given here:
-The prefix of the name will be one of the following:
-
-* Basic:    This is a minimally functional OpMode used to illustrate the skeleton/structure
-            of a particular style of OpMode.  These are bare bones examples.
-* Sensor:   This is a Sample OpMode that shows how to use a specific sensor.
-            It is not intended as a functioning robot, it is simply showing the minimal code
-            required to read and display the sensor values.
-* Hardware: This is not an actual OpMode, but a helper class that is used to describe
-            one particular robot's hardware devices: eg: for a Pushbot.  Look at any
-            Pushbot sample to see how this can be used in an OpMode.
-            Teams can copy one of these to create their own robot definition.
-* Pushbot:  This is a Sample OpMode that uses the Pushbot robot structure as a base.
-* Concept:	This is a sample OpMode that illustrates performing a specific function or concept.
-            These may be complex, but their operation should be explained clearly in the comments,
-            or the header should reference an external doc, guide or tutorial.
-* Library:  This is a class, or set of classes used to implement some strategy.
-            These will typically NOT implement a full OpMode.  Instead they will be included
-            by an OpMode to provide some stand-alone capability.
-
-Once you are familiar with the range of samples available, you can choose one to be the
-basis for your own robot.  In all cases, the desired sample(s) needs to be copied into
-your TeamCode module to be used.
-
-This is done inside Android Studio directly, using the following steps:
-
- 1) Locate the desired sample class in the Project/Android tree.
-
- 2) Right click on the sample class and select "Copy"
-
- 3) Expand the  TeamCode / java folder
-
- 4) Right click on the org.firstinspires.ftc.teamcode folder and select "Paste"
-
- 5) You will be prompted for a class name for the copy.
-    Choose something meaningful based on the purpose of this class.
-    Start with a capital letter, and remember that there may be more similar classes later.
-
-Once your copy has been created, you should prepare it for use on your robot.
-This is done by adjusting the OpMode's name, and enabling it to be displayed on the
-Driver Station's OpMode list.
-
-Each OpMode sample class begins with several lines of code like the ones shown below:
-
-```
- @TeleOp(name="Template: Linear OpMode", group="Linear Opmode")
- @Disabled
-```
-
-The name that will appear on the driver station's "opmode list" is defined by the code:
- ``name="Template: Linear OpMode"``
-You can change what appears between the quotes to better describe your opmode.
-The "group=" portion of the code can be used to help organize your list of OpModes.
-
-As shown, the current OpMode will NOT appear on the driver station's OpMode list because of the
-  ``@Disabled`` annotation which has been included.
-This line can simply be deleted , or commented out, to make the OpMode visible.
-
-
-
-## ADVANCED Multi-Team App management:  Cloning the TeamCode Module
-
-In some situations, you have multiple teams in your club and you want them to all share
-a common code organization, with each being able to *see* the others code but each having
-their own team module with their own code that they maintain themselves.
-
-In this situation, you might wish to clone the TeamCode module, once for each of these teams.
-Each of the clones would then appear along side each other in the Android Studio module list,
-together with the FtcRobotController module (and the original TeamCode module).
-
-Selective Team phones can then be programmed by selecting the desired Module from the pulldown list
-prior to clicking to the green Run arrow.
-
-Warning:  This is not for the inexperienced Software developer.
-You will need to be comfortable with File manipulations and managing Android Studio Modules.
-These changes are performed OUTSIDE of Android Studios, so close Android Studios before you do this.
- 
-Also.. Make a full project backup before you start this :)
-
-To clone TeamCode, do the following:
-
-Note: Some names start with "Team" and others start with "team".  This is intentional.
-
-1)  Using your operating system file management tools, copy the whole "TeamCode"
-    folder to a sibling folder with a corresponding new name, eg: "Team0417".
-
-2)  In the new Team0417 folder, delete the TeamCode.iml file.
-
-3)  the new Team0417 folder, rename the "src/main/java/org/firstinspires/ftc/teamcode" folder
-    to a matching name with a lowercase 'team' eg:  "team0417".
-
-4)  In the new Team0417/src/main folder, edit the "AndroidManifest.xml" file, change the line that contains
-         package="org.firstinspires.ftc.teamcode"
-    to be
-         package="org.firstinspires.ftc.team0417"
-
-5)  Add:    include ':Team0417' to the "/settings.gradle" file.
-    
-6)  Open up Android Studios and clean out any old files by using the menu to "Build/Clean Project""
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/testTensorFlowWithWebcam.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2019 FIRST. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided that\n * the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list\n * of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice, this\n * list of conditions and the following disclaimer in the documentation and/or\n * other materials provided with the distribution.\n *\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\n * promote products derived from this software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.firstinspires.ftc.teamcode.TestPrograms;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport java.util.List;\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\nimport org.firstinspires.ftc.teamcode.JARVISHW;\n\n/**\n * This 2019-2020 OpMode illustrates the basics of using the TensorFlow Object Detection API to\n * determine the position of the Skystone game elements.\n *\n * Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\n * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list.\n *\n * IMPORTANT: In order to use this OpMode, you need to obtain your own Vuforia license key as\n * is explained below.\n */\n@TeleOp(name = \"testTensorFlowWithWebcam\", group = \"Callisto\")\n@Disabled\npublic class testTensorFlowWithWebcam extends LinearOpMode {\n    private static final String TFOD_MODEL_ASSET = \"Skystone.tflite\";\n    private static final String LABEL_FIRST_ELEMENT = \"Stone\";\n    private static final String LABEL_SECOND_ELEMENT = \"Skystone\";\n\n    /*\n     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which\n     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.\n     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer\n     * web site at https://developer.vuforia.com/license-manager.\n     *\n     * Vuforia license keys are always 380 characters long, and look as if they contain mostly\n     * random data. As an example, here is a example of a fragment of a valid key:\n     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...\n     * Once you've obtained a license key, copy the string from the Vuforia web site\n     * and paste it in to your code on the next line, between the double quotes.\n     */\n    private static final String VUFORIA_KEY =\n            \"AXSRCQP/////AAABmZeKs8E+bExYlViUoU4W3x9D+ZqA3HLfy3PxlWiz0h5wh/awa/Oe9lra0C0CqlyRducvIyV5egl7zTYvGsbA34h3hCAV1eQtpnzQtYulVYRxD6W2Lnl47omLOHjXv3fTXLPnPDBugwDQUCqw4tN58FFEN5xoKEIPWwaQuOg43WHpfa6wenMv+bxuiwxM0Ciy+2gad/kkc+MTWzsFAL/yjTQhq718BNLr1FYZveMEwFHS43kILSKaL/+3/YGqd677av/z5tVDLkSRPUDuEYKIB1P0uCJd5AhIPnVvNigICEUxETMZiEt0RmKoQ3x9S6Y8AelTJgpHeuVgDHy5BmNP877er8Bsqr+WfHGho64CNbUx\\n\";\n\n    /**\n     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia\n     * localization engine.\n     */\n    private VuforiaLocalizer vuforia;\n\n    /**\n     * {@link #tfod} is the variable we will use to store our instance of the TensorFlow Object\n     * Detection engine.\n     */\n    private TFObjectDetector tfod;\n\n    //   eg: a Positive RelativeBearing means the robot must turn CCW to point at the target image.\n    private JARVISHW robotJARVIS = new JARVISHW();\n\n    @Override\n    public void runOpMode() {\n        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\n        // first.\n        boolean strafeDone = false;\n        robotJARVIS.init(hardwareMap);\n\n        initVuforia();\n        /**\n         * TODO - needs revisiting\n        if (ClassFactory.getInstance().canCreateTFObjectDetector()) {\n            initTfod();\n        } else {\n            telemetry.addData(\"Sorry!\", \"This device is not compatible with TFOD\");\n        }\n         */\n\n        /**\n         * Activate TensorFlow Object Detection before we wait for the start command.\n         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n         **/\n        if (tfod != null) {\n            tfod.activate();\n        }\n\n        /** Wait for the game to begin */\n        telemetry.addData(\">\", \"Press Play to start op mode\");\n        telemetry.update();\n        waitForStart();\n\n        if (opModeIsActive()) {\n            while (opModeIsActive()) {\n                if (tfod != null) {\n                    // getUpdatedRecognitions() will return null if no new information is available since\n                    // the last time that call was made.\n                    List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n\n                    if (updatedRecognitions != null) {\n                        telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n                        // step through the list of recognitions and display boundary info.\n                        if (updatedRecognitions.size() == 0) {\n                            robotJARVIS.moveHolonomic(0, 0, 0);\n                        }\n                        int i = 0;\n                        for (Recognition recognition : updatedRecognitions) {\n                            if (recognition.getLabel().equals(LABEL_SECOND_ELEMENT)){\n                                double targetHeightRatio = (float) 0.8;\n                                double imageHeight = recognition.getImageHeight();\n                                double imageWidth = recognition.getImageWidth();\n                                double objectHeight = recognition.getHeight();\n                                double objectHeightRatio = objectHeight / imageHeight;\n\n                                telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n                                telemetry.addData(\" \", \"Image Width (%.1f), image Height (%.1f), object Height (%.1f)\",\n                                        imageWidth, imageHeight, objectHeight);\n                                telemetry.addData(String.format(\"  left,right (%d)\", i), \"%.03f , %.03f\",\n                                        recognition.getLeft(), recognition.getRight());\n\n                                double obj_h_mm = objectHeight * 25.4 / 424.0;\n                                double f2 = (60 * 5.5 * 25.4 / obj_h_mm) + 60;\n                                telemetry.addData(\" \", \" Distance = %.1f, inch\", f2 / 25.4);\n                                double power = 0.3;\n                            /*\n                            if (recognition.getLeft() > (680 - 100)) {\n                                robotJARVIS.moveHolonomic(power, 0, 0);\n                            } else {\n                                strafeDone = true;\n                                robotJARVIS.moveHolonomic(0, 0, 0);\n                            }*/\n\n                                double mid = (recognition.getLeft() + recognition.getRight()) / 2;\n                                if (mid < (640 - 100)) {\n                                    robotJARVIS.moveHolonomic(-1 * power, 0, 0);\n                                } else if (mid > (640 + 100)) {\n                                    robotJARVIS.moveHolonomic(power, 0, 0);\n                                } else {\n                                    strafeDone = true;\n                                    robotJARVIS.moveHolonomic(0, 0, 0);\n                                }\n\n                                if (strafeDone == true) {\n\n                                    if (objectHeightRatio < targetHeightRatio) {\n                                        robotJARVIS.moveHolonomic(0, power, 0);\n                                    } else {\n                                        robotJARVIS.moveHolonomic(0, 0, 0);\n                                    }\n                                }\n\n                                if (strafeDone == true) {\n                                    telemetry.addData(\" \", \" Strafe done\");\n                                } else {\n                                    telemetry.addData(\" \", \" Strafing....\");\n\n                                }\n\n\n                                if (objectHeightRatio <= targetHeightRatio) {\n                                    telemetry.addData(\"The objectHeightRatio!\", \"is less than the targetHeightRatio.\");\n                                }\n                            } else {\n                                telemetry.addData(\"Not a skystone\", \" \" );\n                            }\n                        }\n                        telemetry.update();\n                        }\n                    } else {\n                        robotJARVIS.moveHolonomic(0, 0, 0);\n                    }\n\n            }\n        }\n\n\n        if (tfod != null) {\n            tfod.shutdown();\n        }\n    }\n\n    /**\n     * Initialize the Vuforia localization engine.\n     */\n    private void initVuforia() {\n        /*\n         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.\n         */\n        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n\n        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n        //parameters.cameraName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.BACK;\n\n        //  Instantiate the Vuforia engine\n        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n\n        // Loading trackables is not necessary for the TensorFlow Object Detection engine.\n    }\n\n    /**\n     * Initialize the TensorFlow Object Detection engine.\n     */\n    private void initTfod() {\n        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n        tfodParameters.minimumConfidence = 0.8;\n        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/testTensorFlowWithWebcam.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/testTensorFlowWithWebcam.java	(date 1609716235509)
@@ -34,11 +34,9 @@
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
 import java.util.List;
 import org.firstinspires.ftc.robotcore.external.ClassFactory;
-import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
 import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
 import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;
 import org.firstinspires.ftc.robotcore.external.tfod.Recognition;
-import org.firstinspires.ftc.teamcode.JARVISHW;
 
 /**
  * This 2019-2020 OpMode illustrates the basics of using the TensorFlow Object Detection API to
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBLD1Red.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestPrograms;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.JARVISAutonomousBase;\nimport org.firstinspires.ftc.teamcode.JARVISHW;\n\n@Autonomous(name=\"Jarvis Auto Build Site 1 Red\", group=\"JARVIS\")\n\npublic class JARVISAutoBLD1Red extends JARVISAutonomousBase {\n\n    JARVISHW robotJARVIS = new JARVISHW();\n\n    @Override\n    public void runOpMode() {\n        // Initializes all of the hardware so it can be used in the code.\n        robot.init(hardwareMap);\n        // Move the foundation attachment up to the start position\n        moveFoundationServoUp();\n\n        ref_angle = getAngle();\n        telemetry.addData(\"status\", \"ref_angle = %f\", ref_angle);\n        telemetry.update();\n\n\n        // Send telemetry message to signify robot waiting;\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n        // Run the program\n        autoBLDFoundation();\n    }\n\n    public void autoBLDFoundation()\n    {\n        RobotLog.ii(\"CAL\", \"Enter - JARVISAutoBLD1Red\");\n\n        //initialized the motor encoders\n        robot.initMotorEncoders();\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested() )\n        {\n            //move forward to stop dragging along the wall\n            myEncoderDrive(Direction.BACKWARD, 0.1, 2, 5, SensorsToUse.NONE);\n            //Strafe left to be in a better position to move the foundation\n            myEncoderDrive(Direction.STRAFE_LEFT, 0.1, 8, 5, SensorsToUse.NONE);\n            //move to the foundation\n            myEncoderDrive(Direction.BACKWARD, 0.3, 18, 5, SensorsToUse.NONE);\n            //go at a slower speed to make sure we hook on properly\n            myEncoderDrive(Direction.BACKWARD, 0.07, 8, 5, SensorsToUse.NONE);\n            //leave time for the foundation servos to move\n            sleep(500);\n            //move the foundation attachment down\n            moveFoundationServoDown();\n            //leave time for the foundation servos to move\n            sleep(500);\n\n\n            //move backwards with the foundation and bring it close to the wall\n            myEncoderDrive(Direction.FORWARD, 0.2, 31, 5, SensorsToUse.NONE);\n            //leave time for the robot to finish turning\n            sleep(500);\n            //move the foundation attachment up to release the foundation\n            moveFoundationServoUp();\n            //stop for 10 seconds so the robot is out of the way of the other robots while the\n            //autonomous mode is still going on\n            sleep(8000);\n            //move left to be right next to the foundation\n            myEncoderDrive(Direction.STRAFE_RIGHT, 0.3, 50, 5, SensorsToUse.NONE);\n        }\n        RobotLog.ii(\"CAL\", \"Exit - JARVISAutoBLD1Red\");\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBLD1Red.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBLD1Red.java	(date 1609716235563)
@@ -3,9 +3,6 @@
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.JARVISAutonomousBase;
-import org.firstinspires.ftc.teamcode.JARVISHW;
-
 @Autonomous(name="Jarvis Auto Build Site 1 Red", group="JARVIS")
 
 public class JARVISAutoBLD1Red extends JARVISAutonomousBase {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBLDBlueParkMiddle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestPrograms;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.JARVISAutonomousBase;\nimport org.firstinspires.ftc.teamcode.JARVISHW;\n\n@Autonomous(name=\"ZZZZZ2\", group=\"JARVIS\")\n@Disabled\npublic class JARVISAutoBLDBlueParkMiddle extends JARVISAutonomousBase {\n\n    JARVISHW robotJARVIS = new JARVISHW();\n\n    @Override\n    public void runOpMode() {\n        // Initializes the motors so they are ready for use.\n        robot.init(hardwareMap);\n        // move the foundation attachment up to the start position\n        moveFoundationServoUp();\n\n        ref_angle = getAngle();\n        telemetry.addData(\"status\", \"ref_angle = %f\", ref_angle);\n        telemetry.update();\n\n\n        // Send telemetry message to signify robot waiting;\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n\n        // Runs the program\n        autoBLDFoundation();\n    }\n\n    public void autoBLDFoundation()\n    {\n        RobotLog.ii(\"CAL\", \"Enter - JARVISAutoBLD2Blue\");\n\n        //initialized the motor encoders\n        robot.initMotorEncoders();\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested() )\n        {\n            //move Sideways into the middle\n            myEncoderDrive(Direction.STRAFE_RIGHT, 0.5, 15, 5, SensorsToUse.NONE);\n            //move forward to the line\n            myEncoderDrive(Direction.BACKWARD, 0.5, 25, 5, SensorsToUse.NONE);\n            //strafe further out of the way\n            myEncoderDrive(Direction.STRAFE_RIGHT, 0.5, 4, 5, SensorsToUse.NONE);\n        }\n        RobotLog.ii(\"CAL\", \"Exit - JARVISAutoBLD2Blue\");\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBLDBlueParkMiddle.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBLDBlueParkMiddle.java	(date 1609716235480)
@@ -4,9 +4,6 @@
 import com.qualcomm.robotcore.eventloop.opmode.Disabled;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.JARVISAutonomousBase;
-import org.firstinspires.ftc.teamcode.JARVISHW;
-
 @Autonomous(name="ZZZZZ2", group="JARVIS")
 @Disabled
 public class JARVISAutoBLDBlueParkMiddle extends JARVISAutonomousBase {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoStoneSideParkNear.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestPrograms;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.JARVISAutonomousBase;\nimport org.firstinspires.ftc.teamcode.JARVISHW;\n\n@Autonomous(name=\"ZZZZZ4\", group=\"JARVIS\")\n@Disabled\npublic class JARVISAutoStoneSideParkNear extends JARVISAutonomousBase {\n\n    JARVISHW robotJARVIS = new JARVISHW();\n\n    @Override\n    public void runOpMode() {\n        // Initializes the motors so they are ready for use.\n        robot.init(hardwareMap);\n        // move the foundation attachment up to the start position\n        moveFoundationServoUp();\n\n        ref_angle = getAngle();\n        telemetry.addData(\"status\", \"ref_angle = %f\", ref_angle);\n        telemetry.update();\n\n\n        // Send telemetry message to signify robot waiting;\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n\n        // Runs the program\n        autoBLDFoundation();\n    }\n\n    public void autoBLDFoundation()\n    {\n        RobotLog.ii(\"CAL\", \"Enter - JARVISAutoBLD2Blue\");\n\n        //initialized the motor encoders\n        robot.initMotorEncoders();\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested() )\n        {\n            //wait 25 seconds to park\n            sleep(25000);\n            //move forward onto the line\n            myEncoderDrive(Direction.FORWARD, 0.2, 31, 5, SensorsToUse.NONE);\n        }\n        RobotLog.ii(\"CAL\", \"Exit - JARVISAutoBLD2Blue\");\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoStoneSideParkNear.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoStoneSideParkNear.java	(date 1609716235543)
@@ -4,9 +4,6 @@
 import com.qualcomm.robotcore.eventloop.opmode.Disabled;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.JARVISAutonomousBase;
-import org.firstinspires.ftc.teamcode.JARVISHW;
-
 @Autonomous(name="ZZZZZ4", group="JARVIS")
 @Disabled
 public class JARVISAutoStoneSideParkNear extends JARVISAutonomousBase {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBLD1Blue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestPrograms;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.JARVISAutonomousBase;\nimport org.firstinspires.ftc.teamcode.JARVISHW;\n\n@Autonomous(name=\"Jarvis Auto Build Site 1 Blue\", group=\"JARVIS\")\n\npublic class JARVISAutoBLD1Blue extends JARVISAutonomousBase {\n\n    JARVISHW robotJARVIS = new JARVISHW();\n\n    @Override\n    public void runOpMode() {\n        // Initializes all of the hardware so it can be used in the code.\n        robot.init(hardwareMap);\n        // Move the foundation attachment up to the start position\n        moveFoundationServoUp();\n\n        ref_angle = getAngle();\n        telemetry.addData(\"status\", \"ref_angle = %f\", ref_angle);\n        telemetry.update();\n\n\n        // Send telemetry message to signify robot is ready to run;\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n        // Run the program\n        autoBLDFoundation();\n    }\n\n    public void autoBLDFoundation()\n    {\n        RobotLog.ii(\"CAL\", \"Enter - JARVISAutoBLD1Blue\");\n\n        //initialized the motor encoders\n        robot.initMotorEncoders();\n\n        // sure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested() )\n        {\n            //move forward to stop dragging along the wall\n            myEncoderDrive(Direction.BACKWARD, 0.1, 2, 5, SensorsToUse.NONE);\n            //Strafe left to be in a better position to move the foundation\n            myEncoderDrive(Direction.STRAFE_RIGHT, 0.1, 8, 5, SensorsToUse.NONE);\n            //move to the foundation\n            myEncoderDrive(Direction.BACKWARD, 0.3, 18, 5, SensorsToUse.NONE);\n            //go at a slower speed to make sure we hook on properly\n            myEncoderDrive(Direction.BACKWARD, 0.07, 7, 5, SensorsToUse.NONE);\n            //leave time for the foundation servos to move \n            sleep(500);\n            //move the foundation attachment down\n            moveFoundationServoDown();\n            //leave time for the foundation servos to move\n            sleep(500);\n\n\n            //move backwards with the foundation and bring it close to the wall\n            myEncoderDrive(Direction.FORWARD, 0.2, 31, 5, SensorsToUse.NONE);\n            //leave time for the robot to finish turning\n            sleep(500);\n            //move the foundation attachment up to release the foundation\n            moveFoundationServoUp();\n            //stop for 10 seconds so the robot is out of the way of the other robots while the\n            //autonomous mode is still going on\n            sleep(8000);\n            //move left to be right next to the foundation\n            myEncoderDrive(Direction.STRAFE_LEFT, 0.3, 50, 5, SensorsToUse.NONE);\n        }\n        RobotLog.ii(\"CAL\", \"Exit - JARVISAutoBLD1Blue\");\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBLD1Blue.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBLD1Blue.java	(date 1609716235493)
@@ -3,9 +3,6 @@
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.JARVISAutonomousBase;
-import org.firstinspires.ftc.teamcode.JARVISHW;
-
 @Autonomous(name="Jarvis Auto Build Site 1 Blue", group="JARVIS")
 
 public class JARVISAutoBLD1Blue extends JARVISAutonomousBase {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoStoneSideBlueParkMiddle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestPrograms;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.JARVISAutonomousBase;\nimport org.firstinspires.ftc.teamcode.JARVISHW;\n\n@Autonomous(name=\"ZZZZZ3\", group=\"JARVIS\")\n@Disabled\npublic class JARVISAutoStoneSideBlueParkMiddle extends JARVISAutonomousBase {\n\n    JARVISHW robotJARVIS = new JARVISHW();\n\n    @Override\n    public void runOpMode() {\n        // Initializes the motors so they are ready for use.\n        robot.init(hardwareMap);\n        // move the foundation attachment up to the start position\n        moveFoundationServoUp();\n\n        ref_angle = getAngle();\n        telemetry.addData(\"status\", \"ref_angle = %f\", ref_angle);\n        telemetry.update();\n\n\n        // Send telemetry message to signify robot waiting;\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n\n        // Runs the program\n        autoBLDFoundation();\n    }\n\n    public void autoBLDFoundation()\n    {\n        RobotLog.ii(\"CAL\", \"Enter - JARVISAutoBLD2Blue\");\n\n        //initialized the motor encoders\n        robot.initMotorEncoders();\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested() )\n        {\n            //move Sideways into the middle\n            myEncoderDrive(Direction.STRAFE_RIGHT, 0.5, 15, 5, SensorsToUse.NONE);\n            //move forward to the line\n            myEncoderDrive(Direction.FORWARD, 0.5, 25, 5, SensorsToUse.NONE);\n            //strafe further out of the way\n            myEncoderDrive(Direction.STRAFE_RIGHT, 0.5, 4, 5, SensorsToUse.NONE);\n        }\n        RobotLog.ii(\"CAL\", \"Exit - JARVISAutoBLD2Blue\");\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoStoneSideBlueParkMiddle.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoStoneSideBlueParkMiddle.java	(date 1609716235453)
@@ -4,9 +4,6 @@
 import com.qualcomm.robotcore.eventloop.opmode.Disabled;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.JARVISAutonomousBase;
-import org.firstinspires.ftc.teamcode.JARVISHW;
-
 @Autonomous(name="ZZZZZ3", group="JARVIS")
 @Disabled
 public class JARVISAutoStoneSideBlueParkMiddle extends JARVISAutonomousBase {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoParkOrangeWheel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestPrograms;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.JARVISAutonomousBase;\nimport org.firstinspires.ftc.teamcode.JARVISHW;\n\n@Autonomous(name=\"JARVIS Auto Park Orange Wheel\", group=\"JARVIS\")\n@Disabled\npublic class JARVISAutoParkOrangeWheel extends JARVISAutonomousBase {\n\n    JARVISHW robotJARVIS = new JARVISHW();\n\n    @Override\n    public void runOpMode() {\n        // Initializes the motors so they are ready for use.\n        robot.init(hardwareMap);\n        // move the foundation attachment up to the start position\n        moveFoundationServoUp();\n\n        ref_angle = getAngle();\n        telemetry.addData(\"status\", \"ref_angle = %f\", ref_angle);\n        telemetry.update();\n\n\n        // Send telemetry message to signify robot waiting;\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n\n        // Runs the program\n        autoBLDFoundation();\n    }\n\n    public void autoBLDFoundation()\n    {\n        RobotLog.ii(\"CAL\", \"Enter - JARVISAutoParkOrangeWheel\");\n\n        //initialized the motor encoders\n        robot.initMotorEncoders();\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested() )\n        {\n            robot.setGrabberDown(1);\n            robot.openGrabberClaw(1);\n            sleep(1000);\n        }\n        RobotLog.ii(\"CAL\", \"Exit - JARVISAutoParkOrangeWheel\");\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoParkOrangeWheel.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoParkOrangeWheel.java	(date 1609716235714)
@@ -4,9 +4,6 @@
 import com.qualcomm.robotcore.eventloop.opmode.Disabled;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.JARVISAutonomousBase;
-import org.firstinspires.ftc.teamcode.JARVISHW;
-
 @Autonomous(name="JARVIS Auto Park Orange Wheel", group="JARVIS")
 @Disabled
 public class JARVISAutoParkOrangeWheel extends JARVISAutonomousBase {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/TrackWidthTuner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.telemetry.MultipleTelemetry;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.util.Angle;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.util.MovingStatistics;\n\nimport org.firstinspires.ftc.robotcore.internal.system.Misc;\nimport org.firstinspires.ftc.teamcode.drive.DriveConstants;\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\n/*\n * This routine determines the effective track width. The procedure works by executing a point turn\n * with a given angle and measuring the difference between that angle and the actual angle (as\n * indicated by an external IMU/gyro, track wheels, or some other localizer). The quotient\n * given angle / actual angle gives a multiplicative adjustment to the estimated track width\n * (effective track width = estimated track width * given angle / actual angle). The routine repeats\n * this procedure a few times and averages the values for additional accuracy. Note: a relatively\n * accurate track width estimate is important or else the angular constraints will be thrown off.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class TrackWidthTuner extends LinearOpMode {\n    public static double ANGLE = 180; // deg\n    public static int NUM_TRIALS = 5;\n    public static int DELAY = 1000; // ms\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());\n\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n        // TODO: if you haven't already, set the localizer to something that doesn't depend on\n        // drive encoders for computing the heading\n\n        telemetry.addLine(\"Press play to begin the track width tuner routine\");\n        telemetry.addLine(\"Make sure your robot has enough clearance to turn smoothly\");\n        telemetry.update();\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n        telemetry.clearAll();\n        telemetry.addLine(\"Running...\");\n        telemetry.update();\n\n        MovingStatistics trackWidthStats = new MovingStatistics(NUM_TRIALS);\n        for (int i = 0; i < NUM_TRIALS; i++) {\n            drive.setPoseEstimate(new Pose2d());\n\n            // it is important to handle heading wraparounds\n            double headingAccumulator = 0;\n            double lastHeading = 0;\n\n            drive.turnAsync(Math.toRadians(ANGLE));\n\n            while (!isStopRequested() && drive.isBusy()) {\n                double heading = drive.getPoseEstimate().getHeading();\n                headingAccumulator += Angle.norm(heading - lastHeading);\n                lastHeading = heading;\n\n                drive.update();\n            }\n\n            double trackWidth = DriveConstants.TRACK_WIDTH * Math.toRadians(ANGLE) / headingAccumulator;\n            trackWidthStats.add(trackWidth);\n\n            sleep(DELAY);\n        }\n\n        telemetry.clearAll();\n        telemetry.addLine(\"Tuning complete\");\n        telemetry.addLine(Misc.formatInvariant(\"Effective track width = %.2f (SE = %.3f)\",\n                trackWidthStats.getMean(),\n                trackWidthStats.getStandardDeviation() / Math.sqrt(NUM_TRIALS)));\n        telemetry.update();\n\n        while (!isStopRequested()) {\n            idle();\n        }\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/TrackWidthTuner.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/TrackWidthTuner.java	(date 1609716235705)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.FtcDashboard;
 import com.acmerobotics.dashboard.config.Config;
@@ -10,8 +10,8 @@
 import com.qualcomm.robotcore.util.MovingStatistics;
 
 import org.firstinspires.ftc.robotcore.internal.system.Misc;
-import org.firstinspires.ftc.teamcode.drive.DriveConstants;
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 /*
  * This routine determines the effective track width. The procedure works by executing a point turn
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/TurnTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\n/*\n * This is a simple routine to test turning capabilities.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class TurnTest extends LinearOpMode {\n    public static double ANGLE = 90; // deg\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n        drive.turn(Math.toRadians(ANGLE));\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/TurnTest.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/TurnTest.java	(date 1609716235665)
@@ -1,10 +1,10 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.config.Config;
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 /*
  * This is a simple routine to test turning capabilities.
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/StrafeTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\n/*\n * This is a simple routine to test translational drive capabilities.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class StrafeTest extends LinearOpMode {\n    public static double DISTANCE = 60; // in\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        Trajectory trajectory = drive.trajectoryBuilder(new Pose2d())\n                .strafeRight(DISTANCE)\n                .build();\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n        drive.followTrajectory(trajectory);\n\n        Pose2d poseEstimate = drive.getPoseEstimate();\n        telemetry.addData(\"finalX\", poseEstimate.getX());\n        telemetry.addData(\"finalY\", poseEstimate.getY());\n        telemetry.addData(\"finalHeading\", poseEstimate.getHeading());\n        telemetry.update();\n\n        while (!isStopRequested() && opModeIsActive()) ;\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/StrafeTest.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/StrafeTest.java	(date 1609716235440)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.config.Config;
 import com.acmerobotics.roadrunner.geometry.Pose2d;
@@ -6,7 +6,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 /*
  * This is a simple routine to test translational drive capabilities.
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/StraightTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\n/*\n * This is a simple routine to test translational drive capabilities.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class StraightTest extends LinearOpMode {\n    public static double DISTANCE = 60; // in\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        Trajectory trajectory = drive.trajectoryBuilder(new Pose2d())\n                .forward(DISTANCE)\n                .build();\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n        drive.followTrajectory(trajectory);\n\n        Pose2d poseEstimate = drive.getPoseEstimate();\n        telemetry.addData(\"finalX\", poseEstimate.getX());\n        telemetry.addData(\"finalY\", poseEstimate.getY());\n        telemetry.addData(\"finalHeading\", poseEstimate.getHeading());\n        telemetry.update();\n\n        while (!isStopRequested() && opModeIsActive()) ;\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/StraightTest.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/StraightTest.java	(date 1609716235446)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.config.Config;
 import com.acmerobotics.roadrunner.geometry.Pose2d;
@@ -6,7 +6,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 /*
  * This is a simple routine to test translational drive capabilities.
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/ManualFeedforwardTuner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.telemetry.MultipleTelemetry;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.kinematics.Kinematics;\nimport com.acmerobotics.roadrunner.profile.MotionProfile;\nimport com.acmerobotics.roadrunner.profile.MotionProfileGenerator;\nimport com.acmerobotics.roadrunner.profile.MotionState;\nimport com.acmerobotics.roadrunner.util.NanoClock;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.drive.DriveConstants;\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\nimport java.util.Objects;\n\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kA;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kStatic;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;\n\n/*\n * This routine is designed to tune the open-loop feedforward coefficients. Although it may seem unnecessary,\n * tuning these coefficients is just as important as the positional parameters. Like the other\n * manual tuning routines, this op mode relies heavily upon the dashboard. To access the dashboard,\n * connect your computer to the RC's WiFi network. In your browser, navigate to\n * https://192.168.49.1:8080/dash if you're using the RC phone or https://192.168.43.1:8080/dash if\n * you are using the Control Hub. Once you've successfully connected, start the program, and your\n * robot will begin moving forward and backward according to a motion profile. Your job is to graph\n * the velocity errors over time and adjust the feedforward coefficients. Once you've found a\n * satisfactory set of gains, add them to the appropriate fields in the DriveConstants.java file.\n *\n * Pressing X (on the Xbox and Logitech F310 gamepads, square on the PS4 Dualshock gamepad) will\n * pause the tuning process and enter driver override, allowing the user to reset the position of\n * the bot in the event that it drifts off the path.\n * Pressing A (on the Xbox and Logitech F310 gamepads, X on the PS4 Dualshock gamepad) will cede\n * control back to the tuning process.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class ManualFeedforwardTuner extends LinearOpMode {\n    public static double DISTANCE = 72; // in\n\n    private FtcDashboard dashboard = FtcDashboard.getInstance();\n\n    private SampleMecanumDrive drive;\n\n    enum Mode {\n        DRIVER_MODE,\n        TUNING_MODE\n    }\n\n    private Mode mode;\n\n    private static MotionProfile generateProfile(boolean movingForward) {\n        MotionState start = new MotionState(movingForward ? 0 : DISTANCE, 0, 0, 0);\n        MotionState goal = new MotionState(movingForward ? DISTANCE : 0, 0, 0, 0);\n        return MotionProfileGenerator.generateSimpleMotionProfile(start, goal,\n                DriveConstants.BASE_CONSTRAINTS.maxVel,\n                DriveConstants.BASE_CONSTRAINTS.maxAccel,\n                DriveConstants.BASE_CONSTRAINTS.maxJerk);\n    }\n\n    @Override\n    public void runOpMode() {\n        if (RUN_USING_ENCODER) {\n            RobotLog.setGlobalErrorMsg(\"Feedforward constants usually don't need to be tuned \" +\n                    \"when using the built-in drive motor velocity PID.\");\n        }\n\n        telemetry = new MultipleTelemetry(telemetry, dashboard.getTelemetry());\n\n        drive = new SampleMecanumDrive(hardwareMap);\n\n        mode = Mode.TUNING_MODE;\n\n        NanoClock clock = NanoClock.system();\n\n        telemetry.addLine(\"Ready!\");\n        telemetry.update();\n        telemetry.clearAll();\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n        boolean movingForwards = true;\n        MotionProfile activeProfile = generateProfile(true);\n        double profileStart = clock.seconds();\n\n\n        while (!isStopRequested()) {\n            telemetry.addData(\"mode\", mode);\n\n            switch (mode) {\n                case TUNING_MODE:\n                    if (gamepad1.x) {\n                        mode = Mode.DRIVER_MODE;\n                    }\n\n                    // calculate and set the motor power\n                    double profileTime = clock.seconds() - profileStart;\n\n                    if (profileTime > activeProfile.duration()) {\n                        // generate a new profile\n                        movingForwards = !movingForwards;\n                        activeProfile = generateProfile(movingForwards);\n                        profileStart = clock.seconds();\n                    }\n\n                    MotionState motionState = activeProfile.get(profileTime);\n                    double targetPower = Kinematics.calculateMotorFeedforward(motionState.getV(), motionState.getA(), kV, kA, kStatic);\n\n                    drive.setDrivePower(new Pose2d(targetPower, 0, 0));\n                    drive.updatePoseEstimate();\n\n                    Pose2d poseVelo = Objects.requireNonNull(drive.getPoseVelocity(), \"poseVelocity() must not be null. Ensure that the getWheelVelocities() method has been overridden in your localizer.\");\n                    double currentVelo = poseVelo.getX();\n\n                    // update telemetry\n                    telemetry.addData(\"targetVelocity\", motionState.getV());\n                    telemetry.addData(\"measuredVelocity\", currentVelo);\n                    telemetry.addData(\"error\", motionState.getV() - currentVelo);\n                    break;\n                case DRIVER_MODE:\n                    if (gamepad1.a) {\n                        mode = Mode.TUNING_MODE;\n                        movingForwards = true;\n                        activeProfile = generateProfile(movingForwards);\n                        profileStart = clock.seconds();\n                    }\n\n                    drive.setWeightedDrivePower(\n                            new Pose2d(\n                                    -gamepad1.left_stick_y,\n                                    -gamepad1.left_stick_x,\n                                    -gamepad1.right_stick_x\n                            )\n                    );\n                    break;\n            }\n\n            telemetry.update();\n        }\n    }\n}
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/ManualFeedforwardTuner.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/ManualFeedforwardTuner.java	(date 1609716235673)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.FtcDashboard;
 import com.acmerobotics.dashboard.config.Config;
@@ -13,15 +13,15 @@
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.drive.DriveConstants;
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 import java.util.Objects;
 
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kA;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kStatic;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.RUN_USING_ENCODER;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kA;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kStatic;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kV;
 
 /*
  * This routine is designed to tune the open-loop feedforward coefficients. Although it may seem unnecessary,
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/SplineTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.geometry.Vector2d;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\n/*\n * This is an example of a more complex path to really test the tuning.eiihcckgbrrrllbrrllkcjjnnlerlfvtunggvvfcnhci\n *\n */\n@Autonomous(group = \"drive\")\npublic class SplineTest extends LinearOpMode {\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n        Pose2d startPose = new Pose2d(-60, -24, Math.toRadians(0));\n        drive.setPoseEstimate(startPose);\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n\n        Trajectory traj1 = drive.trajectoryBuilder(startPose)\n                .splineToLinearHeading(new Pose2d(40, 40, Math.toRadians(90)), Math.toRadians(0))\n                .build();\n        /*\n        Trajectory traj2 = drive.trajectoryBuilder(traj1.end())\n                .splineToLinearHeading(neweiihcckgbrrrilbbievnvjevkgvgvejvkclfhbruufkb\n                 Pose2d(-35, -5, Math.toRadians(180))\n                .build();\n        Trajectory traj3 = drive.trajectoryBuilder(traj2.end())\n                .splineTo(new Vector2d(0, -26), 0)\n                .build();\n        Trajectory traj4 = drive.trajectoryBuilder(traj3.end())\n                .splineTo(new Vector2d(-20, -12), Math.toRadians(180))\n                .build();\n        drive.followTrajectory(traj1);\n        sleep(300);\n        drive.followTrajectory(traj2);\n        sleep(300);\n        drive.followTrajectory(traj3);\n        sleep(300);\n        drive.followTrajectory(traj4);\n        sleep(300);\n        // sleep(5000);\n\n        drive.followTrajectory(\n                drive.trajectoryBuilder(traj4.end(), false)\n                        .splineTo(new Vector2d(0, -12), Math.toRadians(0))\n                        .build()\n        );\n*/\n        drive.followTrajectory(traj1);\n        sleep(300);\n    }\n\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/SplineTest.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/SplineTest.java	(date 1609716235639)
@@ -1,12 +1,11 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.roadrunner.geometry.Pose2d;
-import com.acmerobotics.roadrunner.geometry.Vector2d;
 import com.acmerobotics.roadrunner.trajectory.Trajectory;
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 /*
  * This is an example of a more complex path to really test the tuning.eiihcckgbrrrllbrrllkcjjnnlerlfvtunggvvfcnhci
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/FollowerPIDTuner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\n/*\n * Op mode for preliminary tuning of the follower PID coefficients (located in the drive base\n * classes). The robot drives in a DISTANCE-by-DISTANCE square indefinitely. Utilization of the\n * dashboard is recommended for this tuning routine. To access the dashboard, connect your computer\n * to the RC's WiFi network. In your browser, navigate to https://192.168.49.1:8080/dash if you're\n * using the RC phone or https://192.168.43.1:8080/dash if you are using the Control Hub. Once\n * you've successfully connected, start the program, and your robot will begin driving in a square.\n * You should observe the target position (green) and your pose estimate (blue) and adjust your\n * follower PID coefficients such that you follow the target position as accurately as possible.\n * If you are using SampleMecanumDrive, you should be tuning TRANSLATIONAL_PID and HEADING_PID.\n * If you are using SampleTankDrive, you should be tuning AXIAL_PID, CROSS_TRACK_PID, and HEADING_PID.\n * These coefficients can be tuned live in dashboard.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class FollowerPIDTuner extends LinearOpMode {\n    public static double DISTANCE = 48; // in\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        Pose2d startPose = new Pose2d(-DISTANCE / 2, -DISTANCE / 2, 0);\n\n        drive.setPoseEstimate(startPose);\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n        while (!isStopRequested()) {\n            Trajectory traj = drive.trajectoryBuilder(startPose)\n                    .forward(DISTANCE)\n                    .build();\n            drive.followTrajectory(traj);\n            drive.turn(Math.toRadians(90));\n\n            startPose = traj.end().plus(new Pose2d(0, 0, Math.toRadians(90)));\n        }\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/FollowerPIDTuner.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/FollowerPIDTuner.java	(date 1609716235524)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.config.Config;
 import com.acmerobotics.roadrunner.geometry.Pose2d;
@@ -6,7 +6,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 /*
  * Op mode for preliminary tuning of the follower PID coefficients (located in the drive base
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/LocalizationTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\n/**\n * This is a simple teleop routine for testing localization. Drive the robot around like a normal\n * teleop routine and make sure the robot's estimated pose matches the robot's actual pose (slight\n * errors are not out of the ordinary, especially with sudden drive motions). The goal of this\n * exercise is to ascertain whether the localizer has been configured properly (note: the pure\n * encoder localizer heading may be significantly off if the track width has not been tuned).\n */\n@Config\n@TeleOp(group = \"drive\")\npublic class LocalizationTest extends LinearOpMode {\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        drive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        waitForStart();\n\n        while (!isStopRequested()) {\n            drive.setWeightedDrivePower(\n                    new Pose2d(\n                            -gamepad1.left_stick_y,\n                            -gamepad1.left_stick_x,\n                            -gamepad1.right_stick_x\n                    )\n            );\n\n            drive.update();\n\n            Pose2d poseEstimate = drive.getPoseEstimate();\n            telemetry.addData(\"x\", poseEstimate.getX());\n            telemetry.addData(\"y\", poseEstimate.getY());\n            telemetry.addData(\"heading\", poseEstimate.getHeading());\n            telemetry.update();\n        }\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/LocalizationTest.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/LocalizationTest.java	(date 1609716235612)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.config.Config;
 import com.acmerobotics.roadrunner.geometry.Pose2d;
@@ -6,7 +6,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
 import com.qualcomm.robotcore.hardware.DcMotor;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 /**
  * This is a simple teleop routine for testing localization. Drive the robot around like a normal
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/BackAndForth.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\n/*\n * Op mode for preliminary tuning of the follower PID coefficients (located in the drive base\n * classes). The robot drives back and forth in a straight line indefinitely. Utilization of the\n * dashboard is recommended for this tuning routine. To access the dashboard, connect your computer\n * to the RC's WiFi network. In your browser, navigate to https://192.168.49.1:8080/dash if you're\n * using the RC phone or https://192.168.43.1:8080/dash if you are using the Control Hub. Once\n * you've successfully connected, start the program, and your robot will begin moving forward and\n * backward. You should observe the target position (green) and your pose estimate (blue) and adjust\n * your follower PID coefficients such that you follow the target position as accurately as possible.\n * If you are using SampleMecanumDrive, you should be tuning TRANSLATIONAL_PID and HEADING_PID.\n * If you are using SampleTankDrive, you should be tuning AXIAL_PID, CROSS_TRACK_PID, and HEADING_PID.\n * These coefficients can be tuned live in dashboard.\n *\n * This opmode is designed as a convenient, coarse tuning for the follower PID coefficients. It\n * is recommended that you use the FollowerPIDTuner opmode for further fine tuning.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class BackAndForth extends LinearOpMode {\n\n    public static double DISTANCE = 50;\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        Trajectory trajectoryForward = drive.trajectoryBuilder(new Pose2d())\n                .forward(DISTANCE)\n                .build();\n\n        Trajectory trajectoryBackward = drive.trajectoryBuilder(trajectoryForward.end())\n                .back(DISTANCE)\n                .build();\n\n        waitForStart();\n\n        while (opModeIsActive() && !isStopRequested()) {\n            drive.followTrajectory(trajectoryForward);\n            drive.followTrajectory(trajectoryBackward);\n        }\n    }\n}
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/BackAndForth.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/BackAndForth.java	(date 1609716235435)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.config.Config;
 import com.acmerobotics.roadrunner.geometry.Pose2d;
@@ -6,7 +6,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 /*
  * Op mode for preliminary tuning of the follower PID coefficients (located in the drive base
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/DriveVelocityPIDTuner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.telemetry.MultipleTelemetry;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.profile.MotionProfile;\nimport com.acmerobotics.roadrunner.profile.MotionProfileGenerator;\nimport com.acmerobotics.roadrunner.profile.MotionState;\nimport com.acmerobotics.roadrunner.util.NanoClock;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.drive.DriveConstants;\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\nimport java.util.List;\n\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;\n\n/*\n * This routine is designed to tune the PID coefficients used by the REV Expansion Hubs for closed-\n * loop velocity control. Although it may seem unnecessary, tuning these coefficients is just as\n * important as the positional parameters. Like the other manual tuning routines, this op mode\n * relies heavily upon the dashboard. To access the dashboard, connect your computer to the RC's\n * WiFi network. In your browser, navigate to https://192.168.49.1:8080/dash if you're using the RC\n * phone or https://192.168.43.1:8080/dash if you are using the Control Hub. Once you've successfully\n * connected, start the program, and your robot will begin moving forward and backward according to\n * a motion profile. Your job is to graph the velocity errors over time and adjust the PID\n * coefficients (note: the tuning variable will not appear until the op mode finishes initializing).\n * Once you've found a satisfactory set of gains, add them to the DriveConstants.java file under the\n * MOTOR_VELO_PID field.\n *\n * Recommended tuning process:\n *\n * 1. Increase kP until any phase lag is eliminated. Concurrently increase kD as necessary to\n *    mitigate oscillations.\n * 2. Add kI (or adjust kF) until the steady state/constant velocity plateaus are reached.\n * 3. Back off kP and kD a little until the response is less oscillatory (but without lag).\n *\n * Pressing X (on the Xbox and Logitech F310 gamepads, square on the PS4 Dualshock gamepad) will\n * pause the tuning process and enter driver override, allowing the user to reset the position of\n * the bot in the event that it drifts off the path.\n * Pressing A (on the Xbox and Logitech F310 gamepads, X on the PS4 Dualshock gamepad) will cede\n * control back to the tuning process.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class DriveVelocityPIDTuner extends LinearOpMode {\n    public static double DISTANCE = 72; // in\n\n    enum Mode {\n        DRIVER_MODE,\n        TUNING_MODE\n    }\n\n    private static MotionProfile generateProfile(boolean movingForward) {\n        MotionState start = new MotionState(movingForward ? 0 : DISTANCE, 0, 0, 0);\n        MotionState goal = new MotionState(movingForward ? DISTANCE : 0, 0, 0, 0);\n        return MotionProfileGenerator.generateSimpleMotionProfile(start, goal,\n                DriveConstants.BASE_CONSTRAINTS.maxVel,\n                DriveConstants.BASE_CONSTRAINTS.maxAccel,\n                DriveConstants.BASE_CONSTRAINTS.maxJerk);\n    }\n\n    @Override\n    public void runOpMode() {\n        if (!RUN_USING_ENCODER) {\n            RobotLog.setGlobalErrorMsg(\"%s does not need to be run if the built-in motor velocity\" +\n                    \"PID is not in use\", getClass().getSimpleName());\n        }\n\n        telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());\n\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        Mode mode = Mode.TUNING_MODE;\n\n        double lastKp = MOTOR_VELO_PID.p;\n        double lastKi = MOTOR_VELO_PID.i;\n        double lastKd = MOTOR_VELO_PID.d;\n        double lastKf = MOTOR_VELO_PID.f;\n\n        drive.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, MOTOR_VELO_PID);\n\n        NanoClock clock = NanoClock.system();\n\n        telemetry.addLine(\"Ready!\");\n        telemetry.update();\n        telemetry.clearAll();\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n        boolean movingForwards = true;\n        MotionProfile activeProfile = generateProfile(true);\n        double profileStart = clock.seconds();\n\n\n        while (!isStopRequested()) {\n            telemetry.addData(\"mode\", mode);\n\n            switch (mode) {\n                case TUNING_MODE:\n                    if (gamepad1.x) {\n                        mode = Mode.DRIVER_MODE;\n                        drive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n                    }\n\n                    // calculate and set the motor power\n                    double profileTime = clock.seconds() - profileStart;\n\n                    if (profileTime > activeProfile.duration()) {\n                        // generate a new profile\n                        movingForwards = !movingForwards;\n                        activeProfile = generateProfile(movingForwards);\n                        profileStart = clock.seconds();\n                    }\n\n                    MotionState motionState = activeProfile.get(profileTime);\n                    double targetPower = kV * motionState.getV();\n                    drive.setDrivePower(new Pose2d(targetPower, 0, 0));\n\n                    List<Double> velocities = drive.getWheelVelocities();\n\n                    // update telemetry\n                    telemetry.addData(\"targetVelocity\", motionState.getV());\n                    for (int i = 0; i < velocities.size(); i++) {\n                        telemetry.addData(\"measuredVelocity\" + i, velocities.get(i));\n                        telemetry.addData(\n                                \"error\" + i,\n                                motionState.getV() - velocities.get(i)\n                        );\n                    }\n                    break;\n                case DRIVER_MODE:\n                    if (gamepad1.a) {\n                        drive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n                        mode = Mode.TUNING_MODE;\n                        movingForwards = true;\n                        activeProfile = generateProfile(movingForwards);\n                        profileStart = clock.seconds();\n                    }\n\n                    drive.setWeightedDrivePower(\n                            new Pose2d(\n                                    -gamepad1.left_stick_y,\n                                    -gamepad1.left_stick_x,\n                                    -gamepad1.right_stick_x\n                            )\n                    );\n                    break;\n            }\n\n            if (lastKp != MOTOR_VELO_PID.p || lastKd != MOTOR_VELO_PID.d\n                    || lastKi != MOTOR_VELO_PID.i || lastKf != MOTOR_VELO_PID.f) {\n                drive.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, MOTOR_VELO_PID);\n\n                lastKp = MOTOR_VELO_PID.p;\n                lastKi = MOTOR_VELO_PID.i;\n                lastKd = MOTOR_VELO_PID.d;\n                lastKf = MOTOR_VELO_PID.f;\n            }\n\n            telemetry.update();\n        }\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/DriveVelocityPIDTuner.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/DriveVelocityPIDTuner.java	(date 1609716235605)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.FtcDashboard;
 import com.acmerobotics.dashboard.config.Config;
@@ -13,14 +13,14 @@
 import com.qualcomm.robotcore.hardware.DcMotor;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.drive.DriveConstants;
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 import java.util.List;
 
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.MOTOR_VELO_PID;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.RUN_USING_ENCODER;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kV;
 
 /*
  * This routine is designed to tune the PID coefficients used by the REV Expansion Hubs for closed-
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/StandardTrackingWheelLocalizer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive;\n\nimport androidx.annotation.NonNull;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.localization.ThreeTrackingWheelLocalizer;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport org.firstinspires.ftc.teamcode.util.Encoder;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/*\n * Sample tracking wheel localizer implementation assuming the standard configuration:\n *\n *    /--------------\\\n *    |     ____     |\n *    |     ----     |\n *    | ||        || |\n *    | ||        || |\n *    |              |\n *    |              |\n *    \\--------------/\n *\n */\n@Config\npublic class StandardTrackingWheelLocalizer extends ThreeTrackingWheelLocalizer {\n    public static double TICKS_PER_REV = 8192;\n    public static double WHEEL_RADIUS = 1.37795/2; // in\n    public static double GEAR_RATIO = 1; // output (wheel) speed / input (encoder) speed\n\n    public static double LATERAL_DISTANCE = 16; // in; distance between the left and right encoder wheels\n    public static double FORWARD_OFFSET = -8.5; // in; offset of the lateral wheel\n\n    private Encoder leftEncoder, rightEncoder, frontEncoder;\n\n    //public static double X_MULTIPLIER = 1.00171982; // Multiplier in the X direction\n    //public static double Y_MULTIPLIER = 0.989382716; // Multiplier in the Y direction\n    public static double X_MULTIPLIER = 1.004210526; // Multiplier in the X direction\n    public static double Y_MULTIPLIER = 0.973789; // Multiplier in the Y direction\n\n    public StandardTrackingWheelLocalizer(HardwareMap hardwareMap) {\n        super(Arrays.asList(\n                new Pose2d(-2, LATERAL_DISTANCE / 2, 0), // left\n                new Pose2d(-2, -LATERAL_DISTANCE / 2, 0), // right\n                new Pose2d(FORWARD_OFFSET, 2, Math.toRadians(90)) // front\n        ));\n\n        leftEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \"M1\"));\n        rightEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \"M2\"));\n        frontEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \"M3\"));\n\n        // TODO: reverse any encoders using Encoder.setDirection(Encoder.Direction.REVERSE)\n        rightEncoder.setDirection(Encoder.Direction.REVERSE);\n    }\n\n    public static double encoderTicksToInches(double ticks) {\n        return WHEEL_RADIUS * 2 * Math.PI * GEAR_RATIO * ticks / TICKS_PER_REV;\n    }\n\n    @NonNull\n    @Override\n    public List<Double> getWheelPositions() {\n\n        return Arrays.asList(\n                encoderTicksToInches(leftEncoder.getCurrentPosition()*X_MULTIPLIER),\n                encoderTicksToInches(rightEncoder.getCurrentPosition()*X_MULTIPLIER),\n                encoderTicksToInches(frontEncoder.getCurrentPosition()*Y_MULTIPLIER)\n        );\n        //return Arrays.asList(0.0,0.0,0.0 );\n    }\n\n    @NonNull\n    @Override\n    public List<Double> getWheelVelocities() {\n        // TODO: If your encoder velocity can exceed 32767 counts / second (such as the REV Through Bore and other\n        //  competing magnetic encoders), change Encoder.getRawVelocity() to Encoder.getCorrectedVelocity() to enable a\n        //  compensation method\n\n        return Arrays.asList(\n                encoderTicksToInches(leftEncoder.getCorrectedVelocity()),\n                encoderTicksToInches(rightEncoder.getCorrectedVelocity()),\n                encoderTicksToInches(frontEncoder.getCorrectedVelocity())\n        );\n        //return Arrays.asList(0.0,0.0,0.0 );\n\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/StandardTrackingWheelLocalizer.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/StandardTrackingWheelLocalizer.java	(date 1609716235469)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive;
 
 import androidx.annotation.NonNull;
 
@@ -7,7 +7,7 @@
 import com.acmerobotics.roadrunner.localization.ThreeTrackingWheelLocalizer;
 import com.qualcomm.robotcore.hardware.DcMotorEx;
 import com.qualcomm.robotcore.hardware.HardwareMap;
-import org.firstinspires.ftc.teamcode.util.Encoder;
+import org.firstinspires.ftc.teamcode.TestPrograms.util.Encoder;
 
 import java.util.Arrays;
 import java.util.List;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/AutomaticFeedforwardTuner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.telemetry.MultipleTelemetry;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.util.NanoClock;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.robotcore.internal.system.Misc;\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\nimport org.firstinspires.ftc.teamcode.util.LoggingUtil;\nimport org.firstinspires.ftc.teamcode.util.RegressionUtil;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_RPM;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.rpmToVelocity;\n\n/*\n * Op mode for computing kV, kStatic, and kA from various drive routines. For the curious, here's an\n * outline of the procedure:\n *   1. Slowly ramp the motor power and record encoder values along the way.\n *   2. Run a linear regression on the encoder velocity vs. motor power plot to obtain a slope (kV)\n *      and an optional intercept (kStatic).\n *   3. Accelerate the robot (apply constant power) and record the encoder counts.\n *   4. Adjust the encoder data based on the velocity tuning data and find kA with another linear\n *      regression.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class AutomaticFeedforwardTuner extends LinearOpMode {\n    public static final double MAX_POWER = 0.7;\n    public static final double DISTANCE = 100; // in\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        if (RUN_USING_ENCODER) {\n            RobotLog.setGlobalErrorMsg(\"Feedforward constants usually don't need to be tuned \" +\n                    \"when using the built-in drive motor velocity PID.\");\n        }\n\n        telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());\n\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        NanoClock clock = NanoClock.system();\n\n        telemetry.addLine(\"Press play to begin the feedforward tuning routine\");\n        telemetry.update();\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n        telemetry.clearAll();\n        telemetry.addLine(\"Would you like to fit kStatic?\");\n        telemetry.addLine(\"Press (A) for yes, (B) for no\");\n        telemetry.update();\n\n        boolean fitIntercept = false;\n        while (!isStopRequested()) {\n            if (gamepad1.a) {\n                fitIntercept = true;\n                while (!isStopRequested() && gamepad1.a) {\n                    idle();\n                }\n                break;\n            } else if (gamepad1.b) {\n                while (!isStopRequested() && gamepad1.b) {\n                    idle();\n                }\n                break;\n            }\n            idle();\n        }\n\n        telemetry.clearAll();\n        telemetry.addLine(Misc.formatInvariant(\n                \"Place your robot on the field with at least %.2f in of room in front\", DISTANCE));\n        telemetry.addLine(\"Press (A) to begin\");\n        telemetry.update();\n\n        while (!isStopRequested() && !gamepad1.a) {\n            idle();\n        }\n        while (!isStopRequested() && gamepad1.a) {\n            idle();\n        }\n\n        telemetry.clearAll();\n        telemetry.addLine(\"Running...\");\n        telemetry.update();\n\n        double maxVel = rpmToVelocity(MAX_RPM);\n        double finalVel = MAX_POWER * maxVel;\n        double accel = (finalVel * finalVel) / (2.0 * DISTANCE);\n        double rampTime = Math.sqrt(2.0 * DISTANCE / accel);\n\n        List<Double> timeSamples = new ArrayList<>();\n        List<Double> positionSamples = new ArrayList<>();\n        List<Double> powerSamples = new ArrayList<>();\n\n        drive.setPoseEstimate(new Pose2d());\n\n        double startTime = clock.seconds();\n        while (!isStopRequested()) {\n            double elapsedTime = clock.seconds() - startTime;\n            if (elapsedTime > rampTime) {\n                break;\n            }\n            double vel = accel * elapsedTime;\n            double power = vel / maxVel;\n\n            timeSamples.add(elapsedTime);\n            positionSamples.add(drive.getPoseEstimate().getX());\n            powerSamples.add(power);\n\n            drive.setDrivePower(new Pose2d(power, 0.0, 0.0));\n            drive.updatePoseEstimate();\n        }\n        drive.setDrivePower(new Pose2d(0.0, 0.0, 0.0));\n\n        RegressionUtil.RampResult rampResult = RegressionUtil.fitRampData(\n                timeSamples, positionSamples, powerSamples, fitIntercept,\n                LoggingUtil.getLogFile(Misc.formatInvariant(\n                        \"DriveRampRegression-%d.csv\", System.currentTimeMillis())));\n\n        telemetry.clearAll();\n        telemetry.addLine(\"Quasi-static ramp up test complete\");\n        if (fitIntercept) {\n            telemetry.addLine(Misc.formatInvariant(\"kV = %.5f, kStatic = %.5f (R^2 = %.2f)\",\n                    rampResult.kV, rampResult.kStatic, rampResult.rSquare));\n        } else {\n            telemetry.addLine(Misc.formatInvariant(\"kV = %.5f (R^2 = %.2f)\",\n                    rampResult.kStatic, rampResult.rSquare));\n        }\n        telemetry.addLine(\"Would you like to fit kA?\");\n        telemetry.addLine(\"Press (A) for yes, (B) for no\");\n        telemetry.update();\n\n        boolean fitAccelFF = false;\n        while (!isStopRequested()) {\n            if (gamepad1.a) {\n                fitAccelFF = true;\n                while (!isStopRequested() && gamepad1.a) {\n                    idle();\n                }\n                break;\n            } else if (gamepad1.b) {\n                while (!isStopRequested() && gamepad1.b) {\n                    idle();\n                }\n                break;\n            }\n            idle();\n        }\n\n        if (fitAccelFF) {\n            telemetry.clearAll();\n            telemetry.addLine(\"Place the robot back in its starting position\");\n            telemetry.addLine(\"Press (A) to continue\");\n            telemetry.update();\n\n            while (!isStopRequested() && !gamepad1.a) {\n                idle();\n            }\n            while (!isStopRequested() && gamepad1.a) {\n                idle();\n            }\n\n            telemetry.clearAll();\n            telemetry.addLine(\"Running...\");\n            telemetry.update();\n\n            double maxPowerTime = DISTANCE / maxVel;\n\n            timeSamples.clear();\n            positionSamples.clear();\n            powerSamples.clear();\n\n            drive.setPoseEstimate(new Pose2d());\n            drive.setDrivePower(new Pose2d(MAX_POWER, 0.0, 0.0));\n\n            startTime = clock.seconds();\n            while (!isStopRequested()) {\n                double elapsedTime = clock.seconds() - startTime;\n                if (elapsedTime > maxPowerTime) {\n                    break;\n                }\n\n                timeSamples.add(elapsedTime);\n                positionSamples.add(drive.getPoseEstimate().getX());\n                powerSamples.add(MAX_POWER);\n\n                drive.updatePoseEstimate();\n            }\n            drive.setDrivePower(new Pose2d(0.0, 0.0, 0.0));\n\n            RegressionUtil.AccelResult accelResult = RegressionUtil.fitAccelData(\n                    timeSamples, positionSamples, powerSamples, rampResult,\n                    LoggingUtil.getLogFile(Misc.formatInvariant(\n                            \"DriveAccelRegression-%d.csv\", System.currentTimeMillis())));\n\n            telemetry.clearAll();\n            telemetry.addLine(\"Constant power test complete\");\n            telemetry.addLine(Misc.formatInvariant(\"kA = %.5f (R^2 = %.2f)\",\n                    accelResult.kA, accelResult.rSquare));\n            telemetry.update();\n        }\n\n        while (!isStopRequested()) {\n            idle();\n        }\n    }\n}
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/AutomaticFeedforwardTuner.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/AutomaticFeedforwardTuner.java	(date 1609716235688)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.FtcDashboard;
 import com.acmerobotics.dashboard.config.Config;
@@ -10,16 +10,16 @@
 import com.qualcomm.robotcore.util.RobotLog;
 
 import org.firstinspires.ftc.robotcore.internal.system.Misc;
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
-import org.firstinspires.ftc.teamcode.util.LoggingUtil;
-import org.firstinspires.ftc.teamcode.util.RegressionUtil;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.util.LoggingUtil;
+import org.firstinspires.ftc.teamcode.TestPrograms.util.RegressionUtil;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_RPM;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.rpmToVelocity;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.MAX_RPM;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.RUN_USING_ENCODER;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.rpmToVelocity;
 
 /*
  * Op mode for computing kV, kStatic, and kA from various drive routines. For the curious, here's an
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleMecanumDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive;\n\nimport androidx.annotation.NonNull;\n\nimport com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.canvas.Canvas;\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.telemetry.TelemetryPacket;\nimport com.acmerobotics.roadrunner.control.PIDCoefficients;\nimport com.acmerobotics.roadrunner.control.PIDFController;\nimport com.acmerobotics.roadrunner.drive.DriveSignal;\nimport com.acmerobotics.roadrunner.drive.MecanumDrive;\nimport com.acmerobotics.roadrunner.followers.HolonomicPIDVAFollower;\nimport com.acmerobotics.roadrunner.followers.TrajectoryFollower;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.profile.MotionProfile;\nimport com.acmerobotics.roadrunner.profile.MotionProfileGenerator;\nimport com.acmerobotics.roadrunner.profile.MotionState;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\nimport com.acmerobotics.roadrunner.trajectory.constraints.DriveConstraints;\nimport com.acmerobotics.roadrunner.trajectory.constraints.MecanumConstraints;\nimport com.acmerobotics.roadrunner.util.NanoClock;\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.hardware.lynx.LynxModule;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\nimport com.qualcomm.robotcore.hardware.VoltageSensor;\nimport com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;\n\nimport org.firstinspires.ftc.teamcode.util.DashboardUtil;\nimport org.firstinspires.ftc.teamcode.util.LynxModuleUtil;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.BASE_CONSTRAINTS;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.TRACK_WIDTH;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.encoderTicksToInches;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kA;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kStatic;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;\n\n/*\n * Simple mecanum drive hardware implementation for REV hardware.\n */\n@Config\npublic class SampleMecanumDrive extends MecanumDrive {\n    public static PIDCoefficients TRANSLATIONAL_PID = new PIDCoefficients(8, 0, 0.0001);\n    public static PIDCoefficients HEADING_PID = new PIDCoefficients(26.5, 0.00005, 0.0005);\n\n    public static double LATERAL_MULTIPLIER = 2;\n\n    public static double VX_WEIGHT = 1;\n    public static double VY_WEIGHT = 1;\n    public static double OMEGA_WEIGHT = 1;\n\n    public static int POSE_HISTORY_LIMIT = 100;\n\n    public enum Mode {\n        IDLE,\n        TURN,\n        FOLLOW_TRAJECTORY\n    }\n\n    private FtcDashboard dashboard;\n    private NanoClock clock;\n\n    private Mode mode;\n\n    private PIDFController turnController;\n    private MotionProfile turnProfile;\n    private double turnStart;\n\n    private DriveConstraints constraints;\n    private TrajectoryFollower follower;\n\n    private LinkedList<Pose2d> poseHistory;\n\n    private DcMotorEx leftFront, leftRear, rightRear, rightFront;\n    private List<DcMotorEx> motors;\n    private BNO055IMU imu;\n\n    private VoltageSensor batteryVoltageSensor;\n\n    private Pose2d lastPoseOnTurn;\n\n    public SampleMecanumDrive(HardwareMap hardwareMap) {\n        super(kV, kA, kStatic, TRACK_WIDTH, TRACK_WIDTH, LATERAL_MULTIPLIER);\n\n        dashboard = FtcDashboard.getInstance();\n        dashboard.setTelemetryTransmissionInterval(25);\n\n        clock = NanoClock.system();\n\n        mode = Mode.IDLE;\n\n        turnController = new PIDFController(HEADING_PID);\n        turnController.setInputBounds(0, 2 * Math.PI);\n\n        constraints = new MecanumConstraints(BASE_CONSTRAINTS, TRACK_WIDTH);\n        follower = new HolonomicPIDVAFollower(TRANSLATIONAL_PID, TRANSLATIONAL_PID, HEADING_PID,\n                new Pose2d(0.5, 0.5, Math.toRadians(5.0)), 0.5);\n\n        poseHistory = new LinkedList<>();\n\n        LynxModuleUtil.ensureMinimumFirmwareVersion(hardwareMap);\n\n        batteryVoltageSensor = hardwareMap.voltageSensor.iterator().next();\n\n        for (LynxModule module : hardwareMap.getAll(LynxModule.class)) {\n            module.setBulkCachingMode(LynxModule.BulkCachingMode.AUTO);\n        }\n\n        // TODO: adjust the names of the following hardware devices to match your configuration\n        imu = hardwareMap.get(BNO055IMU.class, \"imu 1\");\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS;\n        imu.initialize(parameters);\n\n        // TODO: if your hub is mounted vertically, remap the IMU axes so that the z-axis points\n        // upward (normal to the floor) using a command like the following:\n        // BNO055IMUUtil.remapAxes(imu, AxesOrder.XYZ, AxesSigns.NPN);\n\n        leftFront = hardwareMap.get(DcMotorEx.class, \"M1\");\n        rightFront = hardwareMap.get(DcMotorEx.class, \"M2\");\n        leftRear = hardwareMap.get(DcMotorEx.class, \"M3\");\n        rightRear = hardwareMap.get(DcMotorEx.class, \"M4\");\n\n        motors = Arrays.asList(leftFront, leftRear, rightRear, rightFront);\n\n        for (DcMotorEx motor : motors) {\n            MotorConfigurationType motorConfigurationType = motor.getMotorType().clone();\n            motorConfigurationType.setAchieveableMaxRPMFraction(1.0);\n            motor.setMotorType(motorConfigurationType);\n        }\n\n        if (RUN_USING_ENCODER) {\n            setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        }\n\n        setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        if (RUN_USING_ENCODER && MOTOR_VELO_PID != null) {\n            setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, MOTOR_VELO_PID);\n        }\n\n        // TODO: reverse any motors using DcMotor.setDirection()\n        leftFront.setDirection(DcMotorEx.Direction.REVERSE);\n        leftRear.setDirection(DcMotorEx.Direction.REVERSE);\n\n        // TODO: if desired, use setLocalizer() to change the localization method\n        // for instance, setLocalizer(new ThreeTrackingWheelLocalizer(...));\n        setLocalizer(new StandardTrackingWheelLocalizer(hardwareMap));\n    }\n\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose) {\n        return new TrajectoryBuilder(startPose, constraints);\n    }\n\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, boolean reversed) {\n        return new TrajectoryBuilder(startPose, reversed, constraints);\n    }\n\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, double startHeading) {\n        return new TrajectoryBuilder(startPose, startHeading, constraints);\n    }\n\n    public void turnAsync(double angle) {\n        double heading = getPoseEstimate().getHeading();\n\n        lastPoseOnTurn = getPoseEstimate();\n\n        turnProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                new MotionState(heading, 0, 0, 0),\n                new MotionState(heading + angle, 0, 0, 0),\n                constraints.maxAngVel,\n                constraints.maxAngAccel,\n                constraints.maxAngJerk\n        );\n\n        turnStart = clock.seconds();\n        mode = Mode.TURN;\n    }\n\n    public void turn(double angle) {\n        turnAsync(angle);\n        waitForIdle();\n    }\n\n    public void followTrajectoryAsync(Trajectory trajectory) {\n        follower.followTrajectory(trajectory);\n        mode = Mode.FOLLOW_TRAJECTORY;\n    }\n\n    public void followTrajectory(Trajectory trajectory) {\n        followTrajectoryAsync(trajectory);\n        waitForIdle();\n    }\n\n    public Pose2d getLastError() {\n        switch (mode) {\n            case FOLLOW_TRAJECTORY:\n                return follower.getLastError();\n            case TURN:\n                return new Pose2d(0, 0, turnController.getLastError());\n            case IDLE:\n                return new Pose2d();\n        }\n        throw new AssertionError();\n    }\n\n    public void update() {\n        updatePoseEstimate();\n\n        Pose2d currentPose = getPoseEstimate();\n        Pose2d lastError = getLastError();\n\n        poseHistory.add(currentPose);\n\n        if (POSE_HISTORY_LIMIT > -1 && poseHistory.size() > POSE_HISTORY_LIMIT) {\n            poseHistory.removeFirst();\n        }\n\n        TelemetryPacket packet = new TelemetryPacket();\n        Canvas fieldOverlay = packet.fieldOverlay();\n\n        packet.put(\"mode\", mode);\n\n        packet.put(\"x\", currentPose.getX());\n        packet.put(\"y\", currentPose.getY());\n        packet.put(\"heading\", currentPose.getHeading());\n\n        packet.put(\"xError\", lastError.getX());\n        packet.put(\"yError\", lastError.getY());\n        packet.put(\"headingError\", lastError.getHeading());\n\n        switch (mode) {\n            case IDLE:\n                // do nothing\n                break;\n            case TURN: {\n                double t = clock.seconds() - turnStart;\n\n                MotionState targetState = turnProfile.get(t);\n\n                turnController.setTargetPosition(targetState.getX());\n\n                double correction = turnController.update(currentPose.getHeading());\n\n                double targetOmega = targetState.getV();\n                double targetAlpha = targetState.getA();\n                setDriveSignal(new DriveSignal(new Pose2d(\n                        0, 0, targetOmega + correction\n                ), new Pose2d(\n                        0, 0, targetAlpha\n                )));\n\n                Pose2d newPose = lastPoseOnTurn.copy(lastPoseOnTurn.getX(), lastPoseOnTurn.getY(), targetState.getX());\n\n                fieldOverlay.setStroke(\"#4CAF50\");\n                DashboardUtil.drawRobot(fieldOverlay, newPose);\n\n                if (t >= turnProfile.duration()) {\n                    mode = Mode.IDLE;\n                    setDriveSignal(new DriveSignal());\n                }\n\n                break;\n            }\n            case FOLLOW_TRAJECTORY: {\n                setDriveSignal(follower.update(currentPose));\n\n                Trajectory trajectory = follower.getTrajectory();\n\n                fieldOverlay.setStrokeWidth(1);\n                fieldOverlay.setStroke(\"#4CAF50\");\n                DashboardUtil.drawSampledPath(fieldOverlay, trajectory.getPath());\n                double t = follower.elapsedTime();\n                DashboardUtil.drawRobot(fieldOverlay, trajectory.get(t));\n\n                fieldOverlay.setStroke(\"#3F51B5\");\n                DashboardUtil.drawPoseHistory(fieldOverlay, poseHistory);\n\n                if (!follower.isFollowing()) {\n                    mode = Mode.IDLE;\n                    setDriveSignal(new DriveSignal());\n                }\n\n                break;\n            }\n        }\n\n        fieldOverlay.setStroke(\"#3F51B5\");\n        DashboardUtil.drawRobot(fieldOverlay, currentPose);\n\n        dashboard.sendTelemetryPacket(packet);\n    }\n\n    public void waitForIdle() {\n        while (!Thread.currentThread().isInterrupted() && isBusy()) {\n            update();\n        }\n    }\n\n    public boolean isBusy() {\n        return mode != Mode.IDLE;\n    }\n\n    public void setMode(DcMotor.RunMode runMode) {\n        for (DcMotorEx motor : motors) {\n            motor.setMode(runMode);\n        }\n    }\n\n    public void setZeroPowerBehavior(DcMotor.ZeroPowerBehavior zeroPowerBehavior) {\n        for (DcMotorEx motor : motors) {\n            motor.setZeroPowerBehavior(zeroPowerBehavior);\n        }\n    }\n\n    public void setPIDFCoefficients(DcMotor.RunMode runMode, PIDFCoefficients coefficients) {\n        PIDFCoefficients compensatedCoefficients = new PIDFCoefficients(\n                coefficients.p, coefficients.i, coefficients.d,\n                coefficients.f * 12 / batteryVoltageSensor.getVoltage()\n        );\n        for (DcMotorEx motor : motors) {\n            motor.setPIDFCoefficients(runMode, compensatedCoefficients);\n        }\n    }\n\n    public void setWeightedDrivePower(Pose2d drivePower) {\n        Pose2d vel = drivePower;\n\n        if (Math.abs(drivePower.getX()) + Math.abs(drivePower.getY())\n                + Math.abs(drivePower.getHeading()) > 1) {\n            // re-normalize the powers according to the weights\n            double denom = VX_WEIGHT * Math.abs(drivePower.getX())\n                    + VY_WEIGHT * Math.abs(drivePower.getY())\n                    + OMEGA_WEIGHT * Math.abs(drivePower.getHeading());\n\n            vel = new Pose2d(\n                    VX_WEIGHT * drivePower.getX(),\n                    VY_WEIGHT * drivePower.getY(),\n                    OMEGA_WEIGHT * drivePower.getHeading()\n            ).div(denom);\n        }\n\n        setDrivePower(vel);\n    }\n\n    @NonNull\n    @Override\n    public List<Double> getWheelPositions() {\n        List<Double> wheelPositions = new ArrayList<>();\n        for (DcMotorEx motor : motors) {\n            wheelPositions.add(encoderTicksToInches(motor.getCurrentPosition()));\n        }\n        return wheelPositions;\n    }\n\n    @Override\n    public List<Double> getWheelVelocities() {\n        List<Double> wheelVelocities = new ArrayList<>();\n        for (DcMotorEx motor : motors) {\n            wheelVelocities.add(encoderTicksToInches(motor.getVelocity()));\n        }\n        return wheelVelocities;\n    }\n\n    @Override\n    public void setMotorPowers(double v, double v1, double v2, double v3) {\n        leftFront.setPower(v);\n        leftRear.setPower(v1);\n        rightRear.setPower(v2);\n        rightFront.setPower(v3);\n    }\n\n    @Override\n    public double getRawExternalHeading() {\n        return imu.getAngularOrientation().firstAngle;\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleMecanumDrive.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/SampleMecanumDrive.java	(date 1609716235622)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive;
 
 import androidx.annotation.NonNull;
 
@@ -30,22 +30,22 @@
 import com.qualcomm.robotcore.hardware.VoltageSensor;
 import com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;
 
-import org.firstinspires.ftc.teamcode.util.DashboardUtil;
-import org.firstinspires.ftc.teamcode.util.LynxModuleUtil;
+import org.firstinspires.ftc.teamcode.TestPrograms.util.DashboardUtil;
+import org.firstinspires.ftc.teamcode.TestPrograms.util.LynxModuleUtil;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedList;
 import java.util.List;
 
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.BASE_CONSTRAINTS;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.TRACK_WIDTH;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.encoderTicksToInches;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kA;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kStatic;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.BASE_CONSTRAINTS;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.MOTOR_VELO_PID;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.RUN_USING_ENCODER;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.TRACK_WIDTH;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.encoderTicksToInches;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kA;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kStatic;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kV;
 
 /*
  * Simple mecanum drive hardware implementation for REV hardware.
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleTankDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive;\n\nimport androidx.annotation.NonNull;\n\nimport com.acmerobotics.dashboard.FtcDashboard;\nimport com.acmerobotics.dashboard.canvas.Canvas;\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.dashboard.telemetry.TelemetryPacket;\nimport com.acmerobotics.roadrunner.control.PIDCoefficients;\nimport com.acmerobotics.roadrunner.control.PIDFController;\nimport com.acmerobotics.roadrunner.drive.DriveSignal;\nimport com.acmerobotics.roadrunner.drive.TankDrive;\nimport com.acmerobotics.roadrunner.followers.TankPIDVAFollower;\nimport com.acmerobotics.roadrunner.followers.TrajectoryFollower;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.profile.MotionProfile;\nimport com.acmerobotics.roadrunner.profile.MotionProfileGenerator;\nimport com.acmerobotics.roadrunner.profile.MotionState;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\nimport com.acmerobotics.roadrunner.trajectory.constraints.DriveConstraints;\nimport com.acmerobotics.roadrunner.trajectory.constraints.TankConstraints;\nimport com.acmerobotics.roadrunner.util.NanoClock;\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.hardware.lynx.LynxModule;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\nimport com.qualcomm.robotcore.hardware.VoltageSensor;\nimport com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;\n\nimport org.firstinspires.ftc.teamcode.util.DashboardUtil;\nimport org.firstinspires.ftc.teamcode.util.LynxModuleUtil;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.BASE_CONSTRAINTS;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.TRACK_WIDTH;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.encoderTicksToInches;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kA;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kStatic;\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;\n\n/*\n * Simple tank drive hardware implementation for REV hardware.\n */\n@Config\npublic class SampleTankDrive extends TankDrive {\n    public static PIDCoefficients AXIAL_PID = new PIDCoefficients(0, 0, 0);\n    public static PIDCoefficients CROSS_TRACK_PID = new PIDCoefficients(0, 0, 0);\n    public static PIDCoefficients HEADING_PID = new PIDCoefficients(0, 0, 0);\n\n    public static double VX_WEIGHT = 1;\n    public static double OMEGA_WEIGHT = 1;\n\n    public enum Mode {\n        IDLE,\n        TURN,\n        FOLLOW_TRAJECTORY\n    }\n\n    private FtcDashboard dashboard;\n    private NanoClock clock;\n\n    private Mode mode;\n\n    private PIDFController turnController;\n    private MotionProfile turnProfile;\n    private double turnStart;\n\n    private DriveConstraints constraints;\n    private TrajectoryFollower follower;\n\n    private List<Pose2d> poseHistory;\n\n    private List<DcMotorEx> motors, leftMotors, rightMotors;\n    private BNO055IMU imu;\n\n    private VoltageSensor batteryVoltageSensor;\n\n    public SampleTankDrive(HardwareMap hardwareMap) {\n        super(kV, kA, kStatic, TRACK_WIDTH);\n\n        dashboard = FtcDashboard.getInstance();\n        dashboard.setTelemetryTransmissionInterval(25);\n\n        clock = NanoClock.system();\n\n        mode = Mode.IDLE;\n\n        turnController = new PIDFController(HEADING_PID);\n        turnController.setInputBounds(0, 2 * Math.PI);\n\n        constraints = new TankConstraints(BASE_CONSTRAINTS, TRACK_WIDTH);\n        follower = new TankPIDVAFollower(AXIAL_PID, CROSS_TRACK_PID,\n                new Pose2d(0.5, 0.5, Math.toRadians(5.0)), 0.5);\n\n        poseHistory = new ArrayList<>();\n\n        LynxModuleUtil.ensureMinimumFirmwareVersion(hardwareMap);\n\n        batteryVoltageSensor = hardwareMap.voltageSensor.iterator().next();\n\n        for (LynxModule module : hardwareMap.getAll(LynxModule.class)) {\n            module.setBulkCachingMode(LynxModule.BulkCachingMode.AUTO);\n        }\n\n        // TODO: adjust the names of the following hardware devices to match your configuration\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS;\n        imu.initialize(parameters);\n\n        // TODO: if your hub is mounted vertically, remap the IMU axes so that the z-axis points\n        // upward (normal to the floor) using a command like the following:\n        // BNO055IMUUtil.remapAxes(imu, AxesOrder.XYZ, AxesSigns.NPN);\n\n        // add/remove motors depending on your robot (e.g., 6WD)\n        DcMotorEx leftFront = hardwareMap.get(DcMotorEx.class, \"leftFront\");\n        DcMotorEx leftRear = hardwareMap.get(DcMotorEx.class, \"leftRear\");\n        DcMotorEx rightRear = hardwareMap.get(DcMotorEx.class, \"rightRear\");\n        DcMotorEx rightFront = hardwareMap.get(DcMotorEx.class, \"rightFront\");\n\n        motors = Arrays.asList(leftFront, leftRear, rightRear, rightFront);\n        leftMotors = Arrays.asList(leftFront, leftRear);\n        rightMotors = Arrays.asList(rightFront, rightRear);\n\n        for (DcMotorEx motor : motors) {\n            MotorConfigurationType motorConfigurationType = motor.getMotorType().clone();\n            motorConfigurationType.setAchieveableMaxRPMFraction(1.0);\n            motor.setMotorType(motorConfigurationType);\n        }\n\n        if (RUN_USING_ENCODER) {\n            setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        }\n\n        setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        if (RUN_USING_ENCODER && MOTOR_VELO_PID != null) {\n            setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, MOTOR_VELO_PID);\n        }\n\n        // TODO: reverse any motors using DcMotor.setDirection()\n\n        // TODO: if desired, use setLocalizer() to change the localization method\n        // for instance, setLocalizer(new ThreeTrackingWheelLocalizer(...));\n    }\n\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose) {\n        return new TrajectoryBuilder(startPose, constraints);\n    }\n\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, boolean reversed) {\n        return new TrajectoryBuilder(startPose, reversed, constraints);\n    }\n\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, double startHeading) {\n        return new TrajectoryBuilder(startPose, startHeading, constraints);\n    }\n\n    public void turnAsync(double angle) {\n        double heading = getPoseEstimate().getHeading();\n        turnProfile = MotionProfileGenerator.generateSimpleMotionProfile(\n                new MotionState(heading, 0, 0, 0),\n                new MotionState(heading + angle, 0, 0, 0),\n                constraints.maxAngVel,\n                constraints.maxAngAccel,\n                constraints.maxAngJerk\n        );\n        turnStart = clock.seconds();\n        mode = Mode.TURN;\n    }\n\n    public void turn(double angle) {\n        turnAsync(angle);\n        waitForIdle();\n    }\n\n    public void followTrajectoryAsync(Trajectory trajectory) {\n        poseHistory.clear();\n        follower.followTrajectory(trajectory);\n        mode = Mode.FOLLOW_TRAJECTORY;\n    }\n\n    public void followTrajectory(Trajectory trajectory) {\n        followTrajectoryAsync(trajectory);\n        waitForIdle();\n    }\n\n    public Pose2d getLastError() {\n        switch (mode) {\n            case FOLLOW_TRAJECTORY:\n                return follower.getLastError();\n            case TURN:\n                return new Pose2d(0, 0, turnController.getLastError());\n            case IDLE:\n                return new Pose2d();\n        }\n        throw new AssertionError();\n    }\n\n    public void update() {\n        updatePoseEstimate();\n\n        Pose2d currentPose = getPoseEstimate();\n        Pose2d lastError = getLastError();\n\n        poseHistory.add(currentPose);\n\n        TelemetryPacket packet = new TelemetryPacket();\n        Canvas fieldOverlay = packet.fieldOverlay();\n\n        packet.put(\"mode\", mode);\n\n        packet.put(\"x\", currentPose.getX());\n        packet.put(\"y\", currentPose.getY());\n        packet.put(\"heading\", currentPose.getHeading());\n\n        packet.put(\"xError\", lastError.getX());\n        packet.put(\"yError\", lastError.getY());\n        packet.put(\"headingError\", lastError.getHeading());\n\n        switch (mode) {\n            case IDLE:\n                // do nothing\n                break;\n            case TURN: {\n                double t = clock.seconds() - turnStart;\n\n                MotionState targetState = turnProfile.get(t);\n\n                turnController.setTargetPosition(targetState.getX());\n\n                double correction = turnController.update(currentPose.getHeading());\n\n                double targetOmega = targetState.getV();\n                double targetAlpha = targetState.getA();\n                setDriveSignal(new DriveSignal(new Pose2d(\n                        0, 0, targetOmega + correction\n                ), new Pose2d(\n                        0, 0, targetAlpha\n                )));\n\n                if (t >= turnProfile.duration()) {\n                    mode = Mode.IDLE;\n                    setDriveSignal(new DriveSignal());\n                }\n\n                break;\n            }\n            case FOLLOW_TRAJECTORY: {\n                setDriveSignal(follower.update(currentPose));\n\n                Trajectory trajectory = follower.getTrajectory();\n\n                fieldOverlay.setStrokeWidth(1);\n                fieldOverlay.setStroke(\"4CAF50\");\n                DashboardUtil.drawSampledPath(fieldOverlay, trajectory.getPath());\n                double t = follower.elapsedTime();\n                DashboardUtil.drawRobot(fieldOverlay, trajectory.get(t));\n\n                fieldOverlay.setStroke(\"#3F51B5\");\n                DashboardUtil.drawPoseHistory(fieldOverlay, poseHistory);\n                DashboardUtil.drawRobot(fieldOverlay, currentPose);\n\n                if (!follower.isFollowing()) {\n                    mode = Mode.IDLE;\n                    setDriveSignal(new DriveSignal());\n                }\n\n                break;\n            }\n        }\n\n        dashboard.sendTelemetryPacket(packet);\n    }\n\n    public void waitForIdle() {\n        while (!Thread.currentThread().isInterrupted() && isBusy()) {\n            update();\n        }\n    }\n\n    public boolean isBusy() {\n        return mode != Mode.IDLE;\n    }\n\n    public void setMode(DcMotor.RunMode runMode) {\n        for (DcMotorEx motor : motors) {\n            motor.setMode(runMode);\n        }\n    }\n\n    public void setZeroPowerBehavior(DcMotor.ZeroPowerBehavior zeroPowerBehavior) {\n        for (DcMotorEx motor : motors) {\n            motor.setZeroPowerBehavior(zeroPowerBehavior);\n        }\n    }\n\n    public void setPIDFCoefficients(DcMotor.RunMode runMode, PIDFCoefficients coefficients) {\n        PIDFCoefficients compensatedCoefficients = new PIDFCoefficients(\n                coefficients.p, coefficients.i, coefficients.d,\n                coefficients.f * 12 / batteryVoltageSensor.getVoltage()\n        );\n        for (DcMotorEx motor : motors) {\n            motor.setPIDFCoefficients(runMode, compensatedCoefficients);\n        }\n    }\n\n    public void setWeightedDrivePower(Pose2d drivePower) {\n        Pose2d vel = drivePower;\n\n        if (Math.abs(drivePower.getX()) + Math.abs(drivePower.getHeading()) > 1) {\n            // re-normalize the powers according to the weights\n            double denom = VX_WEIGHT * Math.abs(drivePower.getX())\n                    + OMEGA_WEIGHT * Math.abs(drivePower.getHeading());\n\n            vel = new Pose2d(\n                    VX_WEIGHT * drivePower.getX(),\n                    0,\n                    OMEGA_WEIGHT * drivePower.getHeading()\n            ).div(denom);\n        }\n\n        setDrivePower(vel);\n    }\n\n    @NonNull\n    @Override\n    public List<Double> getWheelPositions() {\n        double leftSum = 0, rightSum = 0;\n        for (DcMotorEx leftMotor : leftMotors) {\n            leftSum += encoderTicksToInches(leftMotor.getCurrentPosition());\n        }\n        for (DcMotorEx rightMotor : rightMotors) {\n            rightSum += encoderTicksToInches(rightMotor.getCurrentPosition());\n        }\n        return Arrays.asList(leftSum / leftMotors.size(), rightSum / rightMotors.size());\n    }\n\n    public List<Double> getWheelVelocities() {\n        double leftSum = 0, rightSum = 0;\n        for (DcMotorEx leftMotor : leftMotors) {\n            leftSum += encoderTicksToInches(leftMotor.getVelocity());\n        }\n        for (DcMotorEx rightMotor : rightMotors) {\n            rightSum += encoderTicksToInches(rightMotor.getVelocity());\n        }\n        return Arrays.asList(leftSum / leftMotors.size(), rightSum / rightMotors.size());\n    }\n\n    @Override\n    public void setMotorPowers(double v, double v1) {\n        for (DcMotorEx leftMotor : leftMotors) {\n            leftMotor.setPower(v);\n        }\n        for (DcMotorEx rightMotor : rightMotors) {\n            rightMotor.setPower(v1);\n        }\n    }\n\n    @Override\n    public double getRawExternalHeading() {\n        return imu.getAngularOrientation().firstAngle;\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleTankDrive.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/SampleTankDrive.java	(date 1609716235517)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive;
 
 import androidx.annotation.NonNull;
 
@@ -30,21 +30,21 @@
 import com.qualcomm.robotcore.hardware.VoltageSensor;
 import com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;
 
-import org.firstinspires.ftc.teamcode.util.DashboardUtil;
-import org.firstinspires.ftc.teamcode.util.LynxModuleUtil;
+import org.firstinspires.ftc.teamcode.TestPrograms.util.DashboardUtil;
+import org.firstinspires.ftc.teamcode.TestPrograms.util.LynxModuleUtil;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.BASE_CONSTRAINTS;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.TRACK_WIDTH;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.encoderTicksToInches;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kA;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kStatic;
-import static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.BASE_CONSTRAINTS;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.MOTOR_VELO_PID;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.RUN_USING_ENCODER;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.TRACK_WIDTH;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.encoderTicksToInches;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kA;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kStatic;
+import static org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants.kV;
 
 /*
  * Simple tank drive hardware implementation for REV hardware.
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/DriveConstants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.trajectory.constraints.DriveConstraints;\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\n\n/*\n * Constants shared between multiple drive types.\n *\n * TODO: Tune or adjust the following constants to fit your robot. Note that the non-final\n * fields may also be edited through the dashboard (connect to the robot's WiFi network and\n * navigate to https://192.168.49.1:8080/dash). Make sure to save the values here after you\n * adjust them in the dashboard; **config variable changes don't persist between app restarts**.\n *\n * These are not the only parameters; some are located in the localizer classes, drive base classes,\n * and op modes themselves.\n */\n@Config\npublic class DriveConstants {\n\n    /*\n     * These are motor constants that should be listed online for your motors.\n     */\n    public static final double TICKS_PER_REV = 383.6;\n    public static final double MAX_RPM = 435;\n\n    /*\n     * Set RUN_USING_ENCODER to true to enable built-in hub velocity control using drive encoders.\n     * Set this flag to false if drive encoders are not present and an alternative localization\n     * method is in use (e.g., tracking wheels).\n     *\n     * If using the built-in motor velocity PID, update MOTOR_VELO_PID with the tuned coefficients\n     * from DriveVelocityPIDTuner.\n     */\n    public static final boolean RUN_USING_ENCODER = false;\n    public static PIDFCoefficients MOTOR_VELO_PID = new PIDFCoefficients(0, 0, 0, getMotorVelocityF(MAX_RPM / 60 * TICKS_PER_REV));\n\n    /*\n     * These are physical constants that can be determined from your robot (including the track\n     * width; it will be tune empirically later although a rough estimate is important). Users are\n     * free to chose whichever linear distance unit they would like so long as it is consistently\n     * used. The default values were selected with inches in mind. Road runner uses radians for\n     * angular distances although most angular parameters are wrapped in Math.toRadians() for\n     * convenience. Make sure to exclude any gear ratio included in MOTOR_CONFIG from GEAR_RATIO.\n     */\n    public static double WHEEL_RADIUS = 1.9685; // in\n    public static double GEAR_RATIO = 1; // output (wheel) speed / input (motor) speed\n    public static double TRACK_WIDTH = 17.66; // in\n\n    /*\n     * These are the feedforward parameters used to model the drive motor behavior. If you are using\n     * the built-in velocity PID, *these values are fine as is*. However, if you do not have drive\n     * motor encoders or have elected not to use them for velocity control, these values should be\n     * empirically tuned.\n     */\n    public static double kV = 0.012;\n    public static double kA = 0.00001;\n    public static double kStatic = 0.12;\n        //public static double kV      = 0.013;\n    //public static double kA      = 0.00012;\n    //public static double kStatic = 0.1104;\n\n\n    /*\n     * These values are used to generate the trajectories for you robot. To ensure proper operation,\n     * the constraints should never exceed ~80% of the robot's actual capabilities. While Road\n     * Runner is designed to enable faster autonomous motion, it is a good idea for testing to start\n     * small and gradually increase them later after everything is working. The velocity and\n     * acceleration values are required, and the jerk values are optional (setting a jerk of 0.0\n     * forces acceleration-limited profiling). All distance units are inches.\n     */\n    public static DriveConstraints BASE_CONSTRAINTS = new DriveConstraints(\n            40.0, 40.0, 0.0,\n            Math.toRadians(180.0), Math.toRadians(180.0), 0.0\n    );\n\n\n    public static double encoderTicksToInches(double ticks) {\n        return WHEEL_RADIUS * 2 * Math.PI * GEAR_RATIO * ticks / TICKS_PER_REV;\n    }\n\n    public static double rpmToVelocity(double rpm) {\n        return rpm * GEAR_RATIO * 2 * Math.PI * WHEEL_RADIUS / 60.0;\n    }\n\n    public static double getMotorVelocityF(double ticksPerSecond) {\n        // see https://docs.google.com/document/d/1tyWrXDfMidwYyP_5H4mZyVgaEswhOC35gvdmP-V-5hA/edit#heading=h.61g9ixenznbx\n        return 32767 / ticksPerSecond;\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/DriveConstants.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/DriveConstants.java	(date 1609716235658)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive;
 
 import com.acmerobotics.dashboard.config.Config;
 import com.acmerobotics.roadrunner.trajectory.constraints.DriveConstraints;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/testBotUtility.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestBot;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.util.ElapsedTime;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\nimport org.firstinspires.ftc.teamcode.JARVISAutonomousBase;\n\nimport java.util.List;\n\npublic class testBotUtility extends LinearOpMode {\n\n    public enum Direction {\n        FORWARD, BACKWARD, STRAFE_RIGHT, STRAFE_LEFT, SLIDE_UP, SLIDE_DOWN, SLIDE_IN, SLIDE_OUT, DIAGONAL_LEFT, DIAGONAL_RIGHT;\n    }\n\n    public enum SensorsToUse {\n        NONE, USE_COLOR_LEFT, USE_COLOR_RIGHT, USE_DISTANCE_LEFT, USE_DISTANCE_RIGHT, USE_TOUCH,\n        USE_DISTANCE_RIGHT_BLD, USE_DISTANCE_LEFT_BLD, USE_DISTANCE_LEFT_FDT, USE_DISTANCE_RIGHT_FDT,\n        USE_DISTANCE_FRONT;\n    }\n\n    public enum SideToUse {\n        USE_LEFT, USE_RIGHT;\n    }\n\n    public testBotHW robot = new testBotHW();\n    public ElapsedTime runtime = new ElapsedTime();\n    private Orientation lastAngles = new Orientation();\n    private double globalAngle = 0;\n    // public direction;\n    public double ref_angle = 0;\n\n    public testBotUtility.Direction direction;\n\n    public double distance_traveled = 0;\n\n    static final double COUNTS_PER_MOTOR_REV = 145.6;    // eg: goBilda 5202 Motor Encoder 5.2*28\n    static final double DRIVE_GEAR_REDUCTION = 2.0;     // This is < 1.0 if geared UP\n    static final double WHEEL_DIAMETER_INCHES = 4.0;     // For figuring circumference\n    static final double COUNTS_PER_INCH = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) / (WHEEL_DIAMETER_INCHES * 3.1415);\n    static final double PULLEY_COUNTS_PER_INCH = (50.9 * 28) / (1 * 3.1415); //gobilda 5202 117 rpm motors\n    static final double INOUT_COUNTS_PER_INCH = (19.2 * 28) / (2 * 3.1415); //gobilda 5202 117 rpm motors\n\n    static final double DRIVE_SPEED = 0.3;\n    static final double TURN_SPEED = 0.7;\n\n    private static final String TFOD_MODEL_ASSET = \"Skystone.tflite\";\n    private static final String LABEL_FIRST_ELEMENT = \"Stone\";\n    private static final String LABEL_SECOND_ELEMENT = \"Skystone\";\n    final String VUFORIA_KEY = \"ATVrdOT/////AAABmegFa9L6UUB2ljwRjEStPmU7NS6gi/+GLAe6uAv7o+cB7+pj9EORNLk32cxovTaRj+rUeNw75EMjs5jM0K2OlNn8iO861FyZ5bqnHeBQRr/tR4NIZkQq4ak2zpPLQyyGFzhEkHjnhenYh0dyvxluXF79u8VwJ+g77slCyrCjvgMp6VfEAPLpVJmjzq4hRJMtjYpoRp/agnYFU8HVnmQeGRbjKi1PHLbhP98IkGMowt6Hlobdd2l0vt7msVhwNombHz0XcwJEjwnRKoOkeg7s+kIWvd5paYiO/bnClo9DahFboEFWw1/9wutXgI6/7AGcvwZzkk1HwRh3qZRAWNUSq1hrcjdq9f2QXAYyiqd3wLpT\";\n\n\n    public TFObjectDetector tfod = null;\n    public VuforiaLocalizer vuforia = null;\n\n    @Override\n    public void runOpMode() {\n        //Empty Function\n    }\n\n    private void initVuforia() {\n        RobotLog.ii(\"CAL\", \"Enter -  initVuforia\");\n\n        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.BACK;\n        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n\n        RobotLog.ii(\"CAL\", \"Exit -  initVuforia\");\n        telemetry.addData(\"Path1\", \"Init Vuforia Done\");\n        telemetry.update();\n    }\n\n    private void initTfod() {\n        RobotLog.ii(\"CAL\", \"Enter -  initTfod\");\n        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n        tfodParameters.minimumConfidence = 0.8;\n        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n\n        RobotLog.ii(\"CAL\", \"Exit -  initTfod\");\n        telemetry.addData(\"Path1\", \"initTfod Done\");\n        telemetry.update();\n    }\n\n    public void initHW() {\n        RobotLog.ii(\"CAL\", \"Enter -  initHW\");\n        robot.init(hardwareMap);\n        //robot.initMotorEncoders();\n        /*\n        initVuforia();\n\n        if (ClassFactory.getInstance().canCreateTFObjectDetector()) {\n            initTfod();\n        } else {\n            telemetry.addData(\"Sorry!\", \"This device is not compatible with TFOD\");\n        }\n\n        if (tfod != null) {\n            tfod.activate();\n        }\n        */\n        telemetry.addData(\"Path1\", \"Init HW Done\");\n        telemetry.update();\n\n        RobotLog.ii(\"CAL\", \"Exit -  initHW\");\n    }\n\n    private void resetAngle() {\n        lastAngles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n        RobotLog.ii(\"CAL\", \"resetAngle - lastAngles = %2.2f\", lastAngles.firstAngle);\n        globalAngle = 0;\n    }\n\n    public double getAngle() {\n        // We experimentally determined the Z axis is the axis we want to use for heading angle.\n        // We have to process the angle because the imu works in euler angles so the Z axis is\n        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes\n        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.\n\n        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n\n        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;\n\n        if (deltaAngle < -180)\n            deltaAngle += 360;\n        else if (deltaAngle > 180)\n            deltaAngle -= 360;\n\n        globalAngle += deltaAngle;\n\n        lastAngles = angles;\n\n        return globalAngle;\n    }\n\n    public double getAbsoluteAngle() {\n        // We experimentally determined the Z axis is the axis we want to use for heading angle.\n        // We have to process the angle because the imu works in euler angles so the Z axis is\n        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes\n        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.\n\n        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n\n        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;\n\n        if (deltaAngle < -180)\n            deltaAngle += 360;\n        else if (deltaAngle > 180)\n            deltaAngle -= 360;\n\n        globalAngle += deltaAngle;\n\n        lastAngles = angles;\n\n        return globalAngle;\n    }\n\n\n    public void rotate(int degrees, double power) {\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\n                degrees, power);\n        robot.initMotorNoEncoders();\n        // restart imu movement tracking.\n        resetAngle();\n\n        if (degrees < 0) {   // turn right.\n            robot.moveHolonomic(0, 0, power * -1);\n        } else if (degrees > 0) {   // turn left.\n            robot.moveHolonomic(0, 0, power * 1);\n        } else return;\n\n\n        // rotate until turn is completed.\n        if (degrees < 0) {\n            // On right turn we have to get off zero first.\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\n            }\n\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\n            }\n        } else    // left turn.\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\n            }\n\n        // turn the motors off.\n        power = 0;\n        robot.leftMotor.setPower(power);\n        robot.rightMotor.setPower(power);\n        robot.backleftMotor.setPower(power);\n        robot.backrightMotor.setPower(power);\n\n        // wait for rotation to stop.\n        sleep(50);\n\n        // reset angle tracking on new heading.\n        resetAngle();\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\n    }\n\n    public void rotateFrontUsingOneSide(int degrees, double speed) {\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\n                degrees, speed);\n\n        // restart imu movement tracking.\n        resetAngle();\n\n        if (degrees < 0) {   // turn right.\n            robot.leftMotor.setPower(0);\n            robot.rightMotor.setPower(1 * speed);\n            robot.backleftMotor.setPower(0);\n            robot.backrightMotor.setPower(1 * speed);\n        } else if (degrees > 0) {   // turn left.\n            robot.leftMotor.setPower(1 * speed);\n            robot.rightMotor.setPower(0);\n            robot.backleftMotor.setPower(1 * speed);\n            robot.backrightMotor.setPower(0);\n        } else return;\n\n\n        // rotate until turn is completed.\n        if (degrees < 0) {\n            // On right turn we have to get off zero first.\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\n            }\n\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\n            }\n        } else    // left turn.\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\n            }\n\n        // turn the motors off.\n        int power = 0;\n        robot.leftMotor.setPower(power);\n        robot.rightMotor.setPower(power);\n        robot.backleftMotor.setPower(power);\n        robot.backrightMotor.setPower(power);\n\n        // wait for rotation to stop.\n        sleep(50);\n\n        // reset angle tracking on new heading.\n        resetAngle();\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\n    }\n\n    public void rotateUsingOneSide(int degrees, double speed) {\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\n                degrees, speed);\n\n        // restart imu movement tracking.\n        resetAngle();\n\n        if (degrees < 0) {   // turn right.\n            robot.leftMotor.setPower(0);\n            robot.rightMotor.setPower(-1 * speed);\n            robot.backleftMotor.setPower(0);\n            robot.backrightMotor.setPower(-1 * speed);\n        } else if (degrees > 0) {   // turn left.\n            robot.leftMotor.setPower(-1 * speed);\n            robot.rightMotor.setPower(0);\n            robot.backleftMotor.setPower(-1 * speed);\n            robot.backrightMotor.setPower(0);\n        } else return;\n\n\n        // rotate until turn is completed.\n        if (degrees < 0) {\n            // On right turn we have to get off zero first.\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\n            }\n\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\n            }\n        } else    // left turn.\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\n            }\n\n        // turn the motors off.\n        int power = 0;\n        robot.leftMotor.setPower(power);\n        robot.rightMotor.setPower(power);\n        robot.backleftMotor.setPower(power);\n        robot.backrightMotor.setPower(power);\n\n        // wait for rotation to stop.\n        sleep(50);\n\n        // reset angle tracking on new heading.\n        resetAngle();\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\n    }\n\n\n    public void myEncoderDrive(JARVISAutonomousBase.Direction direction, double speed, double Inches, double timeoutS, JARVISAutonomousBase.SensorsToUse sensors_2_use) {\n        int newLeftTarget = 0;\n        int newRightTarget = 0;\n        int newLeftBackTarget = 0;\n        int newRightBackTarget = 0;\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderDrive -  speed=%f, Inches=%f, timeout=%f\",\n                speed, Inches, timeoutS);\n\n        robot.leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.backleftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.backrightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        //Reset the encoder\n        robot.leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.backrightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.backleftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested()) {\n\n            // Determine new target position, and pass to motor controller\n            if (direction == JARVISAutonomousBase.Direction.FORWARD) {\n                //Go forward\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n            } else if (direction == JARVISAutonomousBase.Direction.BACKWARD) {\n                //Go backward\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n            } else if (direction == JARVISAutonomousBase.Direction.STRAFE_RIGHT) {\n                //Strafe Right\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n\n            } else if (direction == JARVISAutonomousBase.Direction.STRAFE_LEFT) {\n                //Strafe Left\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n\n            } else if (direction == JARVISAutonomousBase.Direction.DIAGONAL_LEFT) {\n                //Left Diagonal\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n\n            } else if (direction == JARVISAutonomousBase.Direction.DIAGONAL_RIGHT) {\n                //Right Diagonal\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n\n            } else {\n                Inches = 0;\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n            }\n\n\n            robot.leftMotor.setTargetPosition(newLeftTarget);\n            robot.rightMotor.setTargetPosition(newRightTarget);\n            robot.backleftMotor.setTargetPosition(newLeftBackTarget);\n            robot.backrightMotor.setTargetPosition(newRightBackTarget);\n\n            // Turn On RUN_TO_POSITION\n            robot.leftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n            robot.rightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n            robot.backleftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n            robot.backrightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n            // reset the timeout time and start motion.\n            runtime.reset();\n\n            robot.leftMotor.setPower(Math.abs(speed));\n            robot.rightMotor.setPower(Math.abs(speed));\n            robot.backleftMotor.setPower(Math.abs(speed));\n            robot.backrightMotor.setPower(Math.abs(speed));\n\n            while (opModeIsActive() && !isStopRequested() &&\n                    (runtime.seconds() < timeoutS) &&\n                    (robot.leftMotor.isBusy())) {\n\n\n\n\n            }\n        }\n\n        // Stop all motion;\n        robot.leftMotor.setPower(0);\n        robot.rightMotor.setPower(0);\n        robot.backleftMotor.setPower(0);\n        robot.backrightMotor.setPower(0);\n\n        distance_traveled = robot.rightMotor.getCurrentPosition() / COUNTS_PER_INCH;\n\n        // Turn off RUN_TO_POSITION\n        robot.leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        robot.rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        robot.backleftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        robot.backrightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        sleep(50);   // optional pause after each move\n    }\n\n    public void myTFOD(double timeoutS) {\n        {\n            // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\n            // first.\n\n            boolean strafeDone = false;\n            RobotLog.ii(\"CAL\", \"myTFOD - Enter\");\n\n            while (opModeIsActive() && !isStopRequested()) {\n\n                if (tfod == null) {\n                    robot.moveHolonomic(0, 0, 0);\n                    break;\n                }\n\n                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n\n                if (updatedRecognitions != null) {\n                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n                    // step through the list of recognitions and display boundary info.\n                    if (updatedRecognitions.size() == 0) {\n                        robot.moveHolonomic(0, 0, 0);\n                    } else {\n                        int i = 0;\n                        for (Recognition recognition : updatedRecognitions) {\n                            if (recognition.getLabel().equals(LABEL_SECOND_ELEMENT)) {\n                                double targetHeightRatio = (float) 0.8;\n                                double imageHeight = recognition.getImageHeight();\n                                double imageWidth = recognition.getImageWidth();\n                                double objectHeight = recognition.getHeight();\n                                double objectHeightRatio = objectHeight / imageHeight;\n                                double power = 0.1;\n                                double mid = (recognition.getLeft() + recognition.getRight()) / 2;\n                                double i_left = recognition.getLeft();\n                                double i_right = recognition.getRight();\n\n                                telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n                                telemetry.addData(\" \", \"Image Width (%.1f), image Height (%.1f), object Height (%.1f)\",\n                                        imageWidth, imageHeight, objectHeight);\n                                telemetry.addData(String.format(\" init left,right (%d)\", i), \"%.03f , %.03f\",\n                                        i_left, i_right);\n\n                                if (strafeDone == false) {\n                                    if (mid < (640 - 100)) {\n                                        telemetry.addData(String.format(\" mid(%f) < 540 \", mid), \"\");\n                                        robot.moveHolonomic(-1 * power, 0, 0);\n                                    } else if (mid > (640 + 100)) {\n                                        telemetry.addData(String.format(\" mid(%f) > 740 \", mid), \"\");\n                                        robot.moveHolonomic(1 * power, 0, 0);\n                                    } else {\n                                        strafeDone = true;\n                                        robot.moveHolonomic(0, 0, 0);\n                                    }\n                                }\n\n                                if (strafeDone == true) {\n                                    telemetry.addData(\" \", \" Shank Strafe done\");\n\n                                    if (objectHeightRatio < targetHeightRatio) {\n                                        telemetry.addData(\" \", \" SHANK object < target power=%f\", power);\n\n                                        robot.moveHolonomic(0, 1 * power, 0);\n                                    } else {\n                                        robot.moveHolonomic(0, 0, 0);\n                                    }\n                                }\n\n                            } else {\n                                telemetry.addData(\"Not a skystone\", \" \");\n\n                            }\n                        }\n                    }\n                    telemetry.update();\n                }\n\n                //RobotLog.ii(\"CAL\", \"while opModeIsActive and !isStopRequested - Enter\");\n            }\n            RobotLog.ii(\"CAL\", \"Exit if opModeIsActive\");\n\n            if (tfod != null) {\n                tfod.shutdown();\n            }\n            RobotLog.ii(\"CAL\", \"myTFOD - Exits\");\n\n        }\n    }\n\n    public boolean myTFOD2(double timeoutS) {\n        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\n        // first.\n        boolean strafeDone = false;\n        RobotLog.ii(\"CAL\", \"myTFOD - Enter\");\n\n\n        while (opModeIsActive() && !isStopRequested()) {\n\n            if (tfod == null) {\n                robot.moveHolonomic(0, 0, 0);\n                break;\n            }\n\n            List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n\n            if (updatedRecognitions != null) {\n                telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n                // step through the list of recognitions and display boundary info.\n                if (updatedRecognitions.size() == 0) {\n                    robot.moveHolonomic(0, 0, 0);\n                } else {\n                    int i = 0;\n                    for (Recognition recognition : updatedRecognitions) {\n                        if (recognition.getLabel().equals(LABEL_SECOND_ELEMENT)) {\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    }\n                }\n                telemetry.update();\n                RobotLog.ii(\"CAL\", \"Exit if opModeIsActive\");\n\n                if (tfod != null) {\n                    tfod.shutdown();\n                }\n                RobotLog.ii(\"CAL\", \"myTFOD - Exits\");\n\n            }\n        }\n        return false;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/testBotUtility.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/testBotUtility.java	(date 1609716235725)
@@ -13,7 +13,7 @@
 import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
 import org.firstinspires.ftc.robotcore.external.tfod.Recognition;
 import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;
-import org.firstinspires.ftc.teamcode.JARVISAutonomousBase;
+import org.firstinspires.ftc.teamcode.TestPrograms.JARVISAutonomousBase;
 
 import java.util.List;
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/MaxVelocityTuner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.VoltageSensor;\nimport com.qualcomm.robotcore.util.ElapsedTime;\n\nimport org.firstinspires.ftc.teamcode.drive.DriveConstants;\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\nimport java.util.Objects;\n\n/**\n * This routine is designed to calculate the maximum velocity your bot can achieve under load. It\n * will also calculate the effective kF value for your velocity PID.\n * <p>\n * Upon pressing start, your bot will run at max power for RUNTIME seconds.\n * <p>\n * Further fine tuning of kF may be desired.\n */\n@Config\n@Autonomous(group = \"drive\")\npublic class MaxVelocityTuner extends LinearOpMode {\n    public static double RUNTIME = 2.0;\n\n    private ElapsedTime timer;\n    private double maxVelocity = 0.0;\n\n    private VoltageSensor batteryVoltageSensor;\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        drive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        batteryVoltageSensor = hardwareMap.voltageSensor.iterator().next();\n\n        telemetry.addLine(\"Your bot will go at full speed for \" + RUNTIME + \" seconds.\");\n        telemetry.addLine(\"Please ensure you have enough space cleared.\");\n        telemetry.addLine(\"\");\n        telemetry.addLine(\"Press start when ready.\");\n        telemetry.update();\n\n        waitForStart();\n\n        telemetry.clearAll();\n        telemetry.update();\n\n        drive.setDrivePower(new Pose2d(1, 0, 0));\n        timer = new ElapsedTime();\n\n        while (!isStopRequested() && timer.seconds() < RUNTIME) {\n            drive.updatePoseEstimate();\n\n            Pose2d poseVelo = Objects.requireNonNull(drive.getPoseVelocity(), \"poseVelocity() must not be null. Ensure that the getWheelVelocities() method has been overridden in your localizer.\");\n\n            maxVelocity = Math.max(poseVelo.vec().norm(), maxVelocity);\n        }\n\n        drive.setDrivePower(new Pose2d());\n\n        double effectiveKf = DriveConstants.getMotorVelocityF(veloInchesToTicks(maxVelocity));\n\n        telemetry.addData(\"Max Velocity\", maxVelocity);\n        telemetry.addData(\"Voltage Compensated kF\", effectiveKf * batteryVoltageSensor.getVoltage() / 12);\n        telemetry.update();\n\n        while (!isStopRequested() && opModeIsActive()) idle();\n    }\n\n    private double veloInchesToTicks(double inchesPerSec) {\n        return inchesPerSec / (2 * Math.PI * DriveConstants.WHEEL_RADIUS) / DriveConstants.GEAR_RATIO * DriveConstants.TICKS_PER_REV;\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/MaxVelocityTuner.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/MaxVelocityTuner.java	(date 1609716235577)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.config.Config;
 import com.acmerobotics.roadrunner.geometry.Pose2d;
@@ -8,8 +8,8 @@
 import com.qualcomm.robotcore.hardware.VoltageSensor;
 import com.qualcomm.robotcore.util.ElapsedTime;
 
-import org.firstinspires.ftc.teamcode.drive.DriveConstants;
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.DriveConstants;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 import java.util.Objects;
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/LynxModuleUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.util;\n\nimport com.qualcomm.hardware.lynx.LynxModule;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\n\nimport org.firstinspires.ftc.robotcore.internal.system.Misc;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Collection of utilites for interacting with Lynx modules.\n */\npublic class LynxModuleUtil {\n\n    private static final LynxFirmwareVersion MIN_VERSION = new LynxFirmwareVersion(1, 8, 2);\n\n    /**\n     * Parsed representation of a Lynx module firmware version.\n     */\n    public static class LynxFirmwareVersion implements Comparable<LynxFirmwareVersion> {\n        public final int major;\n        public final int minor;\n        public final int eng;\n\n        public LynxFirmwareVersion(int major, int minor, int eng) {\n            this.major = major;\n            this.minor = minor;\n            this.eng = eng;\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (other instanceof LynxFirmwareVersion) {\n                LynxFirmwareVersion otherVersion = (LynxFirmwareVersion) other;\n                return major == otherVersion.major && minor == otherVersion.minor &&\n                        eng == otherVersion.eng;\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public int compareTo(LynxFirmwareVersion other) {\n            int majorComp = Integer.compare(major, other.major);\n            if (majorComp == 0) {\n                int minorComp = Integer.compare(minor, other.minor);\n                if (minorComp == 0) {\n                    return Integer.compare(eng, other.eng);\n                } else {\n                    return minorComp;\n                }\n            } else {\n                return majorComp;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return Misc.formatInvariant(\"%d.%d.%d\", major, minor, eng);\n        }\n    }\n\n    /**\n     * Retrieve and parse Lynx module firmware version.\n     * @param module Lynx module\n     * @return parsed firmware version\n     */\n    public static LynxFirmwareVersion getFirmwareVersion(LynxModule module) {\n        String versionString = module.getNullableFirmwareVersionString();\n        if (versionString == null) {\n            return null;\n        }\n\n        String[] parts = versionString.split(\"[ :,]+\");\n        try {\n            // note: for now, we ignore the hardware entry\n            return new LynxFirmwareVersion(\n                    Integer.parseInt(parts[3]),\n                    Integer.parseInt(parts[5]),\n                    Integer.parseInt(parts[7])\n            );\n        } catch (NumberFormatException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Exception indicating an outdated Lynx firmware version.\n     */\n    public static class LynxFirmwareVersionException extends RuntimeException {\n        public LynxFirmwareVersionException(String detailMessage) {\n            super(detailMessage);\n        }\n    }\n\n    /**\n     * Ensure all of the Lynx modules attached to the robot satisfy the minimum requirement.\n     * @param hardwareMap hardware map containing Lynx modules\n     */\n    public static void ensureMinimumFirmwareVersion(HardwareMap hardwareMap) {\n        Map<String, LynxFirmwareVersion> outdatedModules = new HashMap<>();\n        for (LynxModule module : hardwareMap.getAll(LynxModule.class)) {\n            LynxFirmwareVersion version = getFirmwareVersion(module);\n            if (version == null || version.compareTo(MIN_VERSION) < 0) {\n                for (String name : hardwareMap.getNamesOf(module)) {\n                    outdatedModules.put(name, version);\n                }\n            }\n        }\n        if (outdatedModules.size() > 0) {\n            StringBuilder msgBuilder = new StringBuilder();\n            msgBuilder.append(\"One or more of the attached Lynx modules has outdated firmware\\n\");\n            msgBuilder.append(Misc.formatInvariant(\"Mandatory minimum firmware version: %s\\n\",\n                    MIN_VERSION.toString()));\n            for (Map.Entry<String, LynxFirmwareVersion> entry : outdatedModules.entrySet()) {\n                msgBuilder.append(Misc.formatInvariant(\n                        \"\\t%s: %s\\n\", entry.getKey(),\n                        entry.getValue() == null ? \"Unknown\" : entry.getValue().toString()));\n            }\n            throw new LynxFirmwareVersionException(msgBuilder.toString());\n        }\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/LynxModuleUtil.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/util/LynxModuleUtil.java	(date 1609716235555)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.util;
+package org.firstinspires.ftc.teamcode.TestPrograms.util;
 
 import com.qualcomm.hardware.lynx.LynxModule;
 import com.qualcomm.robotcore.hardware.HardwareMap;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/RegressionUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.util;\n\nimport androidx.annotation.Nullable;\n\nimport com.acmerobotics.roadrunner.kinematics.Kinematics;\n\nimport org.apache.commons.math3.stat.regression.SimpleRegression;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Various regression utilities.\n */\npublic class RegressionUtil {\n\n    /**\n     * Feedforward parameter estimates from the ramp regression and additional summary statistics\n     */\n    public static class RampResult {\n        public final double kV, kStatic, rSquare;\n\n        public RampResult(double kV, double kStatic, double rSquare) {\n            this.kV = kV;\n            this.kStatic = kStatic;\n            this.rSquare = rSquare;\n        }\n    }\n\n    /**\n     * Feedforward parameter estimates from the ramp regression and additional summary statistics\n     */\n    public static class AccelResult {\n        public final double kA, rSquare;\n\n        public AccelResult(double kA, double rSquare) {\n            this.kA = kA;\n            this.rSquare = rSquare;\n        }\n    }\n\n    /**\n     * Numerically compute dy/dx from the given x and y values. The returned list is padded to match\n     * the length of the original sequences.\n     *\n     * @param x x-values\n     * @param y y-values\n     * @return derivative values\n     */\n    private static List<Double> numericalDerivative(List<Double> x, List<Double> y) {\n        List<Double> deriv = new ArrayList<>(x.size());\n        for (int i = 1; i < x.size() - 1; i++) {\n            deriv.add(\n                    (y.get(i + 1) - y.get(i - 1)) /\n                    (x.get(i + 1) - x.get(i - 1))\n            );\n        }\n        // copy endpoints to pad output\n        deriv.add(0, deriv.get(0));\n        deriv.add(deriv.get(deriv.size() - 1));\n        return deriv;\n    }\n\n    /**\n     * Run regression to compute velocity and static feedforward from ramp test data.\n     *\n     * Here's the general procedure for gathering the requisite data:\n     *   1. Slowly ramp the motor power/voltage and record encoder values along the way.\n     *   2. Run a linear regression on the encoder velocity vs. motor power plot to obtain a slope\n     *      (kV) and an optional intercept (kStatic).\n     *\n     * @param timeSamples time samples\n     * @param positionSamples position samples\n     * @param powerSamples power samples\n     * @param fitStatic fit kStatic\n     * @param file log file\n     */\n    public static RampResult fitRampData(List<Double> timeSamples, List<Double> positionSamples,\n                                         List<Double> powerSamples, boolean fitStatic,\n                                         @Nullable File file) {\n        if (file != null) {\n            try (PrintWriter pw = new PrintWriter(file)) {\n                pw.println(\"time,position,power\");\n                for (int i = 0; i < timeSamples.size(); i++) {\n                    double time = timeSamples.get(i);\n                    double pos = positionSamples.get(i);\n                    double power = powerSamples.get(i);\n                    pw.println(time + \",\" + pos + \",\" + power);\n                }\n            } catch (FileNotFoundException e) {\n                // ignore\n            }\n        }\n\n        List<Double> velSamples = numericalDerivative(timeSamples, positionSamples);\n\n        SimpleRegression rampReg = new SimpleRegression(fitStatic);\n        for (int i = 0; i < timeSamples.size(); i++) {\n            double vel = velSamples.get(i);\n            double power = powerSamples.get(i);\n\n            rampReg.addData(vel, power);\n        }\n\n        return new RampResult(Math.abs(rampReg.getSlope()), Math.abs(rampReg.getIntercept()),\n                              rampReg.getRSquare());\n    }\n\n    /**\n     * Run regression to compute acceleration feedforward.\n     *\n     * @param timeSamples time samples\n     * @param positionSamples position samples\n     * @param powerSamples power samples\n     * @param rampResult ramp result\n     * @param file log file\n     */\n    public static AccelResult fitAccelData(List<Double> timeSamples, List<Double> positionSamples,\n                                           List<Double> powerSamples, RampResult rampResult,\n                                           @Nullable File file) {\n        if (file != null) {\n            try (PrintWriter pw = new PrintWriter(file)) {\n                pw.println(\"time,position,power\");\n                for (int i = 0; i < timeSamples.size(); i++) {\n                    double time = timeSamples.get(i);\n                    double pos = positionSamples.get(i);\n                    double power = powerSamples.get(i);\n                    pw.println(time + \",\" + pos + \",\" + power);\n                }\n            } catch (FileNotFoundException e) {\n                // ignore\n            }\n        }\n\n        List<Double> velSamples = numericalDerivative(timeSamples, positionSamples);\n        List<Double> accelSamples = numericalDerivative(timeSamples, velSamples);\n\n        SimpleRegression accelReg = new SimpleRegression(false);\n        for (int i = 0; i < timeSamples.size(); i++) {\n            double vel = velSamples.get(i);\n            double accel = accelSamples.get(i);\n            double power = powerSamples.get(i);\n\n            double powerFromVel = Kinematics.calculateMotorFeedforward(\n                    vel, 0.0, rampResult.kV, 0.0, rampResult.kStatic);\n            double powerFromAccel = power - powerFromVel;\n\n            accelReg.addData(accel, powerFromAccel);\n        }\n\n        return new AccelResult(Math.abs(accelReg.getSlope()), accelReg.getRSquare());\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/RegressionUtil.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/util/RegressionUtil.java	(date 1609716235591)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.util;
+package org.firstinspires.ftc.teamcode.TestPrograms.util;
 
 import androidx.annotation.Nullable;
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/Encoder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.util;\n\nimport com.acmerobotics.roadrunner.util.NanoClock;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\n\n/**\n * Wraps a motor instance to provide corrected velocity counts and allow reversing without changing the corresponding\n * slot's motor direction\n */\npublic class Encoder {\n    private final static int CPS_STEP = 0x10000;\n\n    private static double inverseOverflow(double input, double estimate) {\n        double real = input;\n        while (Math.abs(estimate - real) > CPS_STEP / 2.0) {\n            real += Math.signum(estimate - real) * CPS_STEP;\n        }\n        return real;\n    }\n\n    public enum Direction {\n        FORWARD(1),\n        REVERSE(-1);\n\n        private int multiplier;\n\n        Direction(int multiplier) {\n            this.multiplier = multiplier;\n        }\n\n        public int getMultiplier() {\n            return multiplier;\n        }\n    }\n\n    private DcMotorEx motor;\n    private NanoClock clock;\n\n    private Direction direction;\n\n    private int lastPosition;\n    private double velocityEstimate;\n    private double lastUpdateTime;\n\n    public Encoder(DcMotorEx motor, NanoClock clock) {\n        this.motor = motor;\n        this.clock = clock;\n\n        this.direction = Direction.FORWARD;\n\n        this.lastPosition = 0;\n        this.velocityEstimate = 0.0;\n        this.lastUpdateTime = clock.seconds();\n    }\n\n    public Encoder(DcMotorEx motor) {\n        this(motor, NanoClock.system());\n    }\n\n    public Direction getDirection() {\n        return direction;\n    }\n\n    /**\n     * Allows you to set the direction of the counts and velocity without modifying the motor's direction state\n     * @param direction either reverse or forward depending on if encoder counts should be negated\n     */\n    public void setDirection(Direction direction) {\n        this.direction = direction;\n    }\n\n    public int getCurrentPosition() {\n        int multiplier = direction.getMultiplier();\n        int currentPosition = motor.getCurrentPosition() * multiplier;\n        if (currentPosition != lastPosition) {\n            double currentTime = clock.seconds();\n            double dt = currentTime - lastUpdateTime;\n            velocityEstimate = (currentPosition - lastPosition) / dt;\n            lastPosition = currentPosition;\n            lastUpdateTime = currentTime;\n        }\n        return currentPosition;\n    }\n\n    public double getRawVelocity() {\n        int multiplier = direction.getMultiplier();\n        return motor.getVelocity() * multiplier;\n    }\n\n    public double getCorrectedVelocity() {\n        return inverseOverflow(getRawVelocity(), velocityEstimate);\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/Encoder.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/util/Encoder.java	(date 1609716235634)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.util;
+package org.firstinspires.ftc.teamcode.TestPrograms.util;
 
 import com.acmerobotics.roadrunner.util.NanoClock;
 import com.qualcomm.robotcore.hardware.DcMotorEx;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/LoggingUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.util;\n\nimport org.firstinspires.ftc.robotcore.internal.system.AppUtil;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Utility functions for log files.\n */\npublic class LoggingUtil {\n    public static final File ROAD_RUNNER_FOLDER =\n            new File(AppUtil.ROOT_FOLDER + \"/RoadRunner/\");\n\n    private static final long LOG_QUOTA = 25 * 1024 * 1024; // 25MB log quota for now\n\n    private static void buildLogList(List<File> logFiles, File dir) {\n        for (File file : dir.listFiles()) {\n            if (file.isDirectory()) {\n                buildLogList(logFiles, file);\n            } else {\n                logFiles.add(file);\n            }\n        }\n    }\n\n    private static void pruneLogsIfNecessary() {\n        List<File> logFiles = new ArrayList<>();\n        buildLogList(logFiles, ROAD_RUNNER_FOLDER);\n        //Collections.sort(logFiles, (lhs, rhs) ->\n        //        Long.compare(lhs.lastModified(), rhs.lastModified()));\n\n        long dirSize = 0;\n        for (File file: logFiles) {\n            dirSize += file.length();\n        }\n\n        while (dirSize > LOG_QUOTA) {\n            if (logFiles.size() == 0) break;\n            File fileToRemove = logFiles.remove(0);\n            dirSize -= fileToRemove.length();\n            //noinspection ResultOfMethodCallIgnored\n            fileToRemove.delete();\n        }\n    }\n\n    /**\n     * Obtain a log file with the provided name\n     */\n    public static File getLogFile(String name) {\n        //noinspection ResultOfMethodCallIgnored\n        ROAD_RUNNER_FOLDER.mkdirs();\n\n        pruneLogsIfNecessary();\n\n        return new File(ROAD_RUNNER_FOLDER, name);\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/LoggingUtil.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/util/LoggingUtil.java	(date 1609716235535)
@@ -1,10 +1,9 @@
-package org.firstinspires.ftc.teamcode.util;
+package org.firstinspires.ftc.teamcode.TestPrograms.util;
 
 import org.firstinspires.ftc.robotcore.internal.system.AppUtil;
 
 import java.io.File;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/BNO055IMUUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.util;\n\nimport com.qualcomm.hardware.bosch.BNO055IMU;\n\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\n\n/**\n * Various utility functions for the BNO055 IMU.\n */\npublic class BNO055IMUUtil {\n    /**\n     * Remap BNO055 IMU axes and signs. For reference, the default order is {@link AxesOrder#ZYX}.\n     * Call after {@link BNO055IMU#initialize(BNO055IMU.Parameters)}. Although this isn't\n     * mentioned in the datasheet, the axes order appears to affect the onboard sensor fusion.\n     *\n     * Adapted from <a href=\"https://ftcforum.usfirst.org/forum/ftc-technology/53812-mounting-the-revhub-vertically?p=56587#post56587\">this post</a>.\n     *\n     * @param imu IMU\n     * @param order axes order\n     * @param signs axes signs\n     */\n    public static void remapAxes(BNO055IMU imu, AxesOrder order, AxesSigns signs) {\n        try {\n            // the indices correspond with the 2-bit encodings specified in the datasheet\n            int[] indices = order.indices();\n            int axisMapConfig = 0;\n            axisMapConfig |= (indices[0] << 4);\n            axisMapConfig |= (indices[1] << 2);\n            axisMapConfig |= (indices[2] << 0);\n\n            // the BNO055 driver flips the first orientation vector so we also flip here\n            int axisMapSign = signs.bVal ^ (0b100 >> indices[0]);\n\n            // Enter CONFIG mode\n            imu.write8(BNO055IMU.Register.OPR_MODE, BNO055IMU.SensorMode.CONFIG.bVal & 0x0F);\n\n            Thread.sleep(100);\n\n            // Write the AXIS_MAP_CONFIG register\n            imu.write8(BNO055IMU.Register.AXIS_MAP_CONFIG, axisMapConfig & 0x3F);\n\n            // Write the AXIS_MAP_SIGN register\n            imu.write8(BNO055IMU.Register.AXIS_MAP_SIGN, axisMapSign & 0x07);\n\n            // Switch back to the previous mode\n            imu.write8(BNO055IMU.Register.OPR_MODE, imu.getParameters().mode.bVal & 0x0F);\n\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/BNO055IMUUtil.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/util/BNO055IMUUtil.java	(date 1609716235585)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.util;
+package org.firstinspires.ftc.teamcode.TestPrograms.util;
 
 import com.qualcomm.hardware.bosch.BNO055IMU;
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/DashboardUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.util;\n\nimport com.acmerobotics.dashboard.canvas.Canvas;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.geometry.Vector2d;\nimport com.acmerobotics.roadrunner.path.Path;\n\nimport java.util.List;\n\n/**\n * Set of helper functions for drawing Road Runner paths and trajectories on dashboard canvases.\n */\npublic class DashboardUtil {\n    private static final double DEFAULT_RESOLUTION = 2.0; // distance units; presumed inches\n    private static final double ROBOT_RADIUS = 9; // in\n\n\n    public static void drawPoseHistory(Canvas canvas, List<Pose2d> poseHistory) {\n        double[] xPoints = new double[poseHistory.size()];\n        double[] yPoints = new double[poseHistory.size()];\n        for (int i = 0; i < poseHistory.size(); i++) {\n            Pose2d pose = poseHistory.get(i);\n            xPoints[i] = pose.getX();\n            yPoints[i] = pose.getY();\n        }\n        canvas.strokePolyline(xPoints, yPoints);\n    }\n\n    public static void drawSampledPath(Canvas canvas, Path path, double resolution) {\n        int samples = (int) Math.ceil(path.length() / resolution);\n        double[] xPoints = new double[samples];\n        double[] yPoints = new double[samples];\n        double dx = path.length() / (samples - 1);\n        for (int i = 0; i < samples; i++) {\n            double displacement = i * dx;\n            Pose2d pose = path.get(displacement);\n            xPoints[i] = pose.getX();\n            yPoints[i] = pose.getY();\n        }\n        canvas.strokePolyline(xPoints, yPoints);\n    }\n\n    public static void drawSampledPath(Canvas canvas, Path path) {\n        drawSampledPath(canvas, path, DEFAULT_RESOLUTION);\n    }\n\n    public static void drawRobot(Canvas canvas, Pose2d pose) {\n        canvas.strokeCircle(pose.getX(), pose.getY(), ROBOT_RADIUS);\n        Vector2d v = pose.headingVec().times(ROBOT_RADIUS);\n        double x1 = pose.getX() + v.getX() / 2, y1 = pose.getY() + v.getY() / 2;\n        double x2 = pose.getX() + v.getX(), y2 = pose.getY() + v.getY();\n        canvas.strokeLine(x1, y1, x2, y2);\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/DashboardUtil.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/util/DashboardUtil.java	(date 1609716235549)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.util;
+package org.firstinspires.ftc.teamcode.TestPrograms.util;
 
 import com.acmerobotics.dashboard.canvas.Canvas;
 import com.acmerobotics.roadrunner.geometry.Pose2d;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/testBotAutonomousBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestBot;\r\nimport android.app.Activity;\r\nimport android.graphics.Color;\r\nimport android.view.View;\r\n\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.DriveConstraints;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.ColorSensor;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\nimport com.qualcomm.robotcore.util.RobotLog;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\r\nimport org.firstinspires.ftc.teamcode.TestBot.testBotHW;\r\n\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\n//@Disabled\r\npublic class testBotAutonomousBase extends LinearOpMode {\r\n\r\n    public enum Direction {\r\n        FORWARD, BACKWARD, STRAFE_RIGHT, STRAFE_LEFT, SLIDE_UP, SLIDE_DOWN, SLIDE_IN, SLIDE_OUT, DIAGONAL_LEFT, DIAGONAL_RIGHT;\r\n    }\r\n\r\n    public enum SensorsToUse {\r\n        NONE, USE_COLOR_LEFT, USE_COLOR_RIGHT, USE_DISTANCE_LEFT, USE_DISTANCE_RIGHT, USE_TOUCH,\r\n        USE_DISTANCE_RIGHT_BLD, USE_DISTANCE_LEFT_BLD, USE_DISTANCE_LEFT_FDT, USE_DISTANCE_RIGHT_FDT,\r\n        USE_DISTANCE_FRONT;\r\n    }\r\n\r\n    public enum SideToUse {\r\n        USE_LEFT, USE_RIGHT;\r\n    }\r\n\r\n    public testBotHW robot = new testBotHW();\r\n    public ElapsedTime runtime = new ElapsedTime();\r\n    private Orientation lastAngles = new Orientation();\r\n    private double globalAngle = 0;\r\n    // public direction;\r\n    public double ref_angle = 0;\r\n    public double ref_angle_1 = 0;\r\n\r\n    public Direction direction;\r\n\r\n    public double distance_traveled = 0;\r\n\r\n    public static final double TICKS_PER_REV = 383.6;\r\n    public static final double MAX_RPM = 435;\r\n    static final double DRIVE_GEAR_REDUCTION = 2.0;     // This is < 1.0 if geared UP\r\n    static final double WHEEL_DIAMETER_INCHES = 4.0;     // For figuring circumference\r\n    static final double COUNTS_PER_INCH = (TICKS_PER_REV * DRIVE_GEAR_REDUCTION) / (WHEEL_DIAMETER_INCHES * 3.1415);\r\n    static final double PULLEY_COUNTS_PER_INCH = (50.9 * 28) / (1 * 3.1415); //gobilda 5202 117 rpm motors\r\n    static final double INOUT_COUNTS_PER_INCH = (19.2 * 28) / (2 * 3.1415); //gobilda 5202 117 rpm motors\r\n    public static double WHEEL_RADIUS = 1.9685; // in\r\n    public static double GEAR_RATIO = 1; // output (wheel) speed / input (motor) speed\r\n    public static double TRACK_WIDTH = 17.66; // in\r\n    static final double DRIVE_SPEED = 0.3;\r\n    static final double TURN_SPEED = 0.7;\r\n\r\n    private static final String TFOD_MODEL_ASSET = \"Skystone.tflite\";\r\n    private static final String LABEL_FIRST_ELEMENT = \"Stone\";\r\n    private static final String LABEL_SECOND_ELEMENT = \"Skystone\";\r\n    final String VUFORIA_KEY = \"ATVrdOT/////AAABmegFa9L6UUB2ljwRjEStPmU7NS6gi/+GLAe6uAv7o+cB7+pj9EORNLk32cxovTaRj+rUeNw75EMjs5jM0K2OlNn8iO861FyZ5bqnHeBQRr/tR4NIZkQq4ak2zpPLQyyGFzhEkHjnhenYh0dyvxluXF79u8VwJ+g77slCyrCjvgMp6VfEAPLpVJmjzq4hRJMtjYpoRp/agnYFU8HVnmQeGRbjKi1PHLbhP98IkGMowt6Hlobdd2l0vt7msVhwNombHz0XcwJEjwnRKoOkeg7s+kIWvd5paYiO/bnClo9DahFboEFWw1/9wutXgI6/7AGcvwZzkk1HwRh3qZRAWNUSq1hrcjdq9f2QXAYyiqd3wLpT\";\r\n\r\n\r\n    public TFObjectDetector tfod = null;\r\n    public VuforiaLocalizer vuforia = null;\r\n\r\n    @Override\r\n    public void runOpMode() throws InterruptedException {\r\n        //Empty Function\r\n    }\r\n\r\n    public static DriveConstraints BASE_CONSTRAINTS = new DriveConstraints(\r\n            40.0, 40.0, 0.0,\r\n            Math.toRadians(180.0), Math.toRadians(180.0), 0.0\r\n    );\r\n\r\n\r\n    public static double encoderTicksToInches(double ticks) {\r\n        return WHEEL_RADIUS * 2 * Math.PI * GEAR_RATIO * ticks / TICKS_PER_REV;\r\n    }\r\n\r\n    public static double rpmToVelocity(double rpm) {\r\n        return rpm * GEAR_RATIO * 2 * Math.PI * WHEEL_RADIUS / 60.0;\r\n    }\r\n\r\n    public static double getMotorVelocityF(double ticksPerSecond) {\r\n        // see https://docs.google.com/document/d/1tyWrXDfMidwYyP_5H4mZyVgaEswhOC35gvdmP-V-5hA/edit#heading=h.61g9ixenznbx\r\n        return 32767 / ticksPerSecond;\r\n    }\r\n\r\n    private void initVuforia() {\r\n        RobotLog.ii(\"CAL\", \"Enter -  initVuforia\");\r\n\r\n        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\r\n        parameters.vuforiaLicenseKey = VUFORIA_KEY;\r\n        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.BACK;\r\n        vuforia = ClassFactory.getInstance().createVuforia(parameters);\r\n\r\n        RobotLog.ii(\"CAL\", \"Exit -  initVuforia\");\r\n        telemetry.addData(\"Path1\", \"Init Vuforia Done\");\r\n        telemetry.update();\r\n    }\r\n\r\n    private void initTfod() {\r\n        RobotLog.ii(\"CAL\", \"Enter -  initTfod\");\r\n        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\r\n                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\r\n        tfodParameters.minimumConfidence = 0.8;\r\n        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\r\n        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\r\n\r\n        RobotLog.ii(\"CAL\", \"Exit -  initTfod\");\r\n        telemetry.addData(\"Path1\", \"initTfod Done\");\r\n        telemetry.update();\r\n    }\r\n\r\n    public void initHW() {\r\n        RobotLog.ii(\"CAL\", \"Enter -  initHW\");\r\n        robot.init(hardwareMap);\r\n        //HELLO PLEASE ADD SOMETHING TO INITIALIZE CLOSING THE WOBBLE GOAL CLAW\r\n        //THANKS\r\n        //robot.initMotorEncoders();\r\n        /*\r\n        initVuforia();\r\n\r\n        if (ClassFactory.getInstance().canCreateTFObjectDetector()) {\r\n            initTfod();\r\n        } else {\r\n            telemetry.addData(\"Sorry!\", \"This device is not compatible with TFOD\");\r\n        }\r\n\r\n        if (tfod != null) {\r\n            tfod.activate();\r\n        }\r\n        */\r\n        telemetry.addData(\"Path1\", \"Init HW Done\");\r\n        telemetry.update();\r\n\r\n        RobotLog.ii(\"CAL\", \"Exit -  initHW\");\r\n    }\r\n\r\n    private void resetAngle() {\r\n        lastAngles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        RobotLog.ii(\"CAL\", \"resetAngle - lastAngles = %2.2f\", lastAngles.firstAngle);\r\n        globalAngle = 0;\r\n    }\r\n\r\n    public double getAngle() {\r\n        // We experimentally determined the Z axis is the axis we want to use for heading angle.\r\n        // We have to process the angle because the imu works in euler angles so the Z axis is\r\n        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes\r\n        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.\r\n\r\n        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;\r\n\r\n        if (deltaAngle < -180)\r\n            deltaAngle += 360;\r\n        else if (deltaAngle > 180)\r\n            deltaAngle -= 360;\r\n\r\n        globalAngle += deltaAngle;\r\n\r\n        lastAngles = angles;\r\n\r\n        return globalAngle;\r\n    }\r\n\r\n    public double getAbsoluteAngle() {\r\n        // We experimentally determined the Z axis is the axis we want to use for heading angle.\r\n        // We have to process the angle because the imu works in euler angles so the Z axis is\r\n        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes\r\n        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.\r\n\r\n        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;\r\n\r\n        if (deltaAngle < -180)\r\n            deltaAngle += 360;\r\n        else if (deltaAngle > 180)\r\n            deltaAngle -= 360;\r\n\r\n        globalAngle += deltaAngle;\r\n\r\n        lastAngles = angles;\r\n\r\n        return globalAngle;\r\n    }\r\n\r\n\r\n    public void rotate(int degrees, double power) {\r\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\r\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\r\n                degrees, power);\r\n        robot.initMotorNoEncoders();\r\n        // restart imu movement tracking.\r\n        resetAngle();\r\n\r\n        if (degrees < 0) {   // turn right.\r\n            robot.moveHolonomic(0, 0, power * -1);\r\n        } else if (degrees > 0) {   // turn left.\r\n            robot.moveHolonomic(0, 0, power * 1);\r\n        } else return;\r\n\r\n\r\n        // rotate until turn is completed.\r\n        if (degrees < 0) {\r\n            // On right turn we have to get off zero first.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\r\n            }\r\n\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\r\n            }\r\n        } else    // left turn.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\r\n            }\r\n\r\n        // turn the motors off.\r\n        power = 0;\r\n        robot.leftMotor.setPower(power);\r\n        robot.rightMotor.setPower(power);\r\n        robot.backleftMotor.setPower(power);\r\n        robot.backrightMotor.setPower(power);\r\n\r\n        // wait for rotation to stop.\r\n        sleep(50);\r\n\r\n        // reset angle tracking on new heading.\r\n        resetAngle();\r\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\r\n    }\r\n\r\n    public void rotateFrontUsingOneSide(int degrees, double speed) {\r\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\r\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\r\n                degrees, speed);\r\n\r\n        // restart imu movement tracking.\r\n        resetAngle();\r\n\r\n        if (degrees < 0) {   // turn right.\r\n            robot.leftMotor.setPower(0);\r\n            robot.rightMotor.setPower(1 * speed);\r\n            robot.backleftMotor.setPower(0);\r\n            robot.backrightMotor.setPower(1 * speed);\r\n        } else if (degrees > 0) {   // turn left.\r\n            robot.leftMotor.setPower(1 * speed);\r\n            robot.rightMotor.setPower(0);\r\n            robot.backleftMotor.setPower(1 * speed);\r\n            robot.backrightMotor.setPower(0);\r\n        } else return;\r\n\r\n\r\n        // rotate until turn is completed.\r\n        if (degrees < 0) {\r\n            // On right turn we have to get off zero first.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\r\n            }\r\n\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\r\n            }\r\n        } else    // left turn.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\r\n            }\r\n\r\n        // turn the motors off.\r\n        int power = 0;\r\n        robot.leftMotor.setPower(power);\r\n        robot.rightMotor.setPower(power);\r\n        robot.backleftMotor.setPower(power);\r\n        robot.backrightMotor.setPower(power);\r\n\r\n        // wait for rotation to stop.\r\n        sleep(50);\r\n\r\n        // reset angle tracking on new heading.\r\n        resetAngle();\r\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\r\n    }\r\n\r\n    public void rotateUsingOneSide(int degrees, double speed) {\r\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\r\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\r\n                degrees, speed);\r\n\r\n        // restart imu movement tracking.\r\n        resetAngle();\r\n\r\n        if (degrees < 0) {   // turn right.\r\n            robot.leftMotor.setPower(0);\r\n            robot.rightMotor.setPower(-1 * speed);\r\n            robot.backleftMotor.setPower(0);\r\n            robot.backrightMotor.setPower(-1 * speed);\r\n        } else if (degrees > 0) {   // turn left.\r\n            robot.leftMotor.setPower(-1 * speed);\r\n            robot.rightMotor.setPower(0);\r\n            robot.backleftMotor.setPower(-1 * speed);\r\n            robot.backrightMotor.setPower(0);\r\n        } else return;\r\n\r\n\r\n        // rotate until turn is completed.\r\n        if (degrees < 0) {\r\n            // On right turn we have to get off zero first.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\r\n            }\r\n\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\r\n            }\r\n        } else    // left turn.\r\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\r\n            }\r\n\r\n        // turn the motors off.\r\n        int power = 0;\r\n        robot.leftMotor.setPower(power);\r\n        robot.rightMotor.setPower(power);\r\n        robot.backleftMotor.setPower(power);\r\n        robot.backrightMotor.setPower(power);\r\n\r\n        // wait for rotation to stop.\r\n        sleep(50);\r\n\r\n        // reset angle tracking on new heading.\r\n        resetAngle();\r\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\r\n    }\r\n\r\n\r\n    public void myEncoderDrive(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\r\n        int newLeftTarget = 0;\r\n        int newRightTarget = 0;\r\n        int newLeftBackTarget = 0;\r\n        int newRightBackTarget = 0;\r\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderDrive -  speed=%f, Inches=%f, timeout=%f\",\r\n                speed, Inches, timeoutS);\r\n\r\n        robot.leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        robot.rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        robot.backleftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        robot.backrightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        //Reset the encoder\r\n        robot.leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        robot.rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        robot.backrightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        robot.backleftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n        // Ensure that the op mode is still active\r\n        if (opModeIsActive() && !isStopRequested()) {\r\n\r\n            // Determine new target position, and pass to motor controller\r\n            if (direction == Direction.FORWARD) {\r\n                //Go forward\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n            } else if (direction == Direction.BACKWARD) {\r\n                //Go backward\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n            } else if (direction == Direction.STRAFE_RIGHT) {\r\n                //Strafe Right\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n\r\n            } else if (direction == Direction.STRAFE_LEFT) {\r\n                //Strafe Left\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\r\n\r\n            } else if (direction == Direction.DIAGONAL_LEFT) {\r\n                //Left Diagonal\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n\r\n            } else if (direction == Direction.DIAGONAL_RIGHT) {\r\n                //Right Diagonal\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n\r\n            } else {\r\n                Inches = 0;\r\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\r\n            }\r\n\r\n\r\n            robot.leftMotor.setTargetPosition(newLeftTarget);\r\n            robot.rightMotor.setTargetPosition(newRightTarget);\r\n            robot.backleftMotor.setTargetPosition(newLeftBackTarget);\r\n            robot.backrightMotor.setTargetPosition(newRightBackTarget);\r\n\r\n            // Turn On RUN_TO_POSITION\r\n            robot.leftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n            robot.rightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n            robot.backleftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n            robot.backrightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n            // reset the timeout time and start motion.\r\n            runtime.reset();\r\n\r\n            robot.leftMotor.setPower(Math.abs(speed));\r\n            robot.rightMotor.setPower(Math.abs(speed));\r\n            robot.backleftMotor.setPower(Math.abs(speed));\r\n            robot.backrightMotor.setPower(Math.abs(speed));\r\n\r\n            while (opModeIsActive() && !isStopRequested() &&\r\n                    (runtime.seconds() < timeoutS) &&\r\n                    (robot.leftMotor.isBusy())) {\r\n/*\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_LEFT) {\r\n                    if(robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH) <= 7) {\r\n                        robot.stopAllMotors();\r\n\r\n                        telemetry.addData(\"LeftDistSensor\", \"The robot is %7f inches from crashing.\",\r\n                                robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH));\r\n                        telemetry.update();\r\n                        break;\r\n\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_RIGHT) {\r\n                    if(robot.sensorDistanceRight.getDistance(DistanceUnit.INCH) <= 7) {\r\n                        robot.stopAllMotors();\r\n\r\n                        telemetry.addData(\"RightDistSensor\", \"The robot is %7f inches from crashing.\",\r\n                                robot.sensorDistanceRight.getDistance(DistanceUnit.INCH));\r\n                        telemetry.update();\r\n                        break;\r\n\r\n                    }\r\n                }\r\n                if (sensors_2_use == SensorsToUse.USE_COLOR_LEFT) {\r\n\r\n                    if (myDetectSkystone(SideToUse.USE_LEFT, 2) == true)\r\n                    {\r\n                        robot.stopAllMotors();\r\n                        //telemetry.addData(\"LeftColorSensor\", \"The robot detected Skystone\");\r\n                        //telemetry.update();\r\n                        break;\r\n                    }\r\n                }\r\n                if (sensors_2_use == SensorsToUse.USE_COLOR_RIGHT) {\r\n\r\n                    if (myDetectSkystone(SideToUse.USE_RIGHT, 2) == true)\r\n                    {\r\n                        robot.stopAllMotors();\r\n                        //telemetry.addData(\"LeftColorSensor\", \"The robot detected Skystone\");\r\n                        //telemetry.update();\r\n                        break;\r\n                    }\r\n                }\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_RIGHT_BLD) {\r\n                    if(robot.sensorDistanceRight.getDistance(DistanceUnit.INCH) <= 2) {\r\n                        robot.stopAllMotors();\r\n\r\n                        telemetry.addData(\"RightDistSensor\", \"The robot is %7f inches from crashing.\",\r\n                                robot.sensorDistanceRight.getDistance(DistanceUnit.INCH));\r\n                        telemetry.update();\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_LEFT_BLD) {\r\n                    if(robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH) <= 2) {\r\n                        robot.stopAllMotors();\r\n\r\n                        telemetry.addData(\"LeftDistSensor\", \"The robot is %7f inches from crashing.\",\r\n                                robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH));\r\n                        telemetry.update();\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_LEFT_FDT) {\r\n                    if(robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH) > 20) {\r\n                        robot.stopAllMotors();\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_RIGHT_FDT) {\r\n                    if(robot.sensorDistanceRight.getDistance(DistanceUnit.INCH) > 20) {\r\n                        robot.stopAllMotors();\r\n                    }\r\n                }\r\n\r\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_FRONT) {\r\n                    if(robot.sensorDistanceFL.getDistance(DistanceUnit.INCH) <23) {\r\n                        robot.stopAllMotors();\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n\r\n */\r\n        }\r\n\r\n\r\n\r\n                // Stop all motion;\r\n                robot.leftMotor.setPower(0);\r\n                robot.rightMotor.setPower(0);\r\n                robot.backleftMotor.setPower(0);\r\n                robot.backrightMotor.setPower(0);\r\n\r\n                distance_traveled = robot.rightMotor.getCurrentPosition() / COUNTS_PER_INCH;\r\n\r\n                // Turn off RUN_TO_POSITION\r\n                robot.leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n                robot.rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n                robot.backleftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n                robot.backrightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n\r\n                sleep(50);   // optional pause after each move\r\n            }\r\n        }\r\n\r\n\r\n\r\n    /*\r\n    public void myEncoderSlide(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\r\n        int newLeftTarget = 0;\r\n        int newRightTarget = 0;\r\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderSlide -  speed=%f, Inches=%f, timeout=%f\",\r\n                speed, Inches, timeoutS);\r\n\r\n        robot.slide_1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        robot.slide_1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        //robot.slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        //robot.slide_2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n        //Reset the encoder\r\n\r\n        // Ensure that the op mode is still active\r\n        if (opModeIsActive() && !isStopRequested()) {\r\n\r\n            // Determine new target position, and pass to motor controller\r\n            if (direction == Direction.SLIDE_UP) {\r\n                //Go forward\r\n                newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                newRightTarget = robot.slide_2.getCurrentPosition() + (int) (1*Inches * PULLEY_COUNTS_PER_INCH);\r\n\r\n            } else if (direction == Direction.SLIDE_DOWN) {\r\n                //Go backward\r\n                newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (-1 * Inches * PULLEY_COUNTS_PER_INCH);\r\n                newRightTarget = robot.slide_2.getCurrentPosition() + (int) (-1* Inches * PULLEY_COUNTS_PER_INCH);\r\n            } else {\r\n                Inches = 0;\r\n                newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                newRightTarget = robot.slide_2.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n            }\r\n\r\n\r\n            robot.slide_1.setTargetPosition(newLeftTarget);\r\n            robot.slide_2.setTargetPosition(newRightTarget);\r\n\r\n            // Turn On RUN_TO_POSITION\r\n            robot.slide_1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n            robot.slide_2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n            // reset the timeout time and start motion.\r\n            runtime.reset();\r\n\r\n            robot.slide_1.setPower(Math.abs(speed));\r\n            robot.slide_2.setPower(Math.abs(speed));\r\n\r\n            while (opModeIsActive() && !isStopRequested() &&\r\n                    (runtime.seconds() < timeoutS) &&\r\n                    (robot.slide_1.isBusy())) {\r\n\r\n\r\n                // Display it for the driver.\r\n                telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newRightTarget);\r\n                telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\r\n                        robot.slide_1.getCurrentPosition(),\r\n                        robot.slide_2.getCurrentPosition());\r\n                telemetry.update();\r\n            }\r\n        }\r\n\r\n        // Stop all motion;\r\n        robot.slide_1.setPower(0);\r\n        robot.slide_2.setPower(0);\r\n\r\n        // Turn off RUN_TO_POSITION\r\n        robot.slide_1.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        robot.slide_2.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n    }\r\n*/\r\n            public void myWobbleGoal (Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\r\n                int newLeftTarget = 0;\r\n                int newRightTarget = 0;\r\n                RobotLog.ii(\"CAL\", \"Enter - myEncoderSlide -  speed=%f, Inches=%f, timeout=%f\",\r\n                        speed, Inches, timeoutS);\r\n\r\n                //Reset the encoder\r\n                robot.wobbleMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n                robot.wobbleMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n                //robot.slide_2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n                // Ensure that the op mode is still active\r\n                if (opModeIsActive() && !isStopRequested()) {\r\n\r\n                    // Determine new target position, and pass to motor controller\r\n                    if (direction == Direction.SLIDE_UP) {\r\n                        //Go forward\r\n                        newLeftTarget = robot.wobbleMotor.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                        //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (1*Inches * PULLEY_COUNTS_PER_INCH);\r\n\r\n                    } else if (direction == Direction.SLIDE_DOWN) {\r\n                        //Go backward\r\n                        newLeftTarget = robot.wobbleMotor.getCurrentPosition() + (int) (-1 * Inches * PULLEY_COUNTS_PER_INCH);\r\n                        //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (-1* Inches * PULLEY_COUNTS_PER_INCH);\r\n                    } else {\r\n                        Inches = 0;\r\n                        newLeftTarget = robot.wobbleMotor.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                        //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                    }\r\n\r\n\r\n                    robot.wobbleMotor.setTargetPosition(newLeftTarget);\r\n                    //robot.slide_2.setTargetPosition(newRightTarget);\r\n\r\n                    // Turn On RUN_TO_POSITION\r\n                    robot.wobbleMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n                    //robot.slide_2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n                    // reset the timeout time and start motion.\r\n                    runtime.reset();\r\n\r\n                    robot.wobbleMotor.setPower(Math.abs(speed));\r\n                    if (direction == Direction.SLIDE_DOWN) {\r\n                        //robot.slide_2.setPower((-1*speed));\r\n                    } else {\r\n                        //robot.slide_2.setPower((1*speed));\r\n\r\n                    }\r\n\r\n                    while (opModeIsActive() && !isStopRequested() &&\r\n                            (runtime.seconds() < timeoutS) &&\r\n                            (robot.wobbleMotor.isBusy())) {\r\n\r\n\r\n                        // Display it for the driver.\r\n                        telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newRightTarget);\r\n                        telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\r\n                                robot.wobbleMotor.getCurrentPosition(),\r\n                                robot.wobbleMotor.getCurrentPosition());\r\n                        telemetry.update();\r\n                    }\r\n                }\r\n\r\n                // Stop all motion;\r\n                robot.wobbleMotor.setPower(0);\r\n                //robot.slide_2.setPower(0);\r\n\r\n                // Turn off RUN_TO_POSITION\r\n                robot.wobbleMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n                //robot.slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n            }\r\n    /*\r\n        public void myEncoderSlide2(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\r\n            int newLeftTarget = 0;\r\n            int newRightTarget = 0;\r\n            RobotLog.ii(\"CAL\", \"Enter - myEncoderSlide -  speed=%f, Inches=%f, timeout=%f\",\r\n                    speed, Inches, timeoutS);\r\n\r\n            //Reset the encoder\r\n            robot.slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n            //robot.slide_1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n            robot.slide_2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n            // Ensure that the op mode is still active\r\n            if (opModeIsActive() && !isStopRequested()) {\r\n\r\n                // Determine new target position, and pass to motor controller\r\n                if (direction == Direction.SLIDE_UP) {\r\n                    //Go forward\r\n                    //newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                    newRightTarget = robot.slide_2.getCurrentPosition() + (int) (1*Inches * PULLEY_COUNTS_PER_INCH);\r\n\r\n                } else if (direction == Direction.SLIDE_DOWN) {\r\n                    //Go backward\r\n                    //newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (-1 * Inches * PULLEY_COUNTS_PER_INCH);\r\n                    newRightTarget = robot.slide_2.getCurrentPosition() + (int) (-1* Inches * PULLEY_COUNTS_PER_INCH);\r\n                } else {\r\n                    Inches = 0;\r\n                    //newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                    newRightTarget = robot.slide_2.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\r\n                }\r\n\r\n\r\n                //robot.slide_1.setTargetPosition(newLeftTarget);\r\n                robot.slide_2.setTargetPosition(newRightTarget);\r\n\r\n                // Turn On RUN_TO_POSITION\r\n                //robot.slide_1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n                robot.slide_2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n                // reset the timeout time and start motion.\r\n                runtime.reset();\r\n\r\n                robot.slide_2.setPower(Math.abs(speed));\r\n\r\n                while (opModeIsActive() && !isStopRequested() &&\r\n                        (runtime.seconds() < timeoutS) &&\r\n                        (robot.slide_2.isBusy())) {\r\n\r\n\r\n                    // Display it for the driver.\r\n                    telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newRightTarget);\r\n                    telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\r\n                            robot.slide_1.getCurrentPosition(),\r\n                            robot.slide_2.getCurrentPosition());\r\n                    telemetry.update();\r\n                }\r\n            }\r\n\r\n            // Stop all motion;\r\n            //robot.slide_1.setPower(0);\r\n            robot.slide_2.setPower(0);\r\n\r\n            // Turn off RUN_TO_POSITION\r\n            //robot.slide_1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n            robot.slide_2.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        }\r\n\r\n    public void myEncoderInOutSlide(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\r\n        int newLeftTarget = 0;\r\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderInOutSlide -  speed=%f, Inches=%f, timeout=%f\",\r\n                speed, Inches, timeoutS);\r\n\r\n        robot.slide_3.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        robot.slide_3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n        // Ensure that the op mode is still active\r\n        if (opModeIsActive() && !isStopRequested()) {\r\n\r\n            // Determine new target position, and pass to motor controller\r\n            if (direction == Direction.SLIDE_IN) {\r\n                //Go forward\r\n                newLeftTarget = robot.slide_3.getCurrentPosition() + (int) (Inches * INOUT_COUNTS_PER_INCH);\r\n\r\n            } else if (direction == Direction.SLIDE_OUT) {\r\n                //Go backward\r\n                newLeftTarget = robot.slide_3.getCurrentPosition() + (int) (-1 * Inches * INOUT_COUNTS_PER_INCH);\r\n            } else {\r\n                Inches = 0;\r\n                newLeftTarget = robot.slide_3.getCurrentPosition() + (int) (Inches * INOUT_COUNTS_PER_INCH);\r\n            }\r\n\r\n\r\n            robot.slide_3.setTargetPosition(newLeftTarget);\r\n\r\n            // Turn On RUN_TO_POSITION\r\n            robot.slide_3.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n            // reset the timeout time and start motion.\r\n            runtime.reset();\r\n\r\n            robot.slide_3.setPower(Math.abs(speed));\r\n\r\n            while (opModeIsActive() && !isStopRequested() &&\r\n                    (runtime.seconds() < timeoutS) &&\r\n                    (robot.slide_3.isBusy())) {\r\n\r\n\r\n                // Display it for the driver.\r\n                telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newLeftTarget);\r\n                telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\r\n                        robot.slide_3.getCurrentPosition(),\r\n                        robot.slide_3.getCurrentPosition());\r\n                telemetry.update();\r\n            }\r\n        }\r\n\r\n        // Stop all motion;\r\n        robot.slide_3.setPower(0);\r\n\r\n        // Turn off RUN_TO_POSITION\r\n        robot.slide_3.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n    }\r\n\r\n     */\r\n//SONIA AND REESA PLEASE ADD YOUR TENSORFLOW STUFF HERE\r\n            /*\r\n    public void myTFOD(double timeoutS) {\r\n        {\r\n            // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\r\n            // first.\r\n\r\n            boolean strafeDone = false;\r\n            RobotLog.ii(\"CAL\", \"myTFOD - Enter\");\r\n\r\n            while (opModeIsActive() && !isStopRequested()) {\r\n\r\n                if (tfod == null) {\r\n                    robot.moveHolonomic(0, 0, 0);\r\n                    break;\r\n                }\r\n\r\n                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\r\n\r\n                if (updatedRecognitions != null) {\r\n                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\r\n                    // step through the list of recognitions and display boundary info.\r\n                    if (updatedRecognitions.size() == 0) {\r\n                        robot.moveHolonomic(0, 0, 0);\r\n                    } else {\r\n                        int i = 0;\r\n                        for (Recognition recognition : updatedRecognitions) {\r\n                            if (recognition.getLabel().equals(LABEL_SECOND_ELEMENT)) {\r\n                                double targetHeightRatio = (float) 0.8;\r\n                                double imageHeight = recognition.getImageHeight();\r\n                                double imageWidth = recognition.getImageWidth();\r\n                                double objectHeight = recognition.getHeight();\r\n                                double objectHeightRatio = objectHeight / imageHeight;\r\n                                double power = 0.1;\r\n                                double mid = (recognition.getLeft() + recognition.getRight()) / 2;\r\n                                double i_left = recognition.getLeft();\r\n                                double i_right = recognition.getRight();\r\n\r\n                                telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\r\n                                telemetry.addData(\" \", \"Image Width (%.1f), image Height (%.1f), object Height (%.1f)\",\r\n                                        imageWidth, imageHeight, objectHeight);\r\n                                telemetry.addData(String.format(\" init left,right (%d)\", i), \"%.03f , %.03f\",\r\n                                        i_left, i_right);\r\n\r\n                                if (strafeDone == false) {\r\n                                    if (mid < (640 - 100)) {\r\n                                        telemetry.addData(String.format(\" mid(%f) < 540 \", mid), \"\");\r\n                                        robot.moveHolonomic(-1 * power, 0, 0);\r\n                                    } else if (mid > (640 + 100)) {\r\n                                        telemetry.addData(String.format(\" mid(%f) > 740 \", mid), \"\");\r\n                                        robot.moveHolonomic(1 * power, 0, 0);\r\n                                    } else {\r\n                                        strafeDone = true;\r\n                                        robot.moveHolonomic(0, 0, 0);\r\n                                    }\r\n                                }\r\n\r\n                                if (strafeDone == true) {\r\n                                    telemetry.addData(\" \", \" Shank Strafe done\");\r\n\r\n                                    if (objectHeightRatio < targetHeightRatio) {\r\n                                        telemetry.addData(\" \", \" SHANK object < target power=%f\", power);\r\n\r\n                                        robot.moveHolonomic(0, 1 * power, 0);\r\n                                    } else {\r\n                                        robot.moveHolonomic(0, 0, 0);\r\n                                    }\r\n                                }\r\n\r\n                            } else {\r\n                                telemetry.addData(\"Not a skystone\", \" \");\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                    telemetry.update();\r\n                }\r\n\r\n                //RobotLog.ii(\"CAL\", \"while opModeIsActive and !isStopRequested - Enter\");\r\n            }\r\n            RobotLog.ii(\"CAL\", \"Exit if opModeIsActive\");\r\n\r\n            if (tfod != null) {\r\n                tfod.shutdown();\r\n            }\r\n            RobotLog.ii(\"CAL\", \"myTFOD - Exits\");\r\n\r\n        }\r\n    }\r\n\r\n             */\r\n            //SONIA AND REESA PLEASE DELETE THIS IF YOU DON'T NEED IT\r\n            /*\r\n    public boolean myTFOD2(double timeoutS) {\r\n        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\r\n        // first.\r\n        boolean strafeDone = false;\r\n        RobotLog.ii(\"CAL\", \"myTFOD - Enter\");\r\n\r\n\r\n        while (opModeIsActive() && !isStopRequested()) {\r\n\r\n            if (tfod == null) {\r\n                robot.moveHolonomic(0, 0, 0);\r\n                break;\r\n            }\r\n\r\n            List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\r\n\r\n            if (updatedRecognitions != null) {\r\n                telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\r\n                // step through the list of recognitions and display boundary info.\r\n                if (updatedRecognitions.size() == 0) {\r\n                    robot.moveHolonomic(0, 0, 0);\r\n                } else {\r\n                    int i = 0;\r\n                    for (Recognition recognition : updatedRecognitions) {\r\n                        if (recognition.getLabel().equals(LABEL_SECOND_ELEMENT)) {\r\n                            return true;\r\n                        } else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n                telemetry.update();\r\n                RobotLog.ii(\"CAL\", \"Exit if opModeIsActive\");\r\n\r\n                if (tfod != null) {\r\n                    tfod.shutdown();\r\n                }\r\n                RobotLog.ii(\"CAL\", \"myTFOD - Exits\");\r\n\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public void moveFoundationServoDown () {\r\n        // Checks if the servos are = null or not because that is what causes the\r\n        // \"null pointer exception\". Once it is checked, the servos will run.\r\n        robot.moveFoundationServoDown();\r\n        /*\r\n        if (robot.FLServo != null) {\r\n            robot.FLServo.setPosition(0.21);\r\n        }\r\n        if (robot.FRServo != null) {\r\n            robot.FRServo.setPosition(0.21);\r\n        }\r\n         */\r\n        }\r\n    \r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/testBotAutonomousBase.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/testBotAutonomousBase.java	(date 1609715855837)
@@ -960,4 +960,4 @@
         }
          */
         }
-    
+
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/AssetsTrajectoryManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.util;\n\nimport androidx.annotation.Nullable;\n\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\nimport com.acmerobotics.roadrunner.trajectory.config.TrajectoryConfig;\nimport com.acmerobotics.roadrunner.trajectory.config.TrajectoryConfigManager;\nimport com.acmerobotics.roadrunner.trajectory.config.TrajectoryGroupConfig;\n\nimport org.firstinspires.ftc.robotcore.internal.system.AppUtil;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Set of utilities for loading trajectories from assets (the plugin save location).\n */\npublic class AssetsTrajectoryManager {\n\n    /**\n     * Loads the group config.\n     */\n    public static @Nullable\n    TrajectoryGroupConfig loadGroupConfig() {\n        try {\n            InputStream inputStream = AppUtil.getDefContext().getAssets().open(\n                    \"trajectory/\" + TrajectoryConfigManager.GROUP_FILENAME);\n            return TrajectoryConfigManager.loadGroupConfig(inputStream);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Loads a trajectory config with the given name.\n     */\n    public static @Nullable TrajectoryConfig loadConfig(String name) {\n        try {\n            InputStream inputStream = AppUtil.getDefContext().getAssets().open(\n                    \"trajectory/\" + name + \".yaml\");\n            return TrajectoryConfigManager.loadConfig(inputStream);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Loads a trajectory builder with the given name.\n     */\n    public static @Nullable TrajectoryBuilder loadBuilder(String name) {\n        TrajectoryGroupConfig groupConfig = loadGroupConfig();\n        TrajectoryConfig config = loadConfig(name);\n        if (groupConfig == null || config == null) {\n            return null;\n        }\n        return config.toTrajectoryBuilder(groupConfig);\n    }\n\n    /**\n     * Loads a trajectory with the given name.\n     */\n    public static @Nullable Trajectory load(String name) {\n        TrajectoryBuilder builder = loadBuilder(name);\n        if (builder == null) {\n            return null;\n        }\n        return builder.build();\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/AssetsTrajectoryManager.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/util/AssetsTrajectoryManager.java	(date 1609716235719)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.util;
+package org.firstinspires.ftc.teamcode.TestPrograms.util;
 
 import androidx.annotation.Nullable;
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/AxesSigns.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.util;\n\n/**\n * IMU axes signs in the order XYZ (after remapping).\n */\npublic enum AxesSigns {\n    PPP(0b000),\n    PPN(0b001),\n    PNP(0b010),\n    PNN(0b011),\n    NPP(0b100),\n    NPN(0b101),\n    NNP(0b110),\n    NNN(0b111);\n\n    public final int bVal;\n\n    AxesSigns(int bVal) {\n        this.bVal = bVal;\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/AxesSigns.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/util/AxesSigns.java	(date 1609716235486)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.util;
+package org.firstinspires.ftc.teamcode.TestPrograms.util;
 
 /**
  * IMU axes signs in the order XYZ (after remapping).
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/remote1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestBot;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.geometry.Vector2d;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\nimport java.util.List;\n\n    @Autonomous(group = \"drive\")\n    public class remote1 extends testBotAutonomousBase {\n        @Override\n\n        public void runOpMode() throws InterruptedException {\n            SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n            Pose2d startPose = new Pose2d(-60, -24, Math.toRadians(90));\n            drive.setPoseEstimate(startPose);\n\n\n            waitForStart();\n            int position = 0;\n\n            if (isStopRequested()) return;\n\n\n            Trajectory traj1 = drive.trajectoryBuilder(startPose)\n                    .splineTo(new Vector2d(-24, -34), Math.toRadians(0))\n                    .build();\n            drive.followTrajectory(traj1);\n\n\n            if (position == 0) {\n                Trajectory traj2 = drive.trajectoryBuilder(traj1.end())\n                        .splineTo(new Vector2d(-6, -36), Math.toRadians(90))\n                        .build();\n                drive.followTrajectory(traj2);\n            } else if (position == 1) {\n                Trajectory traj2 = drive.trajectoryBuilder(traj1.end())\n                        .splineTo(new Vector2d(24, -12), Math.toRadians(90))\n                        .build();\n                drive.followTrajectory(traj2);\n            } else if (position == 4) {\n                Trajectory traj2 = drive.trajectoryBuilder(traj1.end())\n                       .splineTo(new Vector2d(48, -42), Math.toRadians(45))\n                     .build();\n            }\n            //traj3 in position to shoot rings into the upper target, and then return to get wobble\n            Trajectory traj3 = drive.trajectoryBuilder(traj1.end())\n                    .splineTo(new Vector2d(9, 22), Math.toRadians(202))\n                    .build();\n            drive.followTrajectory(traj3);\n\n\n            Trajectory traj4 = drive.trajectoryBuilder(traj3.end())\n                    .splineTo(new Vector2d(-30, -4), Math.toRadians(-90))\n                    .build();\n            drive.followTrajectory(traj4);\n\n        }\n\n    }\n\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/remote1.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestBot/autoRemote.java	(date 1610326196734)
@@ -3,15 +3,11 @@
 import com.acmerobotics.roadrunner.geometry.Vector2d;
 import com.acmerobotics.roadrunner.trajectory.Trajectory;
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
-import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
-import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
-
-import java.util.List;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
-    @Autonomous(group = "drive")
-    public class remote1 extends testBotAutonomousBase {
+@Autonomous(group = "drive")
+    public class autoRemote extends testBotAutonomousBase {
         @Override
 
         public void runOpMode() throws InterruptedException {
@@ -49,7 +45,7 @@
             }
             //traj3 in position to shoot rings into the upper target, and then return to get wobble
             Trajectory traj3 = drive.trajectoryBuilder(traj1.end())
-                    .splineTo(new Vector2d(9, 22), Math.toRadians(202))
+                    .splineTo(new Vector2d(9, -22), Math.toRadians(202))
                     .build();
             drive.followTrajectory(traj3);
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/esharrpathways.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.geometry.Vector2d;\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\n\n/*\n * This is an example of a more complex path to really test the tuning.eiihcckgbrrrllbrrllkcjjnnlerlfvtunggvvfcnhci\n *\n */\n@Autonomous(group = \"drive\")\npublic class esharrpathways extends LinearOpMode {\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n        Pose2d startPose = new Pose2d(-60, -24, Math.toRadians(0));\n        drive.setPoseEstimate(startPose);\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n\n        /*Trajectory traj1 = drive.trajectoryBuilder(startPose)\n                .splineToLinearHeading(new Pose2d(20, 0, Math.toRadians(90)), Math.toRadians(0))\n                .build();\n        Trajectory traj2 = drive.trajectoryBuilder(traj1.end())\n                .splineToLinearHeading(new Pose2d(0, -20, Math.toRadians(0)), Math.toRadians(90))\n                .build();\n\n        drive.followTrajectory(traj1);\n        drive.followTrajectory(traj2); */\n\n        // goes to (20,0) then (0,-20) medium speed\n\n        //Trajectory traj1 = drive.trajectoryBuilder(new Pose2d())\n                //.lineToSplineHeading(new Pose2d(20, 0, Math.toRadians(90)))\n                //.build();\n\n       Trajectory traj1 = drive.trajectoryBuilder(startPose)\n                .splineToConstantHeading(new Vector2d(20, 0), Math.toRadians(0))\n                .build();\n        Trajectory traj2 = drive.trajectoryBuilder(traj1.end())\n                .splineToConstantHeading(new Vector2d(0, -20), Math.toRadians(0))\n                .build();\n        drive.followTrajectory(traj1);\n        drive.followTrajectory(traj2);\n//faster, less accurate, could use in simple autonomous with wobble goal\n        Trajectory traj3 = drive.trajectoryBuilder(traj2.end())\n                .splineTo(new Vector2d(20, 0), 0)\n                .build();\n        Trajectory traj4 = drive.trajectoryBuilder(traj3.end())\n                .splineTo(new Vector2d(0, -20), Math.toRadians(180))\n                .build();\n        drive.followTrajectory(traj3);\n        drive.followTrajectory(traj4);\n        /*Trajectory traj5 = drive.trajectoryBuilder(traj4.end())\n                .back(10)\n                .build();\n        drive.followTrajectory(traj5);*/\n        //turns too much, slower\n\n\n        /*Trajectory traj2 = drive.trajectoryBuilder(traj1.end())\n                .splineToLinearHeading(new Pose2d(0, -10), Math.toRadians(90)), Math.toRadians(0))\n                .build();\n        drive.followTrajectory(traj1);\n        drive.followTrajectory(traj2); */\n        /*\n        Trajectory traj2 = drive.trajectoryBuilder(traj1.end())\n                .splineToLinearHeading(neweiihcckgbrrrilbbievnvjevkgvgvejvkclfhbruufkb\n                 Pose2d(-35, -5, Math.toRadians(180))\n                .build();\n        Trajectory traj3 = drive.trajectoryBuilder(traj2.end())\n                .splineTo(new Vector2d(0, -26), 0)\n                .build();\n        Trajectory traj4 = drive.trajectoryBuilder(traj3.end())\n                .splineTo(new Vector2d(-20, -12), Math.toRadians(180))\n                .build();\n        drive.followTrajectory(traj1);\n        sleep(300);\n        drive.followTrajectory(traj2);\n        sleep(300);\n        drive.followTrajectory(traj3);\n        sleep(300);\n        drive.followTrajectory(traj4);\n        sleep(300);\n        // sleep(5000);\n\n        drive.followTrajectory(\n                drive.trajectoryBuilder(traj4.end(), false)\n                        .splineTo(new Vector2d(0, -12), Math.toRadians(0))\n                        .build()\n        );\n*/\n        //drive.followTrajectory(traj1);\n        //sleep(300);\n    }\n\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/esharrpathways.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/esharrpathways.java	(date 1609716235679)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.roadrunner.geometry.Pose2d;
 import com.acmerobotics.roadrunner.geometry.Vector2d;
@@ -6,7 +6,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
 
 /*
  * This is an example of a more complex path to really test the tuning.eiihcckgbrrrllbrrllkcjjnnlerlfvtunggvvfcnhci
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/OdometryCalibration.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\nimport com.qualcomm.robotcore.util.ElapsedTime;\nimport com.qualcomm.robotcore.util.ReadWriteFile;\n\nimport org.firstinspires.ftc.robotcore.internal.system.AppUtil;\n\nimport java.io.File;\n\n/**\n * Created by Sarthak on 6/1/2019.\n * Odometry system calibration. Run this OpMode to generate the necessary constants to calculate the robot's global position on the field.\n * The Global Positioning Algorithm will not function and will throw an error if this program is not run first\n */\n@TeleOp(name = \"Odometry System Calibration\", group = \"Calibration\")\npublic class OdometryCalibration extends LinearOpMode {\n    //Drive motors\n    DcMotor right_front, right_back, left_front, left_back;\n    //Odometry Wheels\n    DcMotor verticalLeft, verticalRight, horizontal;\n\n    //IMU Sensor\n    BNO055IMU imu;\n\n    //Hardware Map Names for drive motors and odometry wheels. THIS WILL CHANGE ON EACH ROBOT, YOU NEED TO UPDATE THESE VALUES ACCORDINGLY\n    String lfName = \"M1\";\n    String rfName = \"M2\";\n    String lbName = \"M3\";\n    String rbName = \"M4\";\n\n    String verticalLeftEncoderName = lfName;\n    String verticalRightEncoderName = rfName;\n    String horizontalEncoderName = lbName;\n\n    final double PIVOT_SPEED = 0.4;\n\n    //The amount of encoder ticks for each inch the robot moves. THIS WILL CHANGE FOR EACH ROBOT AND NEEDS TO BE UPDATED HERE\n    final double COUNTS_PER_INCH = 307.699557;\n\n\n    ElapsedTime timer = new ElapsedTime();\n\n    double horizontalTickOffset = 0;\n\n    //Text files to write the values to. The files are stored in the robot controller under Internal Storage\\FIRST\\settings\n    File wheelBaseSeparationFile = AppUtil.getInstance().getSettingsFile(\"wheelBaseSeparation.txt\");\n    File horizontalTickOffsetFile = AppUtil.getInstance().getSettingsFile(\"horizontalTickOffset.txt\");\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n\n        waitForStart();\n\n        //Begin calibration (if robot is unable to pivot at these speeds, please adjust the constant at the top of the code\n\n        while(getZAngle() < 90 && opModeIsActive()){\n\n            setPowerAll(PIVOT_SPEED, PIVOT_SPEED, PIVOT_SPEED, PIVOT_SPEED);\n/*\n            right_front.setPower(-PIVOT_SPEED);\n            right_back.setPower(-PIVOT_SPEED);\n            left_front.setPower(PIVOT_SPEED);\n            left_back.setPower(PIVOT_SPEED);\n\n            setPowerAll(-PIVOT_SPEED, -PIVOT_SPEED, PIVOT_SPEED, PIVOT_SPEED);\n            if(getZAngle() < 60) {\n                setPowerAll(-PIVOT_SPEED, -PIVOT_SPEED, PIVOT_SPEED, PIVOT_SPEED);\n            }else{\n                setPowerAll(-PIVOT_SPEED/2, -PIVOT_SPEED/2, PIVOT_SPEED/2, PIVOT_SPEED/2);\n            }*/\n\n            telemetry.addData(\"IMU Angle\", getZAngle());\n            telemetry.update();\n        }\n\n        //Stop the robot\n        setPowerAll(0, 0, 0, 0);\n        timer.reset();\n        while(timer.milliseconds() < 3000 && opModeIsActive()){\n            telemetry.addData(\"IMU Angle\", getZAngle());\n            telemetry.update();\n        }\n\n        //Record IMU and encoder values to calculate the constants for the global position algorithm\n        double angle = getZAngle();\n\n        /*\n        Encoder Difference is calculated by the formula (leftEncoder - rightEncoder)\n        Since the left encoder is also mapped to a drive motor, the encoder value needs to be reversed with the negative sign in front\n        THIS MAY NEED TO BE CHANGED FOR EACH ROBOT\n       */\n        double encoderDifference = Math.abs(verticalLeft.getCurrentPosition()) + (Math.abs(verticalRight.getCurrentPosition()));\n\n        double verticalEncoderTickOffsetPerDegree = encoderDifference/angle;\n\n        double wheelBaseSeparation = (2*90*verticalEncoderTickOffsetPerDegree)/(Math.PI*COUNTS_PER_INCH);\n\n        horizontalTickOffset = horizontal.getCurrentPosition()/Math.toRadians(getZAngle());\n\n        //Write the constants to text files\n        ReadWriteFile.writeFile(wheelBaseSeparationFile, String.valueOf(wheelBaseSeparation));\n        ReadWriteFile.writeFile(horizontalTickOffsetFile, String.valueOf(horizontalTickOffset));\n\n        while(opModeIsActive()){\n            telemetry.addData(\"Odometry System Calibration Status\", \"Calibration Complete\");\n            //Display calculated constants\n            telemetry.addData(\"Wheel Base Separation\", wheelBaseSeparation);\n            telemetry.addData(\"Horizontal Encoder Offset\", horizontalTickOffset);\n\n//Display raw values\n            telemetry.addData(\"IMU Angle\", getZAngle());\n            telemetry.addData(\"Vertical Left Position\", verticalLeft.getCurrentPosition());\n            telemetry.addData(\"Vertical Right Position\", verticalRight.getCurrentPosition());\n            telemetry.addData(\"Horizontal Position\", horizontal.getCurrentPosition());\n            telemetry.addData(\"Vertical Encoder Offset\", verticalEncoderTickOffsetPerDegree);\n\n            //Update values\n            telemetry.update();\n        }\n    }\n\n    private void initHardwareMap(String rfName, String rbName, String lfName, String lbName, String vlEncoderName, String vrEncoderName, String hEncoderName){\n        right_front = hardwareMap.dcMotor.get(rfName);\n        right_back = hardwareMap.dcMotor.get(rbName);\n        left_front = hardwareMap.dcMotor.get(lfName);\n        left_back = hardwareMap.dcMotor.get(lbName);\n\n        verticalLeft = hardwareMap.dcMotor.get(vlEncoderName);\n        verticalRight = hardwareMap.dcMotor.get(vrEncoderName);\n        horizontal = hardwareMap.dcMotor.get(hEncoderName);\n\n        right_front.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        right_back.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        left_front.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        left_back.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        right_front.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        right_back.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        left_front.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        left_back.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        right_front.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        right_back.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        left_front.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        left_back.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        //right_back.setDirection(DcMotorSimple.Direction.REVERSE);\n        left_back.setDirection(DcMotorSimple.Direction.REVERSE);\n        right_back.setDirection(DcMotorSimple.Direction.REVERSE);\n\n        verticalRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        verticalLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        horizontal.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        //Reset the encoders\n        verticalRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        verticalLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        horizontal.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        //verticalLeft.setDirection(DcMotorSimple.Direction.REVERSE);\n        //horizontal.setDirection(DcMotorSimple.Direction.REVERSE);\n\n        verticalRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        verticalLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        horizontal.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n\n        telemetry.addData(\"Status\", \"Hardware Map Init Complete\");\n        telemetry.update();\n\n    }\n\n    /**\n     * Gets the orientation of the robot using the REV IMU\n     * @return the angle of the robot\n     */\n    private double getZAngle(){\n        return (-imu.getAngularOrientation().firstAngle);\n    }\n\n    /**\n     * Sets power to all four drive motors\n     * @param rf power for right front motor\n     * @param rb power for right back motor\n     * @param lf power for left front motor\n     * @param lb power for left back motor\n     */\n    private void setPowerAll(double rf, double rb, double lf, double lb){\n        right_front.setPower(rf);\n        right_back.setPower(rb);\n        left_front.setPower(lf);\n        left_back.setPower(lb);\n    }\n\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/OdometryCalibration.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/OdometryCalibration.java	(date 1609716235474)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode;
+package org.firstinspires.ftc.teamcode.TestPrograms;
 
 import com.qualcomm.hardware.bosch.BNO055IMU;
 import com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/GlobalCoordinatePositionUpdateSample.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.Samples;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\n\nimport org.firstinspires.ftc.teamcode.TestBot.OdometryGlobalCoordinatePosition;\n\n/**\n * Created by Sarthak on 6/1/2019.\n * Example OpMode that runs the GlobalCoordinatePosition thread and accesses the (x, y, theta) coordinate values\n */\n@TeleOp(name = \"Global Coordinate Position Test\", group = \"Calibration\")\npublic class GlobalCoordinatePositionUpdateSample extends LinearOpMode {\n\n    //Odometry encoder wheels\n     DcMotor verticalRight, verticalLeft, horizontal;\n\n    //The amount of encoder ticks for each inch the robot moves. This will change for each robot and needs to be changed here\n    //The amount of encoder ticks for each inch the robot moves. THIS WILL CHANGE FOR EACH ROBOT AND NEEDS TO BE UPDATED HERE\n    //final double COUNTS_PER_INCH = 307.699557;\n    final double COUNTS_PER_MOTOR_REV  = 360;\n    final double WHEEL_DIAMETER_INCHES = 1.49606;\n    final double COUNTS_PER_INCH       = (COUNTS_PER_MOTOR_REV ) / (WHEEL_DIAMETER_INCHES * 3.1415);\n\n    //Hardware map names for the encoder wheels. Again, these will change for each robot and need to be updated below\n    //Hardware Map Names for drive motors and odometry wheels. THIS WILL CHANGE ON EACH ROBOT, YOU NEED TO UPDATE THESE VALUES ACCORDINGLY\n    String rfName = \"M2\", rbName = \"M4\", lfName = \"M1\", lbName = \"M3\";\n    String verticalLeftEncoderName = lfName, verticalRightEncoderName = rfName, horizontalEncoderName = rbName;\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n\n        //Assign the hardware map to the odometry wheels\n        verticalLeft = hardwareMap.dcMotor.get(verticalLeftEncoderName);\n        verticalRight = hardwareMap.dcMotor.get(verticalRightEncoderName);\n        horizontal = hardwareMap.dcMotor.get(horizontalEncoderName);\n\n        verticalRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        verticalLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        horizontal.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        //Reset the encoders\n        verticalRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        verticalLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        horizontal.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        /*\n        Reverse the direction of the odometry wheels. THIS WILL CHANGE FOR EACH ROBOT. Adjust the direction (as needed) of each encoder wheel\n        such that when the verticalLeft and verticalRight encoders spin forward, they return positive values, and when the\n        horizontal encoder travels to the right, it returns positive value\n        */\n        verticalLeft.setDirection(DcMotorSimple.Direction.REVERSE);\n        //verticalRight.setDirection(DcMotorSimple.Direction.REVERSE);\n        horizontal.setDirection(DcMotorSimple.Direction.REVERSE);\n\n        //Set the mode of the odometry encoders to RUN_WITHOUT_ENCODER\n        //verticalRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        //verticalLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        //horizontal.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        //Init complete\n        telemetry.addData(\"Status\", \"Init Complete\");\n        telemetry.update();\n        waitForStart();\n\n        /**\n         * *****************\n         * OpMode Begins Here\n         * *****************\n         */\n\n        //Create and start GlobalCoordinatePosition thread to constantly update the global coordinate positions\\\n        OdometryGlobalCoordinatePosition globalPositionUpdate = new OdometryGlobalCoordinatePosition(verticalLeft, verticalRight, horizontal, COUNTS_PER_INCH, 75);\n        Thread positionThread = new Thread(globalPositionUpdate);\n        positionThread.start();\n\n        while(opModeIsActive()){\n            //Display Global (x, y, theta) coordinates\n            telemetry.addData(\"X Position\", globalPositionUpdate.returnXCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Y Position\", globalPositionUpdate.returnYCoordinate() / COUNTS_PER_INCH);\n\n            telemetry.addData(\"left Position\", globalPositionUpdate.verticalEncoderLeft.getCurrentPosition() );\n            telemetry.addData(\"Right Position\", globalPositionUpdate.verticalEncoderRight.getCurrentPosition() );\n            telemetry.addData(\"Hori Position\", globalPositionUpdate.horizontalEncoder.getCurrentPosition());\n\n            telemetry.addData(\"Orientation (Degrees)\", globalPositionUpdate.returnOrientation());\n            telemetry.addData(\"Thread Active\", positionThread.isAlive());\n            telemetry.update();\n        }\n\n        //Stop the thread\n        globalPositionUpdate.stop();\n    }\n}
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/GlobalCoordinatePositionUpdateSample.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/util/GlobalCoordinatePositionUpdateSample.java	(date 1609716235457)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.Samples;
+package org.firstinspires.ftc.teamcode.TestPrograms.util;
 
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Shank_odometry.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\n\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\nimport org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\nimport org.firstinspires.ftc.robotcore.external.matrices.VectorF;\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;\nimport static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;\nimport static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;\nimport static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;\nimport static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;\n\n\n@TeleOp(name=\"SHANK Odometry\", group =\"Concept\")\n//@Disabled\npublic class Shank_odometry extends LinearOpMode {\n\n    public DcMotor m1 = null;\n    //public HardwareMap ahwMap = null; // will be set in OpModeManager.runActiveOpMode\n\n    @Override public void runOpMode() {\n        double curr_pos=0;\n        m1= hardwareMap.get(DcMotor.class, \"M1\");\n        m1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        m1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        while (!isStopRequested()) {\n            curr_pos = m1.getCurrentPosition();\n            telemetry.addData(\"SHANK\", \"{curr_pos} = %.0f\", curr_pos);\n            telemetry.update();\n        }\n\n    }\n}\n\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Shank_odometry.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/Shank_odometry.java	(date 1609716235530)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode;
+package org.firstinspires.ftc.teamcode.TestPrograms;
 
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISHW.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.robotcore.hardware.CRServo;\n\nimport com.qualcomm.robotcore.hardware.ColorSensor;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\nimport com.qualcomm.robotcore.hardware.DigitalChannel;\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.hardware.TouchSensor;\nimport com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;\nimport com.qualcomm.robotcore.util.Range;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n\n\npublic class JARVISHW\n{\n    public DcMotor leftMotor = null;\n    public DcMotor rightMotor = null;\n    public DcMotor backrightMotor = null;\n    public DcMotor backleftMotor = null;\n\n    public DcMotor slide_1 = null;\n    //public DcMotor slide_2 = null;\n    public DcMotor slide_3 = null;\n    public Servo capServo = null;\n    public Servo clawServo = null;\n\n    public Servo FLServo = null;\n    public Servo FRServo = null;\n\n\n    public CRServo  tapeServo = null;\n    //public Servo CollectRightServo = null;\n    public DcMotor CollectLeftMotor = null;\n    public DcMotor CollectRightMotor = null;\n\n    public Servo GrabberLeftTurnServo = null;\n    public Servo GrabberLeftClawServo = null;\n    public Servo GrabberRightTurnServo = null;\n    public Servo GrabberRightClawServo = null;\n\n\n    //public CRServo VexServo = null;\n\n    public DistanceSensor sensorDistanceRight = null;\n    public DistanceSensor sensorDistanceLeft = null;\n    public DistanceSensor sensorDistanceFL = null;\n    // public ColorSensor sensorColor = null;\n    public ColorSensor sensorColorLeft = null;\n    public ColorSensor sensorColorRight = null;\n    public TouchSensor touch_sensor = null;\n\n    public BNO055IMU imu = null;\n\n    Orientation lastAngles = new Orientation();  //?\n    double globalAngle, power = .40, correction;  //?\n\n    //sets the power used in each of the actions\n\n    /* Initialize standard Hardware interfaces */\n    public void init(HardwareMap ahwMap) {\n        RobotLog.ii(\"CAL\", \"Enter - init\");\n\n        leftMotor = ahwMap.get(DcMotor.class, \"M1\");\n        rightMotor = ahwMap.get(DcMotor.class, \"M2\");\n        backleftMotor = ahwMap.get(DcMotor.class, \"M3\");\n        backrightMotor = ahwMap.get(DcMotor.class, \"M4\");\n\n\n        slide_1  = ahwMap.get(DcMotor.class, \"slide_1\");\n        //slide_2  = ahwMap.get(DcMotor.class, \"slide_2\");\n        slide_3 = ahwMap.get(DcMotor.class, \"slide_3\");\n\n        capServo = ahwMap.get(Servo.class, \"capServo\");\n        clawServo = ahwMap.get(Servo.class, \"clawServo\");\n\n\n        FLServo = ahwMap.get(Servo.class, \"FLServo\");\n        FRServo = ahwMap.get(Servo.class, \"FRServo\");\n\n        tapeServo = ahwMap.get(CRServo.class, \"tapeServo\");\n        //CollectRightServo = ahwMap.get(Servo.class, \"CollectRightServo\");\n        //VexServo = ahwMap.get(CRServo.class, \"vex\");\n\n        CollectLeftMotor = ahwMap.get(DcMotor.class, \"CollectLeftMotor\");\n        CollectRightMotor = ahwMap.get(DcMotor.class, \"CollectRightMotor\");\n\n        GrabberLeftTurnServo = ahwMap.get(Servo.class, \"GrabberLeftTurnServo\");\n        GrabberLeftClawServo = ahwMap.get(Servo.class, \"GrabberLeftClawServo\");\n\n        GrabberRightTurnServo = ahwMap.get(Servo.class, \"GrabberRightTurnServo\");\n        GrabberRightClawServo = ahwMap.get(Servo.class, \"GrabberRightClawServo\");\n\n        sensorColorLeft = ahwMap.get(ColorSensor.class, \"sensor_color_left\");\n        sensorColorRight = ahwMap.get(ColorSensor.class, \"sensor_color_right\");\n\n        sensorDistanceLeft = ahwMap.get(DistanceSensor.class, \"sensorDistanceLeft\");\n        sensorDistanceRight = ahwMap.get(DistanceSensor.class, \"sensorDistanceRight\");\n        sensorDistanceFL = ahwMap.get(DistanceSensor.class, \"sensorDistanceFL\");\n\n        touch_sensor = ahwMap.get(TouchSensor.class, \"touch_sensor\");\n\n        //markerServo = ahwMap.get(Servo.class, \"MServo\");\n\n        imu = ahwMap.get(BNO055IMU.class, \"imu 1\");\n\n        //initialize the IMU\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n        parameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n        parameters.calibrationDataFile = \"BNO055IMUCalibration.json\"; // see the calibration sample opmode\n        parameters.loggingEnabled = true;\n        parameters.loggingTag = \"IMU\";\n        imu.initialize(parameters);\n\n        //Invert direction for left motors\n        leftMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n        backleftMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n        //slide_1.setDirection(DcMotorSimple.Direction.REVERSE);\n        //slide_2.setDirection(DcMotorSimple.Direction.REVERSE);\n        slide_3.setDirection(DcMotorSimple.Direction.REVERSE);\n        FLServo.setDirection(Servo.Direction.REVERSE);\n        GrabberRightTurnServo.setDirection(Servo.Direction.REVERSE);\n        GrabberRightClawServo.setDirection(Servo.Direction.REVERSE);\n        tapeServo.setDirection(CRServo.Direction.REVERSE);\n        CollectRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n\n        // Set all motors to zero power\n        stopAllMotors();\n\n        //Set zero power behavior to braking\n        leftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        rightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        backrightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        backleftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        slide_1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        //slide_2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        slide_3.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        rotateClawInline();\n        openClaw();\n\n        setGrabberUp(0);\n        setGrabberUp(1);\n\n        closeGrabberClaw(0);\n        closeGrabberClaw(1);\n\n        RobotLog.ii(\"CAL\", \"Exit - init\");\n\n    }\n\n    //resets the power to zero before starting the action\n    public void stopAllMotors() {\n        RobotLog.ii(\"CAL\", \"Stopping All motors\");\n        leftMotor.setPower(0);\n        rightMotor.setPower(0);\n        backleftMotor.setPower(0);\n        backrightMotor.setPower(0);\n        slide_1.setPower(0);\n        //slide_2.setPower(0);\n        slide_3.setPower(0);\n        measureTapeStop();\n    }\n\n    public void initMotorNoEncoders() {\n        RobotLog.ii(\"CAL\", \"Enter -  initMotorNoEncoders\");\n\n        // Sets the mode of the motors to run without encoders\n        leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        backleftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        backrightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        slide_1.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        //slide_2.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        slide_3.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        RobotLog.ii(\"CAL\", \"Exit -  initMotorNoEncoders\");\n    }\n\n\n    public void initMotorEncoders() {\n        RobotLog.ii(\"CAL\", \"Enter -  initMotorEncoders\");\n\n        // Sets the mode of the motors to run WITH encoders\n        leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        backleftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        backrightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        backrightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        backleftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        slide_1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        slide_1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        //slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        //slide_2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        slide_3.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        slide_3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n\n        RobotLog.ii(\"CAL\", \"Exit -  initMotorEncoders\");\n    }\n\n\n\n    public void moveHolonomic(double x, double y , double z)\n    {\n        double max_power = 0.6;\n        double min_power = -1*max_power;\n\n        double fl_power = Range.clip(y + x - z, min_power, max_power);\n        double fr_power = Range.clip(y - x + z, min_power, max_power);\n        double br_power = Range.clip(y + x + z, min_power, max_power);\n        double bl_power = Range.clip(y - x - z, min_power, max_power);\n        RobotLog.ii(\"CAL\", \"moveHolonomic - Enter x(%f), y(%f), z(%f)\", x, y, z);\n        RobotLog.ii(\"CAL\", \"moveHolonomic - Enter fl(%f), fr(%f), bl(%f), br(%f)\", fl_power,fr_power, bl_power, br_power );\n\n        // Sets the power of the motors to the power defined above\n        leftMotor.setPower(fl_power);\n        rightMotor.setPower(fr_power);\n        backleftMotor.setPower(bl_power);\n        backrightMotor.setPower(br_power);\n\n        RobotLog.ii(\"CAL\", \"moveHolonomic - Exit \");\n\n    }\n\n    //extra motions to move slowly go in case we are in a situation like that\n    public void forwardSlow() {\n        leftMotor.setPower(Range.clip(leftMotor.getPower() + 0.01, 0.3, 1.0));\n        rightMotor.setPower(Range.clip(rightMotor.getPower() + 0.01, 0.3, 1.0));\n        backleftMotor.setPower(Range.clip(backleftMotor.getPower() + 0.01, 0.3, 1.0));\n        backrightMotor.setPower(Range.clip(backrightMotor.getPower() + 0.01, 0.3, 1.0));\n    }\n\n    public void backwardSlow() {\n        leftMotor.setPower(Range.clip(leftMotor.getPower() - 0.01, -0.3, -1.0));\n        rightMotor.setPower(Range.clip(rightMotor.getPower() - 0.01, -0.3, -1.0));\n        backleftMotor.setPower(Range.clip(backleftMotor.getPower() - 0.01, -0.3, -1.0));\n        backrightMotor.setPower(Range.clip(backrightMotor.getPower() - 0.01, -0.3, -1.0));\n    }\n\n    // All of the functions that move the motors and servos are below\n    public void slidesUp(double power)\n    {\n        slide_1.setPower(power);\n        //slide_2.setPower(power);\n    }\n\n    public void slidesDown(double power)\n    {\n        slidesUp(-1*power);\n    }\n\n    public void slideOut(double power)\n    {\n        slide_3.setPower(power);\n    }\n\n    public void slideIn(double power)\n    {\n        slideOut(-1*power);\n    }\n\n    public void rotateClawPerpendicular()\n    {\n        capServo.setPosition(0.05);\n    }\n\n    public void rotateClawInline()\n    {\n        //capServo.setPosition(0.25);\n        capServo.setPosition(0.4);\n    }\n\n    public void openClaw()\n    {\n        clawServo.setPosition(0.55);\n    }\n    public void closeClaw()\n    {\n        clawServo.setPosition(0.8);\n    }\n\n    public void closeClawSensor(double timeoutS)\n    {\n        if (timeoutS < 10)\n        clawServo.setPosition(0.8);\n    }\n\n    public void moveFoundationServoUp() {\n        FLServo.setPosition(0);\n        FRServo.setPosition(0);\n    }\n\n    public void moveFoundationServoDown() {\n        FLServo.setPosition(0.5);\n        FRServo.setPosition(0.5);\n    }\n\n    public void closeCapStoneClaw()\n    {\n        capServo.setPosition(0.0);\n    }\n\n    public void openCapStoneClaw()\n    {\n        //capServo.setPosition(0.25);\n        capServo.setPosition(0.7);\n    }\n\n    public void measureTapeOut() {\n        tapeServo.setPower(1);\n        //VexServo.setPower(1);\n    }\n\n    public void measureTapeIn() {\n        tapeServo.setPower(-1);\n        //VexServo.setPower(1);\n    }\n\n    public void measureTapeStop() {\n        tapeServo.setPower(0);\n        //VexServo.setPower(1);\n    }\n\n\n    public void resetCollectionServo () {\n        CollectLeftMotor.setPower(0);\n        CollectRightMotor.setPower(0);\n\n    }\n\n    public void setCollectionServo() {\n        CollectLeftMotor.setPower(1);\n        CollectRightMotor.setPower(1);\n    }\n\n    public void setGrabberDown(int side) {\n        if (side == 0) {\n            //Left\n            GrabberLeftTurnServo.setPosition(0.45);\n        } else\n        {\n           //Right\n           GrabberRightTurnServo.setPosition(0.45);\n       }\n\n    }\n\n    public void setGrabberHalfDown(int side) {\n        if (side == 0) {\n            //Left\n            GrabberLeftTurnServo.setPosition(0.4);\n        } else\n        {\n            //Right\n            GrabberRightTurnServo.setPosition(0.37);\n        }\n    }\n\n\n    public void setGrabberUp(int side) {\n        if (side == 0) {\n            //Left\n            GrabberLeftTurnServo.setPosition(0.1);\n        } else\n        {\n            //Right\n            GrabberRightTurnServo.setPosition(0.1);\n        }\n    }\n\n    public void closeGrabberClaw(int side) {\n\n        if (side == 0) {\n            //Left\n            GrabberLeftClawServo.setPosition(0);\n\n        } else\n        {\n            //Right\n\n            GrabberRightClawServo.setPosition(0);\n        }\n    }\n\n    public void openGrabberClaw(int side) {\n\n        if (side == 0) {\n            //Left\n            GrabberLeftClawServo.setPosition(0.5);\n        } else\n        {\n            //Right\n\n            GrabberRightClawServo.setPosition(0.5);\n        }\n    }\n\n\n\n}
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISHW.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISHW.java	(date 1609716235570)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode;
+package org.firstinspires.ftc.teamcode.TestPrograms;
 
 import com.qualcomm.hardware.bosch.BNO055IMU;
 import com.qualcomm.robotcore.hardware.CRServo;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISManual.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.robotcore.hardware.CRServo;\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.util.ElapsedTime;\nimport com.qualcomm.robotcore.util.Range;\nimport com.qualcomm.robotcore.util.RobotLog;\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.Gamepad;\n\n\n@TeleOp(name = \"JARVIS Manual\", group = \"Linear Opmode\")\n//@Disabled\n\npublic class JARVISManual extends JARVISAutonomousBase {\n    @Override\n    public void runOpMode() {\n        //This is where we set our motor powers\n        double motor_power = 0.3;\n\n        float leftX, leftY, rightZ;\n\n        telemetry.addData(\"Status\", \"Initialized\");\n        telemetry.update();\n        initHW();\n        robot.openCapStoneClaw();\n\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n\n        runtime.reset();\n\n        // run until the end of the match (driver presses STOP)\n        while (opModeIsActive()) {\n            telemetry.addData(\"Status\", \"Run Time: \" + runtime.toString());\n            telemetry.update();\n            //all of the code bellow is setting a power to each button on the gamepad\n\n            if ((gamepad1.left_stick_y != 0) || (gamepad1.left_stick_x != 0) || (gamepad1.right_stick_x != 0)) {\n                leftY = gamepad1.left_stick_y;\n                leftX = gamepad1.left_stick_x * -1;\n                rightZ = gamepad1.right_stick_x * -1;\n                robot.moveHolonomic(leftX, leftY, rightZ);\n            } else if (gamepad1.dpad_down) {\n                //forward\n                robot.moveHolonomic(0, motor_power * 1, 0);\n            } else if (gamepad1.dpad_up) {\n                //backwards\n                robot.moveHolonomic(0, motor_power * -1, 0);\n            } else if (gamepad1.dpad_left) {\n                //rotate counter-clockwise\n                robot.moveHolonomic(0, 0, motor_power * 1);\n            } else if (gamepad1.dpad_right) {\n                //rotate clockwise\n                robot.moveHolonomic(0, 0, motor_power * -1);\n            } else if (gamepad1.x) {\n                robot.openGrabberClaw(0);\n                robot.openGrabberClaw(1);\n            } else if (gamepad1.b) {\n                robot.closeGrabberClaw(0);\n                robot.closeGrabberClaw(1);\n            } else if (gamepad1.y) {\n                robot.setGrabberDown(0);\n                robot.setGrabberDown(1);\n            } else if (gamepad1.a) {\n                robot.setGrabberUp(0);\n                robot.setGrabberUp(1);\n           } else if (gamepad1.right_trigger > 0.5) {\n                //StrafeRight slow\n                robot.moveHolonomic(-0.4, 0, 0);\n            } else if (gamepad1.left_trigger > 0.5) {\n                //StrafeLeft slow\n                robot.moveHolonomic(0.4, 0, 0);\n            } else if (gamepad1.left_bumper){\n                robot.moveFoundationServoUp();\n            } else if (gamepad1.right_bumper) {\n                robot.moveFoundationServoDown();\n            } else if (gamepad2.dpad_up) {\n                robot.slidesUp(0.8);\n                //myEncoderSlide1(Direction.SLIDE_UP, 0.9, 6, 4, SensorsToUse.NONE); //moves the slide up 6 inches every time\n            } else if (gamepad2.dpad_down) {\n                //robot.closeClaw(); //closes the claw\n                robot.slidesDown(0.2);\n                //myEncoderSlide1(Direction.SLIDE_DOWN, 0.9, 6, 4, SensorsToUse.NONE); //moves the slide down 6 inches every time\n           } else if (gamepad2.dpad_left) {\n                robot.slideIn(0.5);\n            } else if (gamepad2.dpad_right) {\n                robot.slideOut(0.5);\n            } else if (gamepad2.x) {\n                robot.openClaw();  //opens the claw\n            } else if (gamepad2.b) {\n                robot.closeClaw(); //closes the claw\n            } else if (gamepad2.y) {\n                robot.rotateClawPerpendicular();  //claw perpendicular\n            } else if (gamepad2.a) {\n                robot.rotateClawInline(); //claw inline\n            } else if (gamepad2.left_trigger > 0.5){\n                robot.resetCollectionServo();\n            } else if (gamepad2.right_trigger > 0.5) {\n                robot.openClaw();  //Automatically opens the claw\n                robot.setCollectionServo();\n            } else if (gamepad2.left_bumper){\n                robot.closeCapStoneClaw();\n            } else if (gamepad2.right_bumper) {\n                robot.openCapStoneClaw();\n            } else if (gamepad2.left_stick_y > 0) {\n                robot.measureTapeOut();\n            } else if (gamepad2.left_stick_y < 0) {\n                robot.measureTapeIn();\n            }  else{\n                robot.stopAllMotors();\n            }\n            if (robot.touch_sensor.isPressed() ) {\n                telemetry.addData(\"TOUCH SENSOR IS PRESSED\", \"THE BLOCK IS IN THE CLAW - YOU CAN NOW CLOSE THE CLAW\");\n                //robot.closeClawSensor(10); //closes the claw\n            } else {\n                telemetry.addData(\"not\", \"pressed\");\n            }\n\n            telemetry.update();\n        }\n        telemetry.addData(\"Status\", \"Run Time: \" + runtime.toString());\n        telemetry.update();\n\n    }\n}\n\n\n\n\n\n\n\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISManual.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISManual.java	(date 1609716235462)
@@ -1,17 +1,8 @@
-package org.firstinspires.ftc.teamcode;
+package org.firstinspires.ftc.teamcode.TestPrograms;
 
-import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
-import com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.robotcore.hardware.CRServo;
-import com.qualcomm.robotcore.hardware.DcMotorSimple;
-import com.qualcomm.robotcore.hardware.Servo;
-import com.qualcomm.robotcore.util.ElapsedTime;
-import com.qualcomm.robotcore.util.Range;
-import com.qualcomm.robotcore.util.RobotLog;
-import com.qualcomm.robotcore.eventloop.opmode.OpMode;
-import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
-import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
-import com.qualcomm.robotcore.hardware.Gamepad;
+
+import org.firstinspires.ftc.teamcode.TestPrograms.JARVISAutonomousBase;
 
 
 @TeleOp(name = "JARVIS Manual", group = "Linear Opmode")
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISAutoBlue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport java.util.List;\n@Autonomous(name=\"Jarvis Auto Blue\", group=\"JARVIS\")\n\npublic class JARVISAutoBlue extends JARVISAutonomousBase {\n    static final int SIDE = 0; //Left side claw\n\n    @Override\n    public void runOpMode() {\n        RobotLog.ii(\"CAL\", \"Enter  - runOpMode - JARVIS Autonomous 1\");\n        initHW(); //initialize hardware\n        ref_angle = getAngle(); //get the current angle and make it the reference angle for the rest of the program\n\n        // Send a telemetry message to signifyrobot waiting;\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n\n        //run the function that actually moves the robot\n        myDetectionRun(40.0);\n        RobotLog.ii(\"CAL\", \"Exit - runOpMode - JARVIS Autonomous 1\");\n    }\n\n    public void correctAngle()\n    {\n        double currentAngle = 0;\n        currentAngle = getAngle(); //get the current angle\n\n        //subtract the reference angle from the current angle and rotate that many degrees\n        //so that the robot is aligned with the starting position\n        rotate((int)((-1)*(currentAngle - ref_angle)), 0.2);\n        sleep(200);\n    }\n\n    public void getStone()\n    {\n        //strafe away from the skystone so we have space to pick it up\n        myEncoderDrive(Direction.STRAFE_RIGHT, 0.2, 3, 5.0, SensorsToUse.NONE);\n        robot.openGrabberClaw(SIDE); //open the claw\n        sleep(100);\n        robot.setGrabberHalfDown(SIDE); //put the claw half down\n        sleep(100);\n        //strafe closer to the skystone so we can pick it up\n        myEncoderDrive(Direction.STRAFE_LEFT, DRIVE_SPEED,3, 5.0, SensorsToUse.NONE);\n        sleep(200);\n        robot.setGrabberDown(SIDE); //put the claw all the way down on top of the stone\n        sleep(500);\n        robot.closeGrabberClaw(SIDE); //close the claw, holding the stone\n        sleep(500);\n        robot.setGrabberUp(SIDE); //put the claw up so that it is vertical and doesn't drag on the ground\n        sleep(500);\n        //strafe towards the wall a little bit so we don't collide with the bridge\n        myEncoderDrive(Direction.STRAFE_RIGHT, DRIVE_SPEED,4, 5.0, SensorsToUse.NONE);\n        sleep(100);\n    }\n\n    public void releaseStone()\n    {\n        robot.setGrabberDown(SIDE); //put the claw down\n        sleep(150);\n        robot.openGrabberClaw(SIDE); //open the claw, letting go of the skystone\n        sleep(200);\n        robot.setGrabberUp(SIDE); //put the claw up\n        sleep(100);\n        robot.closeGrabberClaw(SIDE); //close the claw so it doesn't hit the top of the bridge\n        sleep(100);\n    }\n\n    public void myDetectionRun(double timeoutS)\n    {\n        RobotLog.ii(\"CAL\", \"Enter i- myDetectionRun\");\n        //a variable that holds the number of inches we move from the stone closest to the bridge\n        //to the skystone so we know how much extra we need to move to always end up the\n        //same distance on the other side of the bridge\n        double strafe_back_previous = 0;\n        //same as above except for the second skystone\n        double strafe_back = 0;\n\n        //initialize the motor encoders\n        robot.initMotorEncoders();\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested()) {\n            //MOve towards the skystones using a distance sensor so we don't collide with them\n            myEncoderDrive(Direction.STRAFE_LEFT, 0.2, 50, 5.0, SensorsToUse.USE_DISTANCE_LEFT);\n            //align with the reference angle\n            correctAngle();\n\n            //if the first stone we see is NOT a skystone, continue to move forward while sensing\n            //stop whenever the color sensed is not yellow, but black (skystone)\n            //add the extra distance traveled using the color sensor to strafe_back_previous\n            if (myDetectSkystone(SideToUse.USE_LEFT, 10) == false) {\n                myEncoderDrive(Direction.FORWARD, 0.1, 24, 10.0, SensorsToUse.USE_COLOR_LEFT);\n                strafe_back_previous = distance_traveled;\n                telemetry.addData(\"strafe back = \", strafe_back_previous);\n                telemetry.update();\n                //go backward an inch to be sure that we're aligned with the middle of the skystone\n                myEncoderDrive(Direction.BACKWARD, 0.1, 1, 5.0, SensorsToUse.NONE);\n            }\n\n            //Grab the skystone and go to the other side of the bridge\n            getStone();\n            myEncoderDrive(Direction.BACKWARD, DRIVE_SPEED, 35 + strafe_back_previous, 10.0, SensorsToUse.NONE);\n\n            //drop the skystone\n            releaseStone();\n\n            //Drive back to collect the second stone\n            myEncoderDrive(Direction.FORWARD, DRIVE_SPEED, 52 + strafe_back_previous, 10.0, SensorsToUse.NONE);\n\n            //Drive till we are close to the stone again\n            myEncoderDrive(Direction.STRAFE_LEFT, 0.2,24, 5.0, SensorsToUse.USE_DISTANCE_LEFT);\n\n            //move forward while sensing using the color sensor\n            //stop whenever the color sensed is not yellow, but black (skystone)\n            //add the extra distance traveled using the color sensor to strafe_back\n            myEncoderDrive(Direction.FORWARD, 0.1, 20, 5.0, SensorsToUse.USE_COLOR_LEFT);\n            strafe_back = distance_traveled;\n            telemetry.addData(\"strafe back = \", strafe_back);\n            telemetry.update();\n            myEncoderDrive(Direction.STRAFE_LEFT, DRIVE_SPEED,2, 5.0, SensorsToUse.NONE);\n            //Grab the skystone\n            getStone();\n            //second time, we need to strafe an extra inch to avoid the bridge\n            myEncoderDrive(Direction.STRAFE_RIGHT, DRIVE_SPEED,3, 5.0, SensorsToUse.NONE);\n            correctAngle(); //correct angle to match the reference angle\n\n            //drive to other side and drop the stone\n            myEncoderDrive(Direction.BACKWARD, 0.4, 52 + strafe_back_previous + strafe_back, 10.0, SensorsToUse.NONE);\n            releaseStone();\n\n            //drive under the bridge then strafe towards the bridge so that our alliance also has space to park\n            myEncoderDrive(Direction.FORWARD, 0.4, 15, 10.0, SensorsToUse.NONE);\n            myEncoderDrive(Direction.STRAFE_LEFT, DRIVE_SPEED,5, 5.0, SensorsToUse.NONE);\n            robot.openCapStoneClaw();\n\n        }\n        RobotLog.ii(\"CAL\", \"Exit - myDetectionRun\");\n    }\n}\n\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISAutoBlue.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoBlue.java	(date 1609716235626)
@@ -1,12 +1,14 @@
-package org.firstinspires.ftc.teamcode;
+package org.firstinspires.ftc.teamcode.TestPrograms;
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import java.util.List;
+import org.firstinspires.ftc.teamcode.TestPrograms.JARVISAutonomousBase;
+
 @Autonomous(name="Jarvis Auto Blue", group="JARVIS")
 
 public class JARVISAutoBlue extends JARVISAutonomousBase {
     static final int SIDE = 0; //Left side claw
+    double DRIVE_SPEED = 0.3;
 
     @Override
     public void runOpMode() {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/TrackingWheelLateralDistanceTuner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive.opmode;\n\nimport com.acmerobotics.dashboard.config.Config;\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\nimport com.acmerobotics.roadrunner.util.Angle;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;\nimport org.firstinspires.ftc.teamcode.drive.StandardTrackingWheelLocalizer;\n\n/**\n * Opmode designed to assist the user in tuning the `StandardTrackingWheelLocalizer`'s\n * LATERAL_DISTANCE value. The LATERAL_DISTANCE is the center-to-center distance of the parallel\n * wheels.\n *\n * Tuning Routine:\n *\n * 1. Set the LATERAL_DISTANCE value in StandardTrackingWheelLocalizer.java to the physical\n * measured value. This need only be an estimated value as you will be tuning it anyways.\n *\n * 2. Make a mark on the bot (with a piece of tape or sharpie or however you wish) and make an\n * similar mark right below the indicator on your bot. This will be your reference point to\n * ensure you've turned exactly 360°.\n *\n * 3. Although not entirely necessary, having the bot's pose being drawn in dashbooard does help\n * identify discrepancies in the LATERAL_DISTANCE value. To access the dashboard,\n * connect your computer to the RC's WiFi network. In your browser, navigate to\n * https://192.168.49.1:8080/dash if you're using the RC phone or https://192.168.43.1:8080/dash\n * if you are using the Control Hub.\n * Ensure the field is showing (select the field view in top right of the page).\n *\n * 4. Press play to begin the tuning routine.\n *\n * 5. Use the right joystick on gamepad 1 to turn the bot counterclockwise.\n *\n * 6. Spin the bot 10 times, counterclockwise. Make sure to keep track of these turns.\n *\n * 7. Once the bot has finished spinning 10 times, press A to finishing the routine. The indicators\n * on the bot and on the ground you created earlier should be lined up.\n *\n * 8. Your effective LATERAL_DISTANCE will be given. Stick this value into your\n * StandardTrackingWheelLocalizer.java class.\n *\n * 9. If this value is incorrect, run the routine again while adjusting the LATERAL_DISTANCE value\n * yourself. Read the heading output and follow the advice stated in the note below to manually\n * nudge the values yourself.\n *\n * Note:\n * It helps to pay attention to how the pose on the field is drawn in dashboard. A blue circle with\n * a line from the circumference to the center should be present, representing the bot. The line\n * indicates forward. If your LATERAL_DISTANCE value is tuned currently, the pose drawn in\n * dashboard should keep track with the pose of your actual bot. If the drawn bot turns slower than\n * the actual bot, the LATERAL_DISTANCE should be decreased. If the drawn bot turns faster than the\n * actual bot, the LATERAL_DISTANCE should be increased.\n *\n * If your drawn bot oscillates around a point in dashboard, don't worry. This is because the\n * position of the perpendicular wheel isn't perfectly set and causes a discrepancy in the\n * effective center of rotation. You can ignore this effect. The center of rotation will be offset\n * slightly but your heading will still be fine. This does not affect your overall tracking\n * precision. The heading should still line up.\n */\n@Config\n@TeleOp(group = \"drive\")\npublic class TrackingWheelLateralDistanceTuner extends LinearOpMode {\n    public static int NUM_TURNS = 10;\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\n\n        if (!(drive.getLocalizer() instanceof StandardTrackingWheelLocalizer)) {\n            RobotLog.setGlobalErrorMsg(\"StandardTrackingWheelLocalizer is not being set in the \"\n                    + \"drive class. Ensure that \\\"setLocalizer(new StandardTrackingWheelLocalizer\"\n                    + \"(hardwareMap));\\\" is called in SampleMecanumDrive.java\");\n        }\n\n        telemetry.addLine(\"Prior to beginning the routine, please read the directions \"\n                + \"located in the comments of the opmode file.\");\n        telemetry.addLine(\"Press play to begin the tuning routine.\");\n        telemetry.addLine(\"\");\n        telemetry.addLine(\"Press Y/△ to stop the routine.\");\n        telemetry.update();\n\n        waitForStart();\n\n        if (isStopRequested()) return;\n\n        telemetry.clearAll();\n        telemetry.update();\n\n        double headingAccumulator = 0;\n        double lastHeading = 0;\n\n        boolean tuningFinished = false;\n\n        while (!isStopRequested() && !tuningFinished) {\n            Pose2d vel = new Pose2d(0, 0, -gamepad1.right_stick_x);\n            drive.setDrivePower(vel);\n\n            drive.update();\n\n            double heading = drive.getPoseEstimate().getHeading();\n            double deltaHeading = heading - lastHeading;\n\n            headingAccumulator += Angle.normDelta(deltaHeading);\n            lastHeading = heading;\n\n            telemetry.clearAll();\n            telemetry.addLine(\"Total Heading (deg): \" + Math.toDegrees(headingAccumulator));\n            telemetry.addLine(\"Raw Heading (deg): \" + Math.toDegrees(heading));\n            telemetry.addLine();\n            telemetry.addLine(\"Press Y/△ to conclude routine\");\n            telemetry.update();\n\n            if (gamepad1.y)\n                tuningFinished = true;\n        }\n\n        telemetry.clearAll();\n        telemetry.addLine(\"Localizer's total heading: \" + Math.toDegrees(headingAccumulator) + \"°\");\n        telemetry.addLine(\"Effective LATERAL_DISTANCE: \" +\n                (headingAccumulator / (NUM_TURNS * Math.PI * 2)) * StandardTrackingWheelLocalizer.LATERAL_DISTANCE);\n\n        telemetry.update();\n\n        while (!isStopRequested()) idle();\n    }\n}
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/opmode/TrackingWheelLateralDistanceTuner.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/rdrive/opmode/TrackingWheelLateralDistanceTuner.java	(date 1609716235645)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode.drive.opmode;
+package org.firstinspires.ftc.teamcode.TestPrograms.rdrive.opmode;
 
 import com.acmerobotics.dashboard.config.Config;
 import com.acmerobotics.roadrunner.geometry.Pose2d;
@@ -7,8 +7,8 @@
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
-import org.firstinspires.ftc.teamcode.drive.StandardTrackingWheelLocalizer;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.SampleMecanumDrive;
+import org.firstinspires.ftc.teamcode.TestPrograms.rdrive.StandardTrackingWheelLocalizer;
 
 /**
  * Opmode designed to assist the user in tuning the `StandardTrackingWheelLocalizer`'s
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISAutoParkNear.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.util.RobotLog;\n\n@Autonomous(name=\"JARVIS Auto Park Near\", group=\"JARVIS\")\n\npublic class JARVISAutoParkNear extends JARVISAutonomousBase {\n\n    JARVISHW robotJARVIS = new JARVISHW();\n\n    @Override\n    public void runOpMode() {\n        // Initializes the motors so they are ready for use.\n        robot.init(hardwareMap);\n        // move the foundation attachment up to the start position\n        moveFoundationServoUp();\n\n        ref_angle = getAngle();\n        telemetry.addData(\"status\", \"ref_angle = %f\", ref_angle);\n        telemetry.update();\n\n\n        // Send telemetry message to signify robot waiting;\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n\n        // Runs the program\n        autoBLDFoundation();\n    }\n\n    public void autoBLDFoundation()\n    {\n        RobotLog.ii(\"CAL\", \"Enter - JARVISAutoBLD2Blue\");\n\n        //initialized the motor encoders\n        robot.initMotorEncoders();\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested() )\n        {\n            //Wait for 25 seconds until the end of the autonomous period\n            sleep(25000);\n            //move forward onto the line\n            myEncoderDrive(Direction.BACKWARD, 0.2, 31, 5, SensorsToUse.NONE);\n        }\n        RobotLog.ii(\"CAL\", \"Exit - JARVISAutoBLD2Blue\");\n    }\n\n}
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISAutoParkNear.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoParkNear.java	(date 1609716235429)
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode;
+package org.firstinspires.ftc.teamcode.TestPrograms;
 
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.util.RobotLog;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISAutonomousBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\nimport android.app.Activity;\nimport android.graphics.Color;\nimport android.view.View;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.hardware.ColorSensor;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\nimport com.qualcomm.robotcore.util.ElapsedTime;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\nimport org.firstinspires.ftc.teamcode.JARVISHW;\n\nimport java.util.List;\nimport java.util.Locale;\n\n//@Disabled\npublic class JARVISAutonomousBase extends LinearOpMode {\n\n    public enum Direction\n    {\n        FORWARD, BACKWARD, STRAFE_RIGHT, STRAFE_LEFT, SLIDE_UP, SLIDE_DOWN, SLIDE_IN, SLIDE_OUT, DIAGONAL_LEFT, DIAGONAL_RIGHT;\n    }\n\n    public enum SensorsToUse\n    {\n        NONE, USE_COLOR_LEFT, USE_COLOR_RIGHT, USE_DISTANCE_LEFT, USE_DISTANCE_RIGHT, USE_TOUCH,\n        USE_DISTANCE_RIGHT_BLD, USE_DISTANCE_LEFT_BLD, USE_DISTANCE_LEFT_FDT, USE_DISTANCE_RIGHT_FDT,\n        USE_DISTANCE_FRONT;\n    }\n\n    public enum SideToUse\n    {\n        USE_LEFT, USE_RIGHT;\n    }\n    public JARVISHW robot = new JARVISHW();\n    public ElapsedTime runtime = new ElapsedTime();\n    private Orientation lastAngles = new Orientation();\n    private double globalAngle = 0;\n    // public direction;\n    public double ref_angle = 0;\n    public double ref_angle_1 = 0;\n\n    public Direction direction;\n\n    public double distance_traveled = 0;\n\n    static final double COUNTS_PER_MOTOR_REV  = 145.6;    // eg: goBilda 5202 Motor Encoder 5.2*28\n    static final double DRIVE_GEAR_REDUCTION  = 2.0;     // This is < 1.0 if geared UP\n    static final double WHEEL_DIAMETER_INCHES = 4.0;     // For figuring circumference\n    static final double COUNTS_PER_INCH       = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) / (WHEEL_DIAMETER_INCHES * 3.1415);\n    static final double PULLEY_COUNTS_PER_INCH       = (50.9 * 28 ) / (1 * 3.1415); //gobilda 5202 117 rpm motors\n    static final double INOUT_COUNTS_PER_INCH       = (19.2 * 28 ) / (2 * 3.1415); //gobilda 5202 117 rpm motors\n\n    static final double DRIVE_SPEED = 0.3;\n    static final double TURN_SPEED  = 0.7;\n\n    private static final String TFOD_MODEL_ASSET     = \"Skystone.tflite\";\n    private static final String LABEL_FIRST_ELEMENT  = \"Stone\";\n    private static final String LABEL_SECOND_ELEMENT = \"Skystone\";\n    final String VUFORIA_KEY = \"ATVrdOT/////AAABmegFa9L6UUB2ljwRjEStPmU7NS6gi/+GLAe6uAv7o+cB7+pj9EORNLk32cxovTaRj+rUeNw75EMjs5jM0K2OlNn8iO861FyZ5bqnHeBQRr/tR4NIZkQq4ak2zpPLQyyGFzhEkHjnhenYh0dyvxluXF79u8VwJ+g77slCyrCjvgMp6VfEAPLpVJmjzq4hRJMtjYpoRp/agnYFU8HVnmQeGRbjKi1PHLbhP98IkGMowt6Hlobdd2l0vt7msVhwNombHz0XcwJEjwnRKoOkeg7s+kIWvd5paYiO/bnClo9DahFboEFWw1/9wutXgI6/7AGcvwZzkk1HwRh3qZRAWNUSq1hrcjdq9f2QXAYyiqd3wLpT\";\n\n\n    public TFObjectDetector tfod    = null;\n    public VuforiaLocalizer vuforia = null;\n\n    @Override\n    public void runOpMode() {\n        //Empty Function\n    }\n\n    private void initVuforia() {\n        RobotLog.ii(\"CAL\", \"Enter -  initVuforia\");\n\n        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n        parameters.vuforiaLicenseKey           = VUFORIA_KEY;\n        parameters.cameraDirection             = VuforiaLocalizer.CameraDirection.BACK;\n        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n\n        RobotLog.ii(\"CAL\", \"Exit -  initVuforia\");\n        telemetry.addData(\"Path1\", \"Init Vuforia Done\");\n        telemetry.update();\n    }\n\n    private void initTfod() {\n        RobotLog.ii(\"CAL\", \"Enter -  initTfod\");\n        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n        tfodParameters.minimumConfidence = 0.8;\n        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n\n        RobotLog.ii(\"CAL\", \"Exit -  initTfod\");\n        telemetry.addData(\"Path1\", \"initTfod Done\");\n        telemetry.update();\n    }\n\n    public void initHW() {\n        RobotLog.ii(\"CAL\", \"Enter -  initHW\");\n        robot.init(hardwareMap);\n        robot.openCapStoneClaw();\n        //robot.initMotorEncoders();\n        /*\n        initVuforia();\n\n        if (ClassFactory.getInstance().canCreateTFObjectDetector()) {\n            initTfod();\n        } else {\n            telemetry.addData(\"Sorry!\", \"This device is not compatible with TFOD\");\n        }\n\n        if (tfod != null) {\n            tfod.activate();\n        }\n        */\n        telemetry.addData(\"Path1\", \"Init HW Done\");\n        telemetry.update();\n\n        RobotLog.ii(\"CAL\", \"Exit -  initHW\");\n    }\n\n    private void resetAngle() {\n        lastAngles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n        RobotLog.ii(\"CAL\", \"resetAngle - lastAngles = %2.2f\", lastAngles.firstAngle);\n        globalAngle = 0;\n    }\n\n    public double getAngle() {\n        // We experimentally determined the Z axis is the axis we want to use for heading angle.\n        // We have to process the angle because the imu works in euler angles so the Z axis is\n        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes\n        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.\n\n        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n\n        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;\n\n        if (deltaAngle < -180)\n            deltaAngle += 360;\n        else if (deltaAngle > 180)\n            deltaAngle -= 360;\n\n        globalAngle += deltaAngle;\n\n        lastAngles = angles;\n\n        return globalAngle;\n    }\n\n    public double getAbsoluteAngle() {\n        // We experimentally determined the Z axis is the axis we want to use for heading angle.\n        // We have to process the angle because the imu works in euler angles so the Z axis is\n        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes\n        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.\n\n        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n\n        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;\n\n        if (deltaAngle < -180)\n            deltaAngle += 360;\n        else if (deltaAngle > 180)\n            deltaAngle -= 360;\n\n        globalAngle += deltaAngle;\n\n        lastAngles = angles;\n\n        return globalAngle;\n    }\n\n\n    public void rotate(int degrees, double power) {\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\n                degrees, power);\n        robot.initMotorNoEncoders();\n        // restart imu movement tracking.\n        resetAngle();\n\n        if (degrees < 0)\n        {   // turn right.\n            robot.moveHolonomic(0, 0, power*-1);\n        }\n        else if (degrees > 0)\n        {   // turn left.\n            robot.moveHolonomic(0, 0, power*1);\n        }\n        else return;\n\n\n\n        // rotate until turn is completed.\n        if (degrees < 0) {\n            // On right turn we have to get off zero first.\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\n            }\n\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\n            }\n        } else    // left turn.\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\n            }\n\n        // turn the motors off.\n        power = 0;\n        robot.leftMotor.setPower(power);\n        robot.rightMotor.setPower(power);\n        robot.backleftMotor.setPower(power);\n        robot.backrightMotor.setPower(power);\n\n        // wait for rotation to stop.\n        sleep(50);\n\n        // reset angle tracking on new heading.\n        resetAngle();\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\n    }\n\n    public void rotateFrontUsingOneSide(int degrees, double speed) {\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\n                degrees, speed);\n\n        // restart imu movement tracking.\n        resetAngle();\n\n        if (degrees < 0)\n        {   // turn right.\n            robot.leftMotor.setPower(0);\n            robot.rightMotor.setPower(1 * speed);\n            robot.backleftMotor.setPower(0);\n            robot.backrightMotor.setPower(1 * speed);\n        }\n        else if (degrees > 0)\n        {   // turn left.\n            robot.leftMotor.setPower(1 * speed);\n            robot.rightMotor.setPower(0);\n            robot.backleftMotor.setPower(1 * speed);\n            robot.backrightMotor.setPower(0);\n        }\n        else return;\n\n\n\n        // rotate until turn is completed.\n        if (degrees < 0) {\n            // On right turn we have to get off zero first.\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\n            }\n\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\n            }\n        } else    // left turn.\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\n            }\n\n        // turn the motors off.\n        int power = 0;\n        robot.leftMotor.setPower(power);\n        robot.rightMotor.setPower(power);\n        robot.backleftMotor.setPower(power);\n        robot.backrightMotor.setPower(power);\n\n        // wait for rotation to stop.\n        sleep(50);\n\n        // reset angle tracking on new heading.\n        resetAngle();\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\n    }\n\n    public void rotateUsingOneSide(int degrees, double speed) {\n        //logs that get added to a file to see what was wrong with the robot and the sequences of it\n        RobotLog.ii(\"CAL\", \"Enter - rotate - degrees=%d, power=%f\",\n                degrees, speed);\n\n        // restart imu movement tracking.\n        resetAngle();\n\n        if (degrees < 0)\n        {   // turn right.\n            robot.leftMotor.setPower(0);\n            robot.rightMotor.setPower(-1 * speed);\n            robot.backleftMotor.setPower(0);\n            robot.backrightMotor.setPower(-1 * speed);\n        }\n        else if (degrees > 0)\n        {   // turn left.\n            robot.leftMotor.setPower(-1 * speed);\n            robot.rightMotor.setPower(0);\n            robot.backleftMotor.setPower(-1 * speed);\n            robot.backrightMotor.setPower(0);\n        }\n        else return;\n\n\n\n        // rotate until turn is completed.\n        if (degrees < 0) {\n            // On right turn we have to get off zero first.\n            while (opModeIsActive() && !isStopRequested() && getAngle() == 0) {\n            }\n\n            while (opModeIsActive() && !isStopRequested() && getAngle() > degrees) {\n            }\n        } else    // left turn.\n            while (opModeIsActive() && !isStopRequested() && getAngle() < degrees) {\n            }\n\n        // turn the motors off.\n        int power = 0;\n        robot.leftMotor.setPower(power);\n        robot.rightMotor.setPower(power);\n        robot.backleftMotor.setPower(power);\n        robot.backrightMotor.setPower(power);\n\n        // wait for rotation to stop.\n        sleep(50);\n\n        // reset angle tracking on new heading.\n        resetAngle();\n        RobotLog.ii(\"CAL\", \"Exit - rotate\");\n    }\n\n\n    public void myEncoderDrive(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\n        int newLeftTarget = 0;\n        int newRightTarget = 0;\n        int newLeftBackTarget = 0;\n        int newRightBackTarget = 0;\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderDrive -  speed=%f, Inches=%f, timeout=%f\",\n                speed, Inches, timeoutS);\n\n        robot.leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.backleftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.backrightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        //Reset the encoder\n        robot.leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.backrightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.backleftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested()) {\n\n            // Determine new target position, and pass to motor controller\n            if (direction == Direction.FORWARD) {\n                //Go forward\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n            } else if (direction == Direction.BACKWARD) {\n                //Go backward\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n            } else if (direction == Direction.STRAFE_RIGHT) {\n                //Strafe Right\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n\n            } else if (direction == Direction.STRAFE_LEFT) {\n                //Strafe Left\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (-1 * Inches * COUNTS_PER_INCH);\n\n            } else if (direction == Direction.DIAGONAL_LEFT) {\n                //Left Diagonal\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n\n            } else if (direction == Direction.DIAGONAL_RIGHT) {\n                //Right Diagonal\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n\n            } else {\n                Inches = 0;\n                newLeftTarget = robot.rightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightTarget = robot.leftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newLeftBackTarget = robot.backrightMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n                newRightBackTarget = robot.backleftMotor.getCurrentPosition() + (int) (Inches * COUNTS_PER_INCH);\n            }\n\n\n            robot.leftMotor.setTargetPosition(newLeftTarget);\n            robot.rightMotor.setTargetPosition(newRightTarget);\n            robot.backleftMotor.setTargetPosition(newLeftBackTarget);\n            robot.backrightMotor.setTargetPosition(newRightBackTarget);\n\n            // Turn On RUN_TO_POSITION\n            robot.leftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n            robot.rightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n            robot.backleftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n            robot.backrightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n            // reset the timeout time and start motion.\n            runtime.reset();\n\n            robot.leftMotor.setPower(Math.abs(speed));\n            robot.rightMotor.setPower(Math.abs(speed));\n            robot.backleftMotor.setPower(Math.abs(speed));\n            robot.backrightMotor.setPower(Math.abs(speed));\n\n            while (opModeIsActive() && !isStopRequested() &&\n                    (runtime.seconds() < timeoutS) &&\n                    (robot.leftMotor.isBusy())) {\n\n               if (sensors_2_use == SensorsToUse.USE_DISTANCE_LEFT) {\n                    if(robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH) <= 7) {\n                        robot.stopAllMotors();\n\n                        telemetry.addData(\"LeftDistSensor\", \"The robot is %7f inches from crashing.\",\n                                robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH));\n                        telemetry.update();\n                        break;\n\n                    }\n                }\n\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_RIGHT) {\n                    if(robot.sensorDistanceRight.getDistance(DistanceUnit.INCH) <= 7) {\n                        robot.stopAllMotors();\n\n                        telemetry.addData(\"RightDistSensor\", \"The robot is %7f inches from crashing.\",\n                                robot.sensorDistanceRight.getDistance(DistanceUnit.INCH));\n                        telemetry.update();\n                        break;\n\n                    }\n                }\n                if (sensors_2_use == SensorsToUse.USE_COLOR_LEFT) {\n\n                    if (myDetectSkystone(SideToUse.USE_LEFT, 2) == true)\n                    {\n                        robot.stopAllMotors();\n                        //telemetry.addData(\"LeftColorSensor\", \"The robot detected Skystone\");\n                        //telemetry.update();\n                        break;\n                    }\n                }\n                if (sensors_2_use == SensorsToUse.USE_COLOR_RIGHT) {\n\n                    if (myDetectSkystone(SideToUse.USE_RIGHT, 2) == true)\n                    {\n                        robot.stopAllMotors();\n                        //telemetry.addData(\"LeftColorSensor\", \"The robot detected Skystone\");\n                        //telemetry.update();\n                        break;\n                    }\n                }\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_RIGHT_BLD) {\n                    if(robot.sensorDistanceRight.getDistance(DistanceUnit.INCH) <= 2) {\n                        robot.stopAllMotors();\n\n                        telemetry.addData(\"RightDistSensor\", \"The robot is %7f inches from crashing.\",\n                                robot.sensorDistanceRight.getDistance(DistanceUnit.INCH));\n                        telemetry.update();\n                        break;\n                    }\n                }\n\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_LEFT_BLD) {\n                    if(robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH) <= 2) {\n                        robot.stopAllMotors();\n\n                        telemetry.addData(\"LeftDistSensor\", \"The robot is %7f inches from crashing.\",\n                                robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH));\n                        telemetry.update();\n                        break;\n                    }\n                }\n\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_LEFT_FDT) {\n                    if(robot.sensorDistanceLeft.getDistance(DistanceUnit.INCH) > 20) {\n                        robot.stopAllMotors();\n                    }\n                }\n\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_RIGHT_FDT) {\n                    if(robot.sensorDistanceRight.getDistance(DistanceUnit.INCH) > 20) {\n                        robot.stopAllMotors();\n                    }\n                }\n\n                if (sensors_2_use == SensorsToUse.USE_DISTANCE_FRONT) {\n                    if(robot.sensorDistanceFL.getDistance(DistanceUnit.INCH) <23) {\n                        robot.stopAllMotors();\n                    }\n                }\n\n\n            }\n        }\n\n        // Stop all motion;\n        robot.leftMotor.setPower(0);\n        robot.rightMotor.setPower(0);\n        robot.backleftMotor.setPower(0);\n        robot.backrightMotor.setPower(0);\n\n        distance_traveled = robot.rightMotor.getCurrentPosition() / COUNTS_PER_INCH;\n\n        // Turn off RUN_TO_POSITION\n        robot.leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        robot.rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        robot.backleftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        robot.backrightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        sleep(50);   // optional pause after each move\n    }\n\n    /*\n    public void myEncoderSlide(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\n        int newLeftTarget = 0;\n        int newRightTarget = 0;\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderSlide -  speed=%f, Inches=%f, timeout=%f\",\n                speed, Inches, timeoutS);\n\n        robot.slide_1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.slide_1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        //robot.slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        //robot.slide_2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        //Reset the encoder\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested()) {\n\n            // Determine new target position, and pass to motor controller\n            if (direction == Direction.SLIDE_UP) {\n                //Go forward\n                newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\n                newRightTarget = robot.slide_2.getCurrentPosition() + (int) (1*Inches * PULLEY_COUNTS_PER_INCH);\n\n            } else if (direction == Direction.SLIDE_DOWN) {\n                //Go backward\n                newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (-1 * Inches * PULLEY_COUNTS_PER_INCH);\n                newRightTarget = robot.slide_2.getCurrentPosition() + (int) (-1* Inches * PULLEY_COUNTS_PER_INCH);\n            } else {\n                Inches = 0;\n                newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\n                newRightTarget = robot.slide_2.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\n            }\n\n\n            robot.slide_1.setTargetPosition(newLeftTarget);\n            robot.slide_2.setTargetPosition(newRightTarget);\n\n            // Turn On RUN_TO_POSITION\n            robot.slide_1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n            robot.slide_2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n            // reset the timeout time and start motion.\n            runtime.reset();\n\n            robot.slide_1.setPower(Math.abs(speed));\n            robot.slide_2.setPower(Math.abs(speed));\n\n            while (opModeIsActive() && !isStopRequested() &&\n                    (runtime.seconds() < timeoutS) &&\n                    (robot.slide_1.isBusy())) {\n\n\n                // Display it for the driver.\n                telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newRightTarget);\n                telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\n                        robot.slide_1.getCurrentPosition(),\n                        robot.slide_2.getCurrentPosition());\n                telemetry.update();\n            }\n        }\n\n        // Stop all motion;\n        robot.slide_1.setPower(0);\n        robot.slide_2.setPower(0);\n\n        // Turn off RUN_TO_POSITION\n        robot.slide_1.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        robot.slide_2.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n    }\n*/\n    public void myEncoderSlide1(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\n        int newLeftTarget = 0;\n        int newRightTarget = 0;\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderSlide -  speed=%f, Inches=%f, timeout=%f\",\n                speed, Inches, timeoutS);\n\n        //Reset the encoder\n        robot.slide_1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.slide_1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        //robot.slide_2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested()) {\n\n            // Determine new target position, and pass to motor controller\n            if (direction == Direction.SLIDE_UP) {\n                //Go forward\n                newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\n                //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (1*Inches * PULLEY_COUNTS_PER_INCH);\n\n            } else if (direction == Direction.SLIDE_DOWN) {\n                //Go backward\n                newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (-1 * Inches * PULLEY_COUNTS_PER_INCH);\n                //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (-1* Inches * PULLEY_COUNTS_PER_INCH);\n            } else {\n                Inches = 0;\n                newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\n                //newRightTarget = robot.slide_2.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\n            }\n\n\n            robot.slide_1.setTargetPosition(newLeftTarget);\n            //robot.slide_2.setTargetPosition(newRightTarget);\n\n            // Turn On RUN_TO_POSITION\n            robot.slide_1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n            //robot.slide_2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n            // reset the timeout time and start motion.\n            runtime.reset();\n\n            robot.slide_1.setPower(Math.abs(speed));\n            if (direction == Direction.SLIDE_DOWN){\n                //robot.slide_2.setPower((-1*speed));\n            }else {\n                //robot.slide_2.setPower((1*speed));\n\n            }\n\n            while (opModeIsActive() && !isStopRequested() &&\n                    (runtime.seconds() < timeoutS) &&\n                    (robot.slide_1.isBusy())) {\n\n\n                // Display it for the driver.\n                telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newRightTarget);\n                telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\n                        robot.slide_1.getCurrentPosition(),\n                        robot.slide_1.getCurrentPosition());\n                telemetry.update();\n            }\n        }\n\n        // Stop all motion;\n        robot.slide_1.setPower(0);\n        //robot.slide_2.setPower(0);\n\n        // Turn off RUN_TO_POSITION\n        robot.slide_1.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        //robot.slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n    }\n/*\n    public void myEncoderSlide2(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\n        int newLeftTarget = 0;\n        int newRightTarget = 0;\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderSlide -  speed=%f, Inches=%f, timeout=%f\",\n                speed, Inches, timeoutS);\n\n        //Reset the encoder\n        robot.slide_2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        //robot.slide_1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.slide_2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested()) {\n\n            // Determine new target position, and pass to motor controller\n            if (direction == Direction.SLIDE_UP) {\n                //Go forward\n                //newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\n                newRightTarget = robot.slide_2.getCurrentPosition() + (int) (1*Inches * PULLEY_COUNTS_PER_INCH);\n\n            } else if (direction == Direction.SLIDE_DOWN) {\n                //Go backward\n                //newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (-1 * Inches * PULLEY_COUNTS_PER_INCH);\n                newRightTarget = robot.slide_2.getCurrentPosition() + (int) (-1* Inches * PULLEY_COUNTS_PER_INCH);\n            } else {\n                Inches = 0;\n                //newLeftTarget = robot.slide_1.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\n                newRightTarget = robot.slide_2.getCurrentPosition() + (int) (Inches * PULLEY_COUNTS_PER_INCH);\n            }\n\n\n            //robot.slide_1.setTargetPosition(newLeftTarget);\n            robot.slide_2.setTargetPosition(newRightTarget);\n\n            // Turn On RUN_TO_POSITION\n            //robot.slide_1.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n            robot.slide_2.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n            // reset the timeout time and start motion.\n            runtime.reset();\n\n            robot.slide_2.setPower(Math.abs(speed));\n\n            while (opModeIsActive() && !isStopRequested() &&\n                    (runtime.seconds() < timeoutS) &&\n                    (robot.slide_2.isBusy())) {\n\n\n                // Display it for the driver.\n                telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newRightTarget);\n                telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\n                        robot.slide_1.getCurrentPosition(),\n                        robot.slide_2.getCurrentPosition());\n                telemetry.update();\n            }\n        }\n\n        // Stop all motion;\n        //robot.slide_1.setPower(0);\n        robot.slide_2.setPower(0);\n\n        // Turn off RUN_TO_POSITION\n        //robot.slide_1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.slide_2.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n    }\n*/\n    public void myEncoderInOutSlide(Direction direction, double speed, double Inches, double timeoutS, SensorsToUse sensors_2_use) {\n        int newLeftTarget = 0;\n        RobotLog.ii(\"CAL\", \"Enter - myEncoderInOutSlide -  speed=%f, Inches=%f, timeout=%f\",\n                speed, Inches, timeoutS);\n\n        robot.slide_3.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        robot.slide_3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested()) {\n\n            // Determine new target position, and pass to motor controller\n            if (direction == Direction.SLIDE_IN) {\n                //Go forward\n                newLeftTarget = robot.slide_3.getCurrentPosition() + (int) (Inches * INOUT_COUNTS_PER_INCH);\n\n            } else if (direction == Direction.SLIDE_OUT) {\n                //Go backward\n                newLeftTarget = robot.slide_3.getCurrentPosition() + (int) (-1 * Inches * INOUT_COUNTS_PER_INCH);\n            } else {\n                Inches = 0;\n                newLeftTarget = robot.slide_3.getCurrentPosition() + (int) (Inches * INOUT_COUNTS_PER_INCH);\n            }\n\n\n            robot.slide_3.setTargetPosition(newLeftTarget);\n\n            // Turn On RUN_TO_POSITION\n            robot.slide_3.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n            // reset the timeout time and start motion.\n            runtime.reset();\n\n            robot.slide_3.setPower(Math.abs(speed));\n\n            while (opModeIsActive() && !isStopRequested() &&\n                    (runtime.seconds() < timeoutS) &&\n                    (robot.slide_3.isBusy())) {\n\n\n                // Display it for the driver.\n                telemetry.addData(\"Path1\", \"Running to %7d :%7d\", newLeftTarget, newLeftTarget);\n                telemetry.addData(\"Path2\", \"Running at %7d :%7d\",\n                        robot.slide_3.getCurrentPosition(),\n                        robot.slide_3.getCurrentPosition());\n                telemetry.update();\n            }\n        }\n\n        // Stop all motion;\n        robot.slide_3.setPower(0);\n\n        // Turn off RUN_TO_POSITION\n        robot.slide_3.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n    }\n\n    public void myTFOD(double timeoutS) {\n        {\n            // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\n            // first.\n\n            boolean strafeDone = false;\n            RobotLog.ii(\"CAL\", \"myTFOD - Enter\");\n\n            while (opModeIsActive() && !isStopRequested()) {\n\n                if (tfod == null) {\n                    robot.moveHolonomic(0, 0, 0);\n                    break;\n                }\n\n                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n\n                if (updatedRecognitions != null) {\n                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n                    // step through the list of recognitions and display boundary info.\n                    if (updatedRecognitions.size() == 0) {\n                        robot.moveHolonomic(0, 0, 0);\n                    } else {\n                        int i = 0;\n                        for (Recognition recognition : updatedRecognitions) {\n                            if (recognition.getLabel().equals(LABEL_SECOND_ELEMENT)) {\n                                double targetHeightRatio = (float) 0.8;\n                                double imageHeight = recognition.getImageHeight();\n                                double imageWidth = recognition.getImageWidth();\n                                double objectHeight = recognition.getHeight();\n                                double objectHeightRatio = objectHeight / imageHeight;\n                                double power = 0.1;\n                                double mid = (recognition.getLeft() + recognition.getRight()) / 2;\n                                double i_left = recognition.getLeft();\n                                double i_right = recognition.getRight();\n\n                                telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n                                telemetry.addData(\" \", \"Image Width (%.1f), image Height (%.1f), object Height (%.1f)\",\n                                        imageWidth, imageHeight, objectHeight);\n                                telemetry.addData(String.format(\" init left,right (%d)\", i), \"%.03f , %.03f\",\n                                        i_left, i_right);\n\n                                if (strafeDone == false) {\n                                    if (mid < (640 - 100)) {\n                                        telemetry.addData(String.format(\" mid(%f) < 540 \", mid), \"\");\n                                        robot.moveHolonomic(-1 * power, 0, 0);\n                                    } else if (mid > (640 + 100)) {\n                                        telemetry.addData(String.format(\" mid(%f) > 740 \", mid), \"\");\n                                        robot.moveHolonomic(1 * power, 0, 0);\n                                    } else {\n                                        strafeDone = true;\n                                        robot.moveHolonomic(0, 0, 0);\n                                    }\n                                }\n\n                                if (strafeDone == true) {\n                                    telemetry.addData(\" \", \" Shank Strafe done\");\n\n                                    if (objectHeightRatio < targetHeightRatio) {\n                                        telemetry.addData(\" \", \" SHANK object < target power=%f\", power);\n\n                                        robot.moveHolonomic(0, 1 * power, 0);\n                                    } else {\n                                        robot.moveHolonomic(0, 0, 0);\n                                    }\n                                }\n\n                            } else {\n                                telemetry.addData(\"Not a skystone\", \" \");\n\n                            }\n                        }\n                    }\n                    telemetry.update();\n                }\n\n                //RobotLog.ii(\"CAL\", \"while opModeIsActive and !isStopRequested - Enter\");\n            }\n            RobotLog.ii(\"CAL\", \"Exit if opModeIsActive\");\n\n            if (tfod != null) {\n                tfod.shutdown();\n            }\n            RobotLog.ii(\"CAL\", \"myTFOD - Exits\");\n\n        }\n    }\n\n    public boolean myTFOD2(double timeoutS) {\n        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\n        // first.\n        boolean strafeDone = false;\n        RobotLog.ii(\"CAL\", \"myTFOD - Enter\");\n\n\n        while (opModeIsActive() && !isStopRequested()) {\n\n            if (tfod == null) {\n                robot.moveHolonomic(0, 0, 0);\n                break;\n            }\n\n            List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n\n            if (updatedRecognitions != null) {\n                telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n                // step through the list of recognitions and display boundary info.\n                if (updatedRecognitions.size() == 0) {\n                    robot.moveHolonomic(0, 0, 0);\n                } else {\n                    int i = 0;\n                    for (Recognition recognition : updatedRecognitions) {\n                        if (recognition.getLabel().equals(LABEL_SECOND_ELEMENT)) {\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    }\n                }\n                telemetry.update();\n                RobotLog.ii(\"CAL\", \"Exit if opModeIsActive\");\n\n                if (tfod != null) {\n                    tfod.shutdown();\n                }\n                RobotLog.ii(\"CAL\", \"myTFOD - Exits\");\n\n            }\n        }\n        return false;\n    }\n\n    public void moveFoundationServoDown () {\n        // Checks if the servos are = null or not because that is what causes the\n        // \"null pointer exception\". Once it is checked, the servos will run.\n        robot.moveFoundationServoDown();\n        /*\n        if (robot.FLServo != null) {\n            robot.FLServo.setPosition(0.21);\n        }\n        if (robot.FRServo != null) {\n            robot.FRServo.setPosition(0.21);\n        }\n         */\n    }\n\n    public void moveFoundationServoUp() {\n        // Checks if the servos are = null or not because that is what causes the\n        // \"null pointer exception\". Once it is checked, the servos will run.\n        robot.moveFoundationServoUp();\n        /*\n        if (robot.FLServo != null) {\n            robot.FLServo.setPosition(0);\n        }\n        if (robot.FRServo != null) {\n            robot.FRServo.setPosition(0);703\n        }\n         */\n    }\n    public boolean myDetectSkystone(SideToUse side, double timeoutS) {\n        RobotLog.ii(\"CAL\", \"myDetectSkystone - Enter\");\n        float hsvValues[] = {0F, 0F, 0F};\n\n        // values is a reference to the hsvValues array.\n        final float values[] = hsvValues;\n\n        // sometimes it helps to multiply the raw RGB values with a scale factor\n        // to amplify/attentuate the measured values.\n        final double SCALE_FACTOR = 255;\n\n\n        if (side == SideToUse.USE_LEFT)\n        {\n            Color.RGBToHSV((int) (robot.sensorColorLeft.red() * SCALE_FACTOR),\n                    (int) (robot.sensorColorLeft.green() * SCALE_FACTOR),\n                    (int) (robot.sensorColorLeft.blue() * SCALE_FACTOR),\n                    hsvValues);\n\n        } else {\n            Color.RGBToHSV((int) (robot.sensorColorRight.red() * SCALE_FACTOR),\n                    (int) (robot.sensorColorRight.green() * SCALE_FACTOR),\n                    (int) (robot.sensorColorRight.blue() * SCALE_FACTOR),\n                    hsvValues);\n\n        }\n\n\n        // send the info back to driver station using telemetry function.\n        telemetry.addData(\"Hue\", hsvValues[0]);\n        telemetry.update();\n\n        //BLACK and WHITE\n        if (hsvValues[0] > 100 && hsvValues[0] < 150) {\n            return true;\n        }\n        return false;\n\n    }\n\n    public boolean myDetectFoundation(SideToUse side, double timeoutS) {\n        RobotLog.ii(\"CAL\", \"myDetectFoundation - Enter\");\n        float hsvValues[] = {0F, 0F, 0F};\n\n        // values is a reference to the hsvValues array.\n        final float values[] = hsvValues;\n\n        // sometimes it helps to multiply the raw RGB values with a scale factor\n        // to amplify/attentuate the measured values.\n        final double SCALE_FACTOR = 255;\n\n\n        if (side == SideToUse.USE_LEFT)\n        {\n            Color.RGBToHSV((int) (robot.sensorColorLeft.red() * SCALE_FACTOR),\n                    (int) (robot.sensorColorLeft.green() * SCALE_FACTOR),\n                    (int) (robot.sensorColorLeft.blue() * SCALE_FACTOR),\n                    hsvValues);\n\n        } else {\n            Color.RGBToHSV((int) (robot.sensorColorRight.red() * SCALE_FACTOR),\n                    (int) (robot.sensorColorRight.green() * SCALE_FACTOR),\n                    (int) (robot.sensorColorRight.blue() * SCALE_FACTOR),\n                    hsvValues);\n\n        }\n\n\n        // send the info back to driver station using telemetry function.\n        telemetry.addData(\"Hue\", hsvValues[0]);\n        telemetry.update();\n\n        //BLACK and WHITE\n        if (hsvValues[0] > 100 && hsvValues[0] < 150) {\n            return true;\n        }\n        return false;\n\n    }\n\n    public void mySlidesAuto (double speed, double timeoutS) {\n        while (opModeIsActive() && !isStopRequested() &&\n                (runtime.seconds() < timeoutS))\n        {\n            robot.slide_1.setPower(1*speed);\n            //robot.slide_2.setPower(1*speed);\n        }\n    }\n    public void mySlideAuto (double speed, double timeoutS) {\n        while (opModeIsActive() && !isStopRequested() &&\n                (runtime.seconds() < timeoutS))\n        {\n            robot.slide_3.setPower(1*speed);\n        }\n    }\n    public void openClaw()\n    {\n        robot.clawServo.setPosition(0);\n    }\n    public void closeClaw() {\n        robot.clawServo.setPosition(1);\n    }\n\n    public void setGrabberDownAuto(int side) {\n        if (side == 0) {\n            //Left\n            robot.GrabberLeftTurnServo.setPosition(0.4);\n        } else\n        {\n            //Right\n            robot.GrabberRightTurnServo.setPosition(0.4);\n        }\n    }\n\n    public void setGrabberUpAuto(int side) {\n        if (side == 0) {\n            //Left\n            robot.GrabberLeftTurnServo.setPosition(0);\n        } else\n        {\n            //Right\n            robot.GrabberRightTurnServo.setPosition(0);\n        }\n    }\n\n    public void closeGrabberClawAuto(int side) {\n        if (side == 0) {\n            //Left\n            robot.GrabberLeftClawServo.setPosition(0);\n        } else\n        {\n            //Right\n            robot.GrabberRightClawServo.setPosition(0);\n        }\n    }\n\n    public void openGrabberClawAuto(int side) {\n        if (side == 0) {\n            //Left\n            robot.GrabberLeftClawServo.setPosition(0.5);\n        } else\n        {\n            //Right\n            robot.GrabberRightClawServo.setPosition(0.5);\n        }\n    }\n}\n
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/JARVISAutonomousBase.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutonomousBase.java	(date 1609716235697)
@@ -1,13 +1,9 @@
-package org.firstinspires.ftc.teamcode;
+package org.firstinspires.ftc.teamcode.TestPrograms;
 
-import android.app.Activity;
 import android.graphics.Color;
-import android.view.View;
 
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
-import com.qualcomm.robotcore.hardware.ColorSensor;
 import com.qualcomm.robotcore.hardware.DcMotor;
-import com.qualcomm.robotcore.hardware.DistanceSensor;
 import com.qualcomm.robotcore.util.ElapsedTime;
 import com.qualcomm.robotcore.util.RobotLog;
 
@@ -20,10 +16,8 @@
 import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
 import org.firstinspires.ftc.robotcore.external.tfod.Recognition;
 import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;
-import org.firstinspires.ftc.teamcode.JARVISHW;
 
 import java.util.List;
-import java.util.Locale;
 
 //@Disabled
 public class JARVISAutonomousBase extends LinearOpMode {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoParkGrnWheel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TestPrograms;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\nimport com.qualcomm.robotcore.util.RobotLog;\n\nimport org.firstinspires.ftc.teamcode.JARVISAutonomousBase;\nimport org.firstinspires.ftc.teamcode.JARVISHW;\n\n@Autonomous(name=\"JARVIS Auto Park Green Wheel\", group=\"JARVIS\")\n@Disabled\npublic class JARVISAutoParkGrnWheel extends JARVISAutonomousBase {\n\n    JARVISHW robotJARVIS = new JARVISHW();\n\n    @Override\n    public void runOpMode() {\n        // Initializes the motors so they are ready for use.\n        robot.init(hardwareMap);\n        // move the foundation attachment up to the start position\n        moveFoundationServoUp();\n\n        ref_angle = getAngle();\n        telemetry.addData(\"status\", \"ref_angle = %f\", ref_angle);\n        telemetry.update();\n\n\n        // Send telemetry message to signify robot waiting;\n        while (!opModeIsActive() && !isStopRequested()) {\n            telemetry.addData(\"status\", \"waiting for start command...\");\n            telemetry.update();\n        }\n\n        // Runs the program\n        autoBLDFoundation();\n    }\n\n    public void autoBLDFoundation()\n    {\n        RobotLog.ii(\"CAL\", \"Enter - JARVISAutoParkGrnWheel\");\n\n        //initialized the motor encoders\n        robot.initMotorEncoders();\n\n        // Ensure that the op mode is still active\n        if (opModeIsActive() && !isStopRequested() )\n        {\n            robot.setGrabberDown(0);\n            robot.openGrabberClaw(0);\n            sleep(1000);\n        }\n        RobotLog.ii(\"CAL\", \"Exit - JARVISAutoParkGrnWheel\");\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoParkGrnWheel.java	(revision 29a6f2a8dab863063a71e9a0a262ba0cc87fc2a2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestPrograms/JARVISAutoParkGrnWheel.java	(date 1609716235651)
@@ -4,9 +4,6 @@
 import com.qualcomm.robotcore.eventloop.opmode.Disabled;
 import com.qualcomm.robotcore.util.RobotLog;
 
-import org.firstinspires.ftc.teamcode.JARVISAutonomousBase;
-import org.firstinspires.ftc.teamcode.JARVISHW;
-
 @Autonomous(name="JARVIS Auto Park Green Wheel", group="JARVIS")
 @Disabled
 public class JARVISAutoParkGrnWheel extends JARVISAutonomousBase {
